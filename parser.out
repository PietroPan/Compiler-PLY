Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    vars
    global

Grammar

Rule 0     S' -> Prog
Rule 1     Prog -> MainBlc DefBlcs
Rule 2     DefBlcs -> DefBlcs DefBlc
Rule 3     DefBlcs -> <empty>
Rule 4     DefBlc -> id { VarBlc Insts }
Rule 5     VarBlc -> Dcls
Rule 6     Dcls -> Dcls Dcl
Rule 7     Dcls -> <empty>
Rule 8     MainBlc -> main { VarBlc Insts }
Rule 9     Insts -> Insts Inst
Rule 10    Insts -> <empty>
Rule 11    Inst -> Attr
Rule 12    Inst -> Return
Rule 13    Inst -> Exp
Rule 14    Inst -> Print
Rule 15    Inst -> Println
Rule 16    Inst -> Prints
Rule 17    Inst -> Repeat
Rule 18    Inst -> For
Rule 19    Inst -> While
Rule 20    Inst -> Read
Rule 21    Inst -> If
Rule 22    Repeat -> RepeatS ( num ) { Insts }
Rule 23    RepeatS -> repeat
Rule 24    For -> for ( Insts ; Cond ; Insts ) { Insts }
Rule 25    While -> while ( Cond ) { Insts }
Rule 26    Read -> read ( id )
Rule 27    Print -> print ( Exp )
Rule 28    Println -> println ( Exp )
Rule 29    Prints -> prints ( string )
Rule 30    Dcl -> int id [ num ]
Rule 31    Dcl -> int id [ num ] [ num ]
Rule 32    Dcl -> int id
Rule 33    Dcl -> int id = num
Rule 34    Attr -> id = Exp
Rule 35    Attr -> id [ Exp ] = Exp
Rule 36    Attr -> id [ Exp ] [ Exp ] = Exp
Rule 37    Return -> return ( Exp )
Rule 38    If -> if ( Cond ) { Insts }
Rule 39    If -> if ( Cond ) Inst
Rule 40    IfStart -> if ( Cond )
Rule 41    If -> if ( Cond ) { Insts } else { Insts }
Rule 42    ElseStart -> else
Rule 43    Exp -> Exp + Term
Rule 44    Exp -> Exp - Term
Rule 45    Exp -> id addeq Term
Rule 46    Exp -> id subeq Term
Rule 47    Exp -> id addeql Term
Rule 48    Exp -> id subeql Term
Rule 49    Exp -> Term
Rule 50    Term -> Term * Factor
Rule 51    Term -> Term / Factor
Rule 52    Term -> Term % Factor
Rule 53    Term -> id muleq Factor
Rule 54    Term -> id diveq Factor
Rule 55    Term -> id modeq Factor
Rule 56    Term -> id muleql Factor
Rule 57    Term -> id diveql Factor
Rule 58    Term -> id modeql Factor
Rule 59    Term -> Factor
Rule 60    Factor -> id plus
Rule 61    Factor -> id plusl
Rule 62    Factor -> id minus
Rule 63    Factor -> id minusl
Rule 64    Factor -> id
Rule 65    Factor -> num
Rule 66    Factor -> id ( )
Rule 67    Factor -> ( Cond )
Rule 68    Factor -> id [ Exp ]
Rule 69    Factor -> id [ Exp ] [ Exp ]
Rule 70    Factor -> ( Exp )
Rule 71    Id -> id
Rule 72    Id -> id [ Exp ]
Rule 73    Id -> id [ Exp ] [ Exp ]
Rule 74    Cond -> Cond and Cond
Rule 75    Cond -> Cond or Cond
Rule 76    Cond -> ( Cond and Cond )
Rule 77    Cond -> ( Cond or Cond )
Rule 78    Cond -> Exp sup Exp
Rule 79    Cond -> Exp inf Exp
Rule 80    Cond -> Exp supeq Exp
Rule 81    Cond -> Exp infeq Exp
Rule 82    Cond -> not Exp
Rule 83    Cond -> Exp eq Exp
Rule 84    Cond -> Exp diff Exp

Terminals, with rules where they appear

%                    : 52
(                    : 22 24 25 26 27 28 29 37 38 39 40 41 66 67 70 76 77
)                    : 22 24 25 26 27 28 29 37 38 39 40 41 66 67 70 76 77
*                    : 50
+                    : 43
-                    : 44
/                    : 51
;                    : 24 24
=                    : 33 34 35 36
[                    : 30 31 31 35 36 36 68 69 69 72 73 73
]                    : 30 31 31 35 36 36 68 69 69 72 73 73
addeq                : 45
addeql               : 47
and                  : 74 76
diff                 : 84
diveq                : 54
diveql               : 57
else                 : 41 42
eq                   : 83
error                : 
for                  : 24
global               : 
id                   : 4 26 30 31 32 33 34 35 36 45 46 47 48 53 54 55 56 57 58 60 61 62 63 64 66 68 69 71 72 73
if                   : 38 39 40 41
inf                  : 79
infeq                : 81
int                  : 30 31 32 33
main                 : 8
minus                : 62
minusl               : 63
modeq                : 55
modeql               : 58
muleq                : 53
muleql               : 56
not                  : 82
num                  : 22 30 31 31 33 65
or                   : 75 77
plus                 : 60
plusl                : 61
print                : 27
println              : 28
prints               : 29
read                 : 26
repeat               : 23
return               : 37
string               : 29
subeq                : 46
subeql               : 48
sup                  : 78
supeq                : 80
vars                 : 
while                : 25
{                    : 4 8 22 24 25 38 41 41
}                    : 4 8 22 24 25 38 41 41

Nonterminals, with rules where they appear

Attr                 : 11
Cond                 : 24 25 38 39 40 41 67 74 74 75 75 76 76 77 77
Dcl                  : 6
Dcls                 : 5 6
DefBlc               : 2
DefBlcs              : 1 2
ElseStart            : 
Exp                  : 13 27 28 34 35 35 36 36 36 37 43 44 68 69 69 70 72 73 73 78 78 79 79 80 80 81 81 82 83 83 84 84
Factor               : 50 51 52 53 54 55 56 57 58 59
For                  : 18
Id                   : 
If                   : 21
IfStart              : 
Inst                 : 9 39
Insts                : 4 8 9 22 24 24 24 25 38 41 41
MainBlc              : 1
Print                : 14
Println              : 15
Prints               : 16
Prog                 : 0
Read                 : 20
Repeat               : 17
RepeatS              : 22
Return               : 12
Term                 : 43 44 45 46 47 48 49 50 51 52
VarBlc               : 4 8
While                : 19

Parsing method: LALR

state 0

    (0) S' -> . Prog
    (1) Prog -> . MainBlc DefBlcs
    (8) MainBlc -> . main { VarBlc Insts }

    main            shift and go to state 3

    Prog                           shift and go to state 1
    MainBlc                        shift and go to state 2

state 1

    (0) S' -> Prog .



state 2

    (1) Prog -> MainBlc . DefBlcs
    (2) DefBlcs -> . DefBlcs DefBlc
    (3) DefBlcs -> .

    id              reduce using rule 3 (DefBlcs -> .)
    $end            reduce using rule 3 (DefBlcs -> .)

    DefBlcs                        shift and go to state 4

state 3

    (8) MainBlc -> main . { VarBlc Insts }

    {               shift and go to state 5


state 4

    (1) Prog -> MainBlc DefBlcs .
    (2) DefBlcs -> DefBlcs . DefBlc
    (4) DefBlc -> . id { VarBlc Insts }

    $end            reduce using rule 1 (Prog -> MainBlc DefBlcs .)
    id              shift and go to state 7

    DefBlc                         shift and go to state 6

state 5

    (8) MainBlc -> main { . VarBlc Insts }
    (5) VarBlc -> . Dcls
    (6) Dcls -> . Dcls Dcl
    (7) Dcls -> .

    int             reduce using rule 7 (Dcls -> .)
    }               reduce using rule 7 (Dcls -> .)
    id              reduce using rule 7 (Dcls -> .)
    return          reduce using rule 7 (Dcls -> .)
    print           reduce using rule 7 (Dcls -> .)
    println         reduce using rule 7 (Dcls -> .)
    prints          reduce using rule 7 (Dcls -> .)
    for             reduce using rule 7 (Dcls -> .)
    while           reduce using rule 7 (Dcls -> .)
    read            reduce using rule 7 (Dcls -> .)
    if              reduce using rule 7 (Dcls -> .)
    repeat          reduce using rule 7 (Dcls -> .)
    num             reduce using rule 7 (Dcls -> .)
    (               reduce using rule 7 (Dcls -> .)

    VarBlc                         shift and go to state 8
    Dcls                           shift and go to state 9

state 6

    (2) DefBlcs -> DefBlcs DefBlc .

    id              reduce using rule 2 (DefBlcs -> DefBlcs DefBlc .)
    $end            reduce using rule 2 (DefBlcs -> DefBlcs DefBlc .)


state 7

    (4) DefBlc -> id . { VarBlc Insts }

    {               shift and go to state 10


state 8

    (8) MainBlc -> main { VarBlc . Insts }
    (9) Insts -> . Insts Inst
    (10) Insts -> .

    }               reduce using rule 10 (Insts -> .)
    id              reduce using rule 10 (Insts -> .)
    return          reduce using rule 10 (Insts -> .)
    print           reduce using rule 10 (Insts -> .)
    println         reduce using rule 10 (Insts -> .)
    prints          reduce using rule 10 (Insts -> .)
    for             reduce using rule 10 (Insts -> .)
    while           reduce using rule 10 (Insts -> .)
    read            reduce using rule 10 (Insts -> .)
    if              reduce using rule 10 (Insts -> .)
    repeat          reduce using rule 10 (Insts -> .)
    num             reduce using rule 10 (Insts -> .)
    (               reduce using rule 10 (Insts -> .)

    Insts                          shift and go to state 11

state 9

    (5) VarBlc -> Dcls .
    (6) Dcls -> Dcls . Dcl
    (30) Dcl -> . int id [ num ]
    (31) Dcl -> . int id [ num ] [ num ]
    (32) Dcl -> . int id
    (33) Dcl -> . int id = num

    }               reduce using rule 5 (VarBlc -> Dcls .)
    id              reduce using rule 5 (VarBlc -> Dcls .)
    return          reduce using rule 5 (VarBlc -> Dcls .)
    print           reduce using rule 5 (VarBlc -> Dcls .)
    println         reduce using rule 5 (VarBlc -> Dcls .)
    prints          reduce using rule 5 (VarBlc -> Dcls .)
    for             reduce using rule 5 (VarBlc -> Dcls .)
    while           reduce using rule 5 (VarBlc -> Dcls .)
    read            reduce using rule 5 (VarBlc -> Dcls .)
    if              reduce using rule 5 (VarBlc -> Dcls .)
    repeat          reduce using rule 5 (VarBlc -> Dcls .)
    num             reduce using rule 5 (VarBlc -> Dcls .)
    (               reduce using rule 5 (VarBlc -> Dcls .)
    int             shift and go to state 13

    Dcl                            shift and go to state 12

state 10

    (4) DefBlc -> id { . VarBlc Insts }
    (5) VarBlc -> . Dcls
    (6) Dcls -> . Dcls Dcl
    (7) Dcls -> .

    int             reduce using rule 7 (Dcls -> .)
    }               reduce using rule 7 (Dcls -> .)
    id              reduce using rule 7 (Dcls -> .)
    return          reduce using rule 7 (Dcls -> .)
    print           reduce using rule 7 (Dcls -> .)
    println         reduce using rule 7 (Dcls -> .)
    prints          reduce using rule 7 (Dcls -> .)
    for             reduce using rule 7 (Dcls -> .)
    while           reduce using rule 7 (Dcls -> .)
    read            reduce using rule 7 (Dcls -> .)
    if              reduce using rule 7 (Dcls -> .)
    repeat          reduce using rule 7 (Dcls -> .)
    num             reduce using rule 7 (Dcls -> .)
    (               reduce using rule 7 (Dcls -> .)

    VarBlc                         shift and go to state 14
    Dcls                           shift and go to state 9

state 11

    (8) MainBlc -> main { VarBlc Insts . }
    (9) Insts -> Insts . Inst
    (11) Inst -> . Attr
    (12) Inst -> . Return
    (13) Inst -> . Exp
    (14) Inst -> . Print
    (15) Inst -> . Println
    (16) Inst -> . Prints
    (17) Inst -> . Repeat
    (18) Inst -> . For
    (19) Inst -> . While
    (20) Inst -> . Read
    (21) Inst -> . If
    (34) Attr -> . id = Exp
    (35) Attr -> . id [ Exp ] = Exp
    (36) Attr -> . id [ Exp ] [ Exp ] = Exp
    (37) Return -> . return ( Exp )
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (27) Print -> . print ( Exp )
    (28) Println -> . println ( Exp )
    (29) Prints -> . prints ( string )
    (22) Repeat -> . RepeatS ( num ) { Insts }
    (24) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (25) While -> . while ( Cond ) { Insts }
    (26) Read -> . read ( id )
    (38) If -> . if ( Cond ) { Insts }
    (39) If -> . if ( Cond ) Inst
    (41) If -> . if ( Cond ) { Insts } else { Insts }
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (23) RepeatS -> . repeat
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    }               shift and go to state 15
    id              shift and go to state 28
    return          shift and go to state 29
    print           shift and go to state 32
    println         shift and go to state 33
    prints          shift and go to state 34
    for             shift and go to state 37
    while           shift and go to state 38
    read            shift and go to state 39
    if              shift and go to state 40
    repeat          shift and go to state 42
    num             shift and go to state 36
    (               shift and go to state 30

    Inst                           shift and go to state 16
    Attr                           shift and go to state 17
    Return                         shift and go to state 18
    Exp                            shift and go to state 19
    Print                          shift and go to state 20
    Println                        shift and go to state 21
    Prints                         shift and go to state 22
    Repeat                         shift and go to state 23
    For                            shift and go to state 24
    While                          shift and go to state 25
    Read                           shift and go to state 26
    If                             shift and go to state 27
    Term                           shift and go to state 31
    RepeatS                        shift and go to state 35
    Factor                         shift and go to state 41

state 12

    (6) Dcls -> Dcls Dcl .

    int             reduce using rule 6 (Dcls -> Dcls Dcl .)
    }               reduce using rule 6 (Dcls -> Dcls Dcl .)
    id              reduce using rule 6 (Dcls -> Dcls Dcl .)
    return          reduce using rule 6 (Dcls -> Dcls Dcl .)
    print           reduce using rule 6 (Dcls -> Dcls Dcl .)
    println         reduce using rule 6 (Dcls -> Dcls Dcl .)
    prints          reduce using rule 6 (Dcls -> Dcls Dcl .)
    for             reduce using rule 6 (Dcls -> Dcls Dcl .)
    while           reduce using rule 6 (Dcls -> Dcls Dcl .)
    read            reduce using rule 6 (Dcls -> Dcls Dcl .)
    if              reduce using rule 6 (Dcls -> Dcls Dcl .)
    repeat          reduce using rule 6 (Dcls -> Dcls Dcl .)
    num             reduce using rule 6 (Dcls -> Dcls Dcl .)
    (               reduce using rule 6 (Dcls -> Dcls Dcl .)


state 13

    (30) Dcl -> int . id [ num ]
    (31) Dcl -> int . id [ num ] [ num ]
    (32) Dcl -> int . id
    (33) Dcl -> int . id = num

    id              shift and go to state 43


state 14

    (4) DefBlc -> id { VarBlc . Insts }
    (9) Insts -> . Insts Inst
    (10) Insts -> .

    }               reduce using rule 10 (Insts -> .)
    id              reduce using rule 10 (Insts -> .)
    return          reduce using rule 10 (Insts -> .)
    print           reduce using rule 10 (Insts -> .)
    println         reduce using rule 10 (Insts -> .)
    prints          reduce using rule 10 (Insts -> .)
    for             reduce using rule 10 (Insts -> .)
    while           reduce using rule 10 (Insts -> .)
    read            reduce using rule 10 (Insts -> .)
    if              reduce using rule 10 (Insts -> .)
    repeat          reduce using rule 10 (Insts -> .)
    num             reduce using rule 10 (Insts -> .)
    (               reduce using rule 10 (Insts -> .)

    Insts                          shift and go to state 44

state 15

    (8) MainBlc -> main { VarBlc Insts } .

    id              reduce using rule 8 (MainBlc -> main { VarBlc Insts } .)
    $end            reduce using rule 8 (MainBlc -> main { VarBlc Insts } .)


state 16

    (9) Insts -> Insts Inst .

    }               reduce using rule 9 (Insts -> Insts Inst .)
    id              reduce using rule 9 (Insts -> Insts Inst .)
    return          reduce using rule 9 (Insts -> Insts Inst .)
    print           reduce using rule 9 (Insts -> Insts Inst .)
    println         reduce using rule 9 (Insts -> Insts Inst .)
    prints          reduce using rule 9 (Insts -> Insts Inst .)
    for             reduce using rule 9 (Insts -> Insts Inst .)
    while           reduce using rule 9 (Insts -> Insts Inst .)
    read            reduce using rule 9 (Insts -> Insts Inst .)
    if              reduce using rule 9 (Insts -> Insts Inst .)
    repeat          reduce using rule 9 (Insts -> Insts Inst .)
    num             reduce using rule 9 (Insts -> Insts Inst .)
    (               reduce using rule 9 (Insts -> Insts Inst .)
    ;               reduce using rule 9 (Insts -> Insts Inst .)
    )               reduce using rule 9 (Insts -> Insts Inst .)


state 17

    (11) Inst -> Attr .

    }               reduce using rule 11 (Inst -> Attr .)
    id              reduce using rule 11 (Inst -> Attr .)
    return          reduce using rule 11 (Inst -> Attr .)
    print           reduce using rule 11 (Inst -> Attr .)
    println         reduce using rule 11 (Inst -> Attr .)
    prints          reduce using rule 11 (Inst -> Attr .)
    for             reduce using rule 11 (Inst -> Attr .)
    while           reduce using rule 11 (Inst -> Attr .)
    read            reduce using rule 11 (Inst -> Attr .)
    if              reduce using rule 11 (Inst -> Attr .)
    repeat          reduce using rule 11 (Inst -> Attr .)
    num             reduce using rule 11 (Inst -> Attr .)
    (               reduce using rule 11 (Inst -> Attr .)
    ;               reduce using rule 11 (Inst -> Attr .)
    )               reduce using rule 11 (Inst -> Attr .)


state 18

    (12) Inst -> Return .

    }               reduce using rule 12 (Inst -> Return .)
    id              reduce using rule 12 (Inst -> Return .)
    return          reduce using rule 12 (Inst -> Return .)
    print           reduce using rule 12 (Inst -> Return .)
    println         reduce using rule 12 (Inst -> Return .)
    prints          reduce using rule 12 (Inst -> Return .)
    for             reduce using rule 12 (Inst -> Return .)
    while           reduce using rule 12 (Inst -> Return .)
    read            reduce using rule 12 (Inst -> Return .)
    if              reduce using rule 12 (Inst -> Return .)
    repeat          reduce using rule 12 (Inst -> Return .)
    num             reduce using rule 12 (Inst -> Return .)
    (               reduce using rule 12 (Inst -> Return .)
    ;               reduce using rule 12 (Inst -> Return .)
    )               reduce using rule 12 (Inst -> Return .)


state 19

    (13) Inst -> Exp .
    (43) Exp -> Exp . + Term
    (44) Exp -> Exp . - Term

    }               reduce using rule 13 (Inst -> Exp .)
    id              reduce using rule 13 (Inst -> Exp .)
    return          reduce using rule 13 (Inst -> Exp .)
    print           reduce using rule 13 (Inst -> Exp .)
    println         reduce using rule 13 (Inst -> Exp .)
    prints          reduce using rule 13 (Inst -> Exp .)
    for             reduce using rule 13 (Inst -> Exp .)
    while           reduce using rule 13 (Inst -> Exp .)
    read            reduce using rule 13 (Inst -> Exp .)
    if              reduce using rule 13 (Inst -> Exp .)
    repeat          reduce using rule 13 (Inst -> Exp .)
    num             reduce using rule 13 (Inst -> Exp .)
    (               reduce using rule 13 (Inst -> Exp .)
    ;               reduce using rule 13 (Inst -> Exp .)
    )               reduce using rule 13 (Inst -> Exp .)
    +               shift and go to state 45
    -               shift and go to state 46


state 20

    (14) Inst -> Print .

    }               reduce using rule 14 (Inst -> Print .)
    id              reduce using rule 14 (Inst -> Print .)
    return          reduce using rule 14 (Inst -> Print .)
    print           reduce using rule 14 (Inst -> Print .)
    println         reduce using rule 14 (Inst -> Print .)
    prints          reduce using rule 14 (Inst -> Print .)
    for             reduce using rule 14 (Inst -> Print .)
    while           reduce using rule 14 (Inst -> Print .)
    read            reduce using rule 14 (Inst -> Print .)
    if              reduce using rule 14 (Inst -> Print .)
    repeat          reduce using rule 14 (Inst -> Print .)
    num             reduce using rule 14 (Inst -> Print .)
    (               reduce using rule 14 (Inst -> Print .)
    ;               reduce using rule 14 (Inst -> Print .)
    )               reduce using rule 14 (Inst -> Print .)


state 21

    (15) Inst -> Println .

    }               reduce using rule 15 (Inst -> Println .)
    id              reduce using rule 15 (Inst -> Println .)
    return          reduce using rule 15 (Inst -> Println .)
    print           reduce using rule 15 (Inst -> Println .)
    println         reduce using rule 15 (Inst -> Println .)
    prints          reduce using rule 15 (Inst -> Println .)
    for             reduce using rule 15 (Inst -> Println .)
    while           reduce using rule 15 (Inst -> Println .)
    read            reduce using rule 15 (Inst -> Println .)
    if              reduce using rule 15 (Inst -> Println .)
    repeat          reduce using rule 15 (Inst -> Println .)
    num             reduce using rule 15 (Inst -> Println .)
    (               reduce using rule 15 (Inst -> Println .)
    ;               reduce using rule 15 (Inst -> Println .)
    )               reduce using rule 15 (Inst -> Println .)


state 22

    (16) Inst -> Prints .

    }               reduce using rule 16 (Inst -> Prints .)
    id              reduce using rule 16 (Inst -> Prints .)
    return          reduce using rule 16 (Inst -> Prints .)
    print           reduce using rule 16 (Inst -> Prints .)
    println         reduce using rule 16 (Inst -> Prints .)
    prints          reduce using rule 16 (Inst -> Prints .)
    for             reduce using rule 16 (Inst -> Prints .)
    while           reduce using rule 16 (Inst -> Prints .)
    read            reduce using rule 16 (Inst -> Prints .)
    if              reduce using rule 16 (Inst -> Prints .)
    repeat          reduce using rule 16 (Inst -> Prints .)
    num             reduce using rule 16 (Inst -> Prints .)
    (               reduce using rule 16 (Inst -> Prints .)
    ;               reduce using rule 16 (Inst -> Prints .)
    )               reduce using rule 16 (Inst -> Prints .)


state 23

    (17) Inst -> Repeat .

    }               reduce using rule 17 (Inst -> Repeat .)
    id              reduce using rule 17 (Inst -> Repeat .)
    return          reduce using rule 17 (Inst -> Repeat .)
    print           reduce using rule 17 (Inst -> Repeat .)
    println         reduce using rule 17 (Inst -> Repeat .)
    prints          reduce using rule 17 (Inst -> Repeat .)
    for             reduce using rule 17 (Inst -> Repeat .)
    while           reduce using rule 17 (Inst -> Repeat .)
    read            reduce using rule 17 (Inst -> Repeat .)
    if              reduce using rule 17 (Inst -> Repeat .)
    repeat          reduce using rule 17 (Inst -> Repeat .)
    num             reduce using rule 17 (Inst -> Repeat .)
    (               reduce using rule 17 (Inst -> Repeat .)
    ;               reduce using rule 17 (Inst -> Repeat .)
    )               reduce using rule 17 (Inst -> Repeat .)


state 24

    (18) Inst -> For .

    }               reduce using rule 18 (Inst -> For .)
    id              reduce using rule 18 (Inst -> For .)
    return          reduce using rule 18 (Inst -> For .)
    print           reduce using rule 18 (Inst -> For .)
    println         reduce using rule 18 (Inst -> For .)
    prints          reduce using rule 18 (Inst -> For .)
    for             reduce using rule 18 (Inst -> For .)
    while           reduce using rule 18 (Inst -> For .)
    read            reduce using rule 18 (Inst -> For .)
    if              reduce using rule 18 (Inst -> For .)
    repeat          reduce using rule 18 (Inst -> For .)
    num             reduce using rule 18 (Inst -> For .)
    (               reduce using rule 18 (Inst -> For .)
    ;               reduce using rule 18 (Inst -> For .)
    )               reduce using rule 18 (Inst -> For .)


state 25

    (19) Inst -> While .

    }               reduce using rule 19 (Inst -> While .)
    id              reduce using rule 19 (Inst -> While .)
    return          reduce using rule 19 (Inst -> While .)
    print           reduce using rule 19 (Inst -> While .)
    println         reduce using rule 19 (Inst -> While .)
    prints          reduce using rule 19 (Inst -> While .)
    for             reduce using rule 19 (Inst -> While .)
    while           reduce using rule 19 (Inst -> While .)
    read            reduce using rule 19 (Inst -> While .)
    if              reduce using rule 19 (Inst -> While .)
    repeat          reduce using rule 19 (Inst -> While .)
    num             reduce using rule 19 (Inst -> While .)
    (               reduce using rule 19 (Inst -> While .)
    ;               reduce using rule 19 (Inst -> While .)
    )               reduce using rule 19 (Inst -> While .)


state 26

    (20) Inst -> Read .

    }               reduce using rule 20 (Inst -> Read .)
    id              reduce using rule 20 (Inst -> Read .)
    return          reduce using rule 20 (Inst -> Read .)
    print           reduce using rule 20 (Inst -> Read .)
    println         reduce using rule 20 (Inst -> Read .)
    prints          reduce using rule 20 (Inst -> Read .)
    for             reduce using rule 20 (Inst -> Read .)
    while           reduce using rule 20 (Inst -> Read .)
    read            reduce using rule 20 (Inst -> Read .)
    if              reduce using rule 20 (Inst -> Read .)
    repeat          reduce using rule 20 (Inst -> Read .)
    num             reduce using rule 20 (Inst -> Read .)
    (               reduce using rule 20 (Inst -> Read .)
    ;               reduce using rule 20 (Inst -> Read .)
    )               reduce using rule 20 (Inst -> Read .)


state 27

    (21) Inst -> If .

    }               reduce using rule 21 (Inst -> If .)
    id              reduce using rule 21 (Inst -> If .)
    return          reduce using rule 21 (Inst -> If .)
    print           reduce using rule 21 (Inst -> If .)
    println         reduce using rule 21 (Inst -> If .)
    prints          reduce using rule 21 (Inst -> If .)
    for             reduce using rule 21 (Inst -> If .)
    while           reduce using rule 21 (Inst -> If .)
    read            reduce using rule 21 (Inst -> If .)
    if              reduce using rule 21 (Inst -> If .)
    repeat          reduce using rule 21 (Inst -> If .)
    num             reduce using rule 21 (Inst -> If .)
    (               reduce using rule 21 (Inst -> If .)
    ;               reduce using rule 21 (Inst -> If .)
    )               reduce using rule 21 (Inst -> If .)


state 28

    (34) Attr -> id . = Exp
    (35) Attr -> id . [ Exp ] = Exp
    (36) Attr -> id . [ Exp ] [ Exp ] = Exp
    (45) Exp -> id . addeq Term
    (46) Exp -> id . subeq Term
    (47) Exp -> id . addeql Term
    (48) Exp -> id . subeql Term
    (53) Term -> id . muleq Factor
    (54) Term -> id . diveq Factor
    (55) Term -> id . modeq Factor
    (56) Term -> id . muleql Factor
    (57) Term -> id . diveql Factor
    (58) Term -> id . modeql Factor
    (60) Factor -> id . plus
    (61) Factor -> id . plusl
    (62) Factor -> id . minus
    (63) Factor -> id . minusl
    (64) Factor -> id .
    (66) Factor -> id . ( )
    (68) Factor -> id . [ Exp ]
    (69) Factor -> id . [ Exp ] [ Exp ]

  ! shift/reduce conflict for ( resolved as shift
    =               shift and go to state 47
    [               shift and go to state 48
    addeq           shift and go to state 49
    subeq           shift and go to state 50
    addeql          shift and go to state 51
    subeql          shift and go to state 52
    muleq           shift and go to state 53
    diveq           shift and go to state 54
    modeq           shift and go to state 55
    muleql          shift and go to state 56
    diveql          shift and go to state 57
    modeql          shift and go to state 58
    plus            shift and go to state 59
    plusl           shift and go to state 60
    minus           shift and go to state 61
    minusl          shift and go to state 62
    *               reduce using rule 64 (Factor -> id .)
    /               reduce using rule 64 (Factor -> id .)
    %               reduce using rule 64 (Factor -> id .)
    +               reduce using rule 64 (Factor -> id .)
    -               reduce using rule 64 (Factor -> id .)
    }               reduce using rule 64 (Factor -> id .)
    id              reduce using rule 64 (Factor -> id .)
    return          reduce using rule 64 (Factor -> id .)
    print           reduce using rule 64 (Factor -> id .)
    println         reduce using rule 64 (Factor -> id .)
    prints          reduce using rule 64 (Factor -> id .)
    for             reduce using rule 64 (Factor -> id .)
    while           reduce using rule 64 (Factor -> id .)
    read            reduce using rule 64 (Factor -> id .)
    if              reduce using rule 64 (Factor -> id .)
    repeat          reduce using rule 64 (Factor -> id .)
    num             reduce using rule 64 (Factor -> id .)
    ;               reduce using rule 64 (Factor -> id .)
    )               reduce using rule 64 (Factor -> id .)
    (               shift and go to state 63

  ! (               [ reduce using rule 64 (Factor -> id .) ]


state 29

    (37) Return -> return . ( Exp )

    (               shift and go to state 64


state 30

    (67) Factor -> ( . Cond )
    (70) Factor -> ( . Exp )
    (74) Cond -> . Cond and Cond
    (75) Cond -> . Cond or Cond
    (76) Cond -> . ( Cond and Cond )
    (77) Cond -> . ( Cond or Cond )
    (78) Cond -> . Exp sup Exp
    (79) Cond -> . Exp inf Exp
    (80) Cond -> . Exp supeq Exp
    (81) Cond -> . Exp infeq Exp
    (82) Cond -> . not Exp
    (83) Cond -> . Exp eq Exp
    (84) Cond -> . Exp diff Exp
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    (               shift and go to state 65
    not             shift and go to state 68
    id              shift and go to state 69
    num             shift and go to state 36

    Cond                           shift and go to state 66
    Exp                            shift and go to state 67
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 31

    (49) Exp -> Term .
    (50) Term -> Term . * Factor
    (51) Term -> Term . / Factor
    (52) Term -> Term . % Factor

    +               reduce using rule 49 (Exp -> Term .)
    -               reduce using rule 49 (Exp -> Term .)
    }               reduce using rule 49 (Exp -> Term .)
    id              reduce using rule 49 (Exp -> Term .)
    return          reduce using rule 49 (Exp -> Term .)
    print           reduce using rule 49 (Exp -> Term .)
    println         reduce using rule 49 (Exp -> Term .)
    prints          reduce using rule 49 (Exp -> Term .)
    for             reduce using rule 49 (Exp -> Term .)
    while           reduce using rule 49 (Exp -> Term .)
    read            reduce using rule 49 (Exp -> Term .)
    if              reduce using rule 49 (Exp -> Term .)
    repeat          reduce using rule 49 (Exp -> Term .)
    num             reduce using rule 49 (Exp -> Term .)
    (               reduce using rule 49 (Exp -> Term .)
    )               reduce using rule 49 (Exp -> Term .)
    sup             reduce using rule 49 (Exp -> Term .)
    inf             reduce using rule 49 (Exp -> Term .)
    supeq           reduce using rule 49 (Exp -> Term .)
    infeq           reduce using rule 49 (Exp -> Term .)
    eq              reduce using rule 49 (Exp -> Term .)
    diff            reduce using rule 49 (Exp -> Term .)
    ;               reduce using rule 49 (Exp -> Term .)
    ]               reduce using rule 49 (Exp -> Term .)
    and             reduce using rule 49 (Exp -> Term .)
    or              reduce using rule 49 (Exp -> Term .)
    *               shift and go to state 70
    /               shift and go to state 71
    %               shift and go to state 72


state 32

    (27) Print -> print . ( Exp )

    (               shift and go to state 73


state 33

    (28) Println -> println . ( Exp )

    (               shift and go to state 74


state 34

    (29) Prints -> prints . ( string )

    (               shift and go to state 75


state 35

    (22) Repeat -> RepeatS . ( num ) { Insts }

    (               shift and go to state 76


state 36

    (65) Factor -> num .

    *               reduce using rule 65 (Factor -> num .)
    /               reduce using rule 65 (Factor -> num .)
    %               reduce using rule 65 (Factor -> num .)
    +               reduce using rule 65 (Factor -> num .)
    -               reduce using rule 65 (Factor -> num .)
    }               reduce using rule 65 (Factor -> num .)
    id              reduce using rule 65 (Factor -> num .)
    return          reduce using rule 65 (Factor -> num .)
    print           reduce using rule 65 (Factor -> num .)
    println         reduce using rule 65 (Factor -> num .)
    prints          reduce using rule 65 (Factor -> num .)
    for             reduce using rule 65 (Factor -> num .)
    while           reduce using rule 65 (Factor -> num .)
    read            reduce using rule 65 (Factor -> num .)
    if              reduce using rule 65 (Factor -> num .)
    repeat          reduce using rule 65 (Factor -> num .)
    num             reduce using rule 65 (Factor -> num .)
    (               reduce using rule 65 (Factor -> num .)
    )               reduce using rule 65 (Factor -> num .)
    sup             reduce using rule 65 (Factor -> num .)
    inf             reduce using rule 65 (Factor -> num .)
    supeq           reduce using rule 65 (Factor -> num .)
    infeq           reduce using rule 65 (Factor -> num .)
    eq              reduce using rule 65 (Factor -> num .)
    diff            reduce using rule 65 (Factor -> num .)
    ;               reduce using rule 65 (Factor -> num .)
    ]               reduce using rule 65 (Factor -> num .)
    and             reduce using rule 65 (Factor -> num .)
    or              reduce using rule 65 (Factor -> num .)


state 37

    (24) For -> for . ( Insts ; Cond ; Insts ) { Insts }

    (               shift and go to state 77


state 38

    (25) While -> while . ( Cond ) { Insts }

    (               shift and go to state 78


state 39

    (26) Read -> read . ( id )

    (               shift and go to state 79


state 40

    (38) If -> if . ( Cond ) { Insts }
    (39) If -> if . ( Cond ) Inst
    (41) If -> if . ( Cond ) { Insts } else { Insts }

    (               shift and go to state 80


state 41

    (59) Term -> Factor .

    *               reduce using rule 59 (Term -> Factor .)
    /               reduce using rule 59 (Term -> Factor .)
    %               reduce using rule 59 (Term -> Factor .)
    +               reduce using rule 59 (Term -> Factor .)
    -               reduce using rule 59 (Term -> Factor .)
    }               reduce using rule 59 (Term -> Factor .)
    id              reduce using rule 59 (Term -> Factor .)
    return          reduce using rule 59 (Term -> Factor .)
    print           reduce using rule 59 (Term -> Factor .)
    println         reduce using rule 59 (Term -> Factor .)
    prints          reduce using rule 59 (Term -> Factor .)
    for             reduce using rule 59 (Term -> Factor .)
    while           reduce using rule 59 (Term -> Factor .)
    read            reduce using rule 59 (Term -> Factor .)
    if              reduce using rule 59 (Term -> Factor .)
    repeat          reduce using rule 59 (Term -> Factor .)
    num             reduce using rule 59 (Term -> Factor .)
    (               reduce using rule 59 (Term -> Factor .)
    )               reduce using rule 59 (Term -> Factor .)
    sup             reduce using rule 59 (Term -> Factor .)
    inf             reduce using rule 59 (Term -> Factor .)
    supeq           reduce using rule 59 (Term -> Factor .)
    infeq           reduce using rule 59 (Term -> Factor .)
    eq              reduce using rule 59 (Term -> Factor .)
    diff            reduce using rule 59 (Term -> Factor .)
    ;               reduce using rule 59 (Term -> Factor .)
    ]               reduce using rule 59 (Term -> Factor .)
    and             reduce using rule 59 (Term -> Factor .)
    or              reduce using rule 59 (Term -> Factor .)


state 42

    (23) RepeatS -> repeat .

    (               reduce using rule 23 (RepeatS -> repeat .)


state 43

    (30) Dcl -> int id . [ num ]
    (31) Dcl -> int id . [ num ] [ num ]
    (32) Dcl -> int id .
    (33) Dcl -> int id . = num

    [               shift and go to state 81
    int             reduce using rule 32 (Dcl -> int id .)
    }               reduce using rule 32 (Dcl -> int id .)
    id              reduce using rule 32 (Dcl -> int id .)
    return          reduce using rule 32 (Dcl -> int id .)
    print           reduce using rule 32 (Dcl -> int id .)
    println         reduce using rule 32 (Dcl -> int id .)
    prints          reduce using rule 32 (Dcl -> int id .)
    for             reduce using rule 32 (Dcl -> int id .)
    while           reduce using rule 32 (Dcl -> int id .)
    read            reduce using rule 32 (Dcl -> int id .)
    if              reduce using rule 32 (Dcl -> int id .)
    repeat          reduce using rule 32 (Dcl -> int id .)
    num             reduce using rule 32 (Dcl -> int id .)
    (               reduce using rule 32 (Dcl -> int id .)
    =               shift and go to state 82


state 44

    (4) DefBlc -> id { VarBlc Insts . }
    (9) Insts -> Insts . Inst
    (11) Inst -> . Attr
    (12) Inst -> . Return
    (13) Inst -> . Exp
    (14) Inst -> . Print
    (15) Inst -> . Println
    (16) Inst -> . Prints
    (17) Inst -> . Repeat
    (18) Inst -> . For
    (19) Inst -> . While
    (20) Inst -> . Read
    (21) Inst -> . If
    (34) Attr -> . id = Exp
    (35) Attr -> . id [ Exp ] = Exp
    (36) Attr -> . id [ Exp ] [ Exp ] = Exp
    (37) Return -> . return ( Exp )
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (27) Print -> . print ( Exp )
    (28) Println -> . println ( Exp )
    (29) Prints -> . prints ( string )
    (22) Repeat -> . RepeatS ( num ) { Insts }
    (24) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (25) While -> . while ( Cond ) { Insts }
    (26) Read -> . read ( id )
    (38) If -> . if ( Cond ) { Insts }
    (39) If -> . if ( Cond ) Inst
    (41) If -> . if ( Cond ) { Insts } else { Insts }
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (23) RepeatS -> . repeat
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    }               shift and go to state 83
    id              shift and go to state 28
    return          shift and go to state 29
    print           shift and go to state 32
    println         shift and go to state 33
    prints          shift and go to state 34
    for             shift and go to state 37
    while           shift and go to state 38
    read            shift and go to state 39
    if              shift and go to state 40
    repeat          shift and go to state 42
    num             shift and go to state 36
    (               shift and go to state 30

    Inst                           shift and go to state 16
    Attr                           shift and go to state 17
    Return                         shift and go to state 18
    Exp                            shift and go to state 19
    Print                          shift and go to state 20
    Println                        shift and go to state 21
    Prints                         shift and go to state 22
    Repeat                         shift and go to state 23
    For                            shift and go to state 24
    While                          shift and go to state 25
    Read                           shift and go to state 26
    If                             shift and go to state 27
    Term                           shift and go to state 31
    RepeatS                        shift and go to state 35
    Factor                         shift and go to state 41

state 45

    (43) Exp -> Exp + . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 85
    num             shift and go to state 36
    (               shift and go to state 30

    Term                           shift and go to state 84
    Factor                         shift and go to state 41

state 46

    (44) Exp -> Exp - . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 85
    num             shift and go to state 36
    (               shift and go to state 30

    Term                           shift and go to state 86
    Factor                         shift and go to state 41

state 47

    (34) Attr -> id = . Exp
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 69
    num             shift and go to state 36
    (               shift and go to state 30

    Exp                            shift and go to state 87
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 48

    (35) Attr -> id [ . Exp ] = Exp
    (36) Attr -> id [ . Exp ] [ Exp ] = Exp
    (68) Factor -> id [ . Exp ]
    (69) Factor -> id [ . Exp ] [ Exp ]
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 69
    num             shift and go to state 36
    (               shift and go to state 30

    Exp                            shift and go to state 88
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 49

    (45) Exp -> id addeq . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 85
    num             shift and go to state 36
    (               shift and go to state 30

    Term                           shift and go to state 89
    Factor                         shift and go to state 41

state 50

    (46) Exp -> id subeq . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 85
    num             shift and go to state 36
    (               shift and go to state 30

    Term                           shift and go to state 90
    Factor                         shift and go to state 41

state 51

    (47) Exp -> id addeql . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 85
    num             shift and go to state 36
    (               shift and go to state 30

    Term                           shift and go to state 91
    Factor                         shift and go to state 41

state 52

    (48) Exp -> id subeql . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 85
    num             shift and go to state 36
    (               shift and go to state 30

    Term                           shift and go to state 92
    Factor                         shift and go to state 41

state 53

    (53) Term -> id muleq . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 93
    num             shift and go to state 36
    (               shift and go to state 30

    Factor                         shift and go to state 94

state 54

    (54) Term -> id diveq . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 93
    num             shift and go to state 36
    (               shift and go to state 30

    Factor                         shift and go to state 95

state 55

    (55) Term -> id modeq . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 93
    num             shift and go to state 36
    (               shift and go to state 30

    Factor                         shift and go to state 96

state 56

    (56) Term -> id muleql . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 93
    num             shift and go to state 36
    (               shift and go to state 30

    Factor                         shift and go to state 97

state 57

    (57) Term -> id diveql . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 93
    num             shift and go to state 36
    (               shift and go to state 30

    Factor                         shift and go to state 98

state 58

    (58) Term -> id modeql . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 93
    num             shift and go to state 36
    (               shift and go to state 30

    Factor                         shift and go to state 99

state 59

    (60) Factor -> id plus .

    *               reduce using rule 60 (Factor -> id plus .)
    /               reduce using rule 60 (Factor -> id plus .)
    %               reduce using rule 60 (Factor -> id plus .)
    +               reduce using rule 60 (Factor -> id plus .)
    -               reduce using rule 60 (Factor -> id plus .)
    }               reduce using rule 60 (Factor -> id plus .)
    id              reduce using rule 60 (Factor -> id plus .)
    return          reduce using rule 60 (Factor -> id plus .)
    print           reduce using rule 60 (Factor -> id plus .)
    println         reduce using rule 60 (Factor -> id plus .)
    prints          reduce using rule 60 (Factor -> id plus .)
    for             reduce using rule 60 (Factor -> id plus .)
    while           reduce using rule 60 (Factor -> id plus .)
    read            reduce using rule 60 (Factor -> id plus .)
    if              reduce using rule 60 (Factor -> id plus .)
    repeat          reduce using rule 60 (Factor -> id plus .)
    num             reduce using rule 60 (Factor -> id plus .)
    (               reduce using rule 60 (Factor -> id plus .)
    )               reduce using rule 60 (Factor -> id plus .)
    sup             reduce using rule 60 (Factor -> id plus .)
    inf             reduce using rule 60 (Factor -> id plus .)
    supeq           reduce using rule 60 (Factor -> id plus .)
    infeq           reduce using rule 60 (Factor -> id plus .)
    eq              reduce using rule 60 (Factor -> id plus .)
    diff            reduce using rule 60 (Factor -> id plus .)
    ;               reduce using rule 60 (Factor -> id plus .)
    ]               reduce using rule 60 (Factor -> id plus .)
    and             reduce using rule 60 (Factor -> id plus .)
    or              reduce using rule 60 (Factor -> id plus .)


state 60

    (61) Factor -> id plusl .

    *               reduce using rule 61 (Factor -> id plusl .)
    /               reduce using rule 61 (Factor -> id plusl .)
    %               reduce using rule 61 (Factor -> id plusl .)
    +               reduce using rule 61 (Factor -> id plusl .)
    -               reduce using rule 61 (Factor -> id plusl .)
    }               reduce using rule 61 (Factor -> id plusl .)
    id              reduce using rule 61 (Factor -> id plusl .)
    return          reduce using rule 61 (Factor -> id plusl .)
    print           reduce using rule 61 (Factor -> id plusl .)
    println         reduce using rule 61 (Factor -> id plusl .)
    prints          reduce using rule 61 (Factor -> id plusl .)
    for             reduce using rule 61 (Factor -> id plusl .)
    while           reduce using rule 61 (Factor -> id plusl .)
    read            reduce using rule 61 (Factor -> id plusl .)
    if              reduce using rule 61 (Factor -> id plusl .)
    repeat          reduce using rule 61 (Factor -> id plusl .)
    num             reduce using rule 61 (Factor -> id plusl .)
    (               reduce using rule 61 (Factor -> id plusl .)
    )               reduce using rule 61 (Factor -> id plusl .)
    sup             reduce using rule 61 (Factor -> id plusl .)
    inf             reduce using rule 61 (Factor -> id plusl .)
    supeq           reduce using rule 61 (Factor -> id plusl .)
    infeq           reduce using rule 61 (Factor -> id plusl .)
    eq              reduce using rule 61 (Factor -> id plusl .)
    diff            reduce using rule 61 (Factor -> id plusl .)
    ;               reduce using rule 61 (Factor -> id plusl .)
    ]               reduce using rule 61 (Factor -> id plusl .)
    and             reduce using rule 61 (Factor -> id plusl .)
    or              reduce using rule 61 (Factor -> id plusl .)


state 61

    (62) Factor -> id minus .

    *               reduce using rule 62 (Factor -> id minus .)
    /               reduce using rule 62 (Factor -> id minus .)
    %               reduce using rule 62 (Factor -> id minus .)
    +               reduce using rule 62 (Factor -> id minus .)
    -               reduce using rule 62 (Factor -> id minus .)
    }               reduce using rule 62 (Factor -> id minus .)
    id              reduce using rule 62 (Factor -> id minus .)
    return          reduce using rule 62 (Factor -> id minus .)
    print           reduce using rule 62 (Factor -> id minus .)
    println         reduce using rule 62 (Factor -> id minus .)
    prints          reduce using rule 62 (Factor -> id minus .)
    for             reduce using rule 62 (Factor -> id minus .)
    while           reduce using rule 62 (Factor -> id minus .)
    read            reduce using rule 62 (Factor -> id minus .)
    if              reduce using rule 62 (Factor -> id minus .)
    repeat          reduce using rule 62 (Factor -> id minus .)
    num             reduce using rule 62 (Factor -> id minus .)
    (               reduce using rule 62 (Factor -> id minus .)
    )               reduce using rule 62 (Factor -> id minus .)
    sup             reduce using rule 62 (Factor -> id minus .)
    inf             reduce using rule 62 (Factor -> id minus .)
    supeq           reduce using rule 62 (Factor -> id minus .)
    infeq           reduce using rule 62 (Factor -> id minus .)
    eq              reduce using rule 62 (Factor -> id minus .)
    diff            reduce using rule 62 (Factor -> id minus .)
    ;               reduce using rule 62 (Factor -> id minus .)
    ]               reduce using rule 62 (Factor -> id minus .)
    and             reduce using rule 62 (Factor -> id minus .)
    or              reduce using rule 62 (Factor -> id minus .)


state 62

    (63) Factor -> id minusl .

    *               reduce using rule 63 (Factor -> id minusl .)
    /               reduce using rule 63 (Factor -> id minusl .)
    %               reduce using rule 63 (Factor -> id minusl .)
    +               reduce using rule 63 (Factor -> id minusl .)
    -               reduce using rule 63 (Factor -> id minusl .)
    }               reduce using rule 63 (Factor -> id minusl .)
    id              reduce using rule 63 (Factor -> id minusl .)
    return          reduce using rule 63 (Factor -> id minusl .)
    print           reduce using rule 63 (Factor -> id minusl .)
    println         reduce using rule 63 (Factor -> id minusl .)
    prints          reduce using rule 63 (Factor -> id minusl .)
    for             reduce using rule 63 (Factor -> id minusl .)
    while           reduce using rule 63 (Factor -> id minusl .)
    read            reduce using rule 63 (Factor -> id minusl .)
    if              reduce using rule 63 (Factor -> id minusl .)
    repeat          reduce using rule 63 (Factor -> id minusl .)
    num             reduce using rule 63 (Factor -> id minusl .)
    (               reduce using rule 63 (Factor -> id minusl .)
    )               reduce using rule 63 (Factor -> id minusl .)
    sup             reduce using rule 63 (Factor -> id minusl .)
    inf             reduce using rule 63 (Factor -> id minusl .)
    supeq           reduce using rule 63 (Factor -> id minusl .)
    infeq           reduce using rule 63 (Factor -> id minusl .)
    eq              reduce using rule 63 (Factor -> id minusl .)
    diff            reduce using rule 63 (Factor -> id minusl .)
    ;               reduce using rule 63 (Factor -> id minusl .)
    ]               reduce using rule 63 (Factor -> id minusl .)
    and             reduce using rule 63 (Factor -> id minusl .)
    or              reduce using rule 63 (Factor -> id minusl .)


state 63

    (66) Factor -> id ( . )

    )               shift and go to state 100


state 64

    (37) Return -> return ( . Exp )
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 69
    num             shift and go to state 36
    (               shift and go to state 30

    Exp                            shift and go to state 101
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 65

    (76) Cond -> ( . Cond and Cond )
    (77) Cond -> ( . Cond or Cond )
    (67) Factor -> ( . Cond )
    (70) Factor -> ( . Exp )
    (74) Cond -> . Cond and Cond
    (75) Cond -> . Cond or Cond
    (76) Cond -> . ( Cond and Cond )
    (77) Cond -> . ( Cond or Cond )
    (78) Cond -> . Exp sup Exp
    (79) Cond -> . Exp inf Exp
    (80) Cond -> . Exp supeq Exp
    (81) Cond -> . Exp infeq Exp
    (82) Cond -> . not Exp
    (83) Cond -> . Exp eq Exp
    (84) Cond -> . Exp diff Exp
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    (               shift and go to state 65
    not             shift and go to state 68
    id              shift and go to state 69
    num             shift and go to state 36

    Cond                           shift and go to state 102
    Exp                            shift and go to state 67
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 66

    (67) Factor -> ( Cond . )
    (74) Cond -> Cond . and Cond
    (75) Cond -> Cond . or Cond

    )               shift and go to state 103
    and             shift and go to state 104
    or              shift and go to state 105


state 67

    (70) Factor -> ( Exp . )
    (78) Cond -> Exp . sup Exp
    (79) Cond -> Exp . inf Exp
    (80) Cond -> Exp . supeq Exp
    (81) Cond -> Exp . infeq Exp
    (83) Cond -> Exp . eq Exp
    (84) Cond -> Exp . diff Exp
    (43) Exp -> Exp . + Term
    (44) Exp -> Exp . - Term

    )               shift and go to state 106
    sup             shift and go to state 107
    inf             shift and go to state 108
    supeq           shift and go to state 109
    infeq           shift and go to state 110
    eq              shift and go to state 111
    diff            shift and go to state 112
    +               shift and go to state 45
    -               shift and go to state 46


state 68

    (82) Cond -> not . Exp
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 69
    num             shift and go to state 36
    (               shift and go to state 30

    Exp                            shift and go to state 113
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 69

    (45) Exp -> id . addeq Term
    (46) Exp -> id . subeq Term
    (47) Exp -> id . addeql Term
    (48) Exp -> id . subeql Term
    (53) Term -> id . muleq Factor
    (54) Term -> id . diveq Factor
    (55) Term -> id . modeq Factor
    (56) Term -> id . muleql Factor
    (57) Term -> id . diveql Factor
    (58) Term -> id . modeql Factor
    (60) Factor -> id . plus
    (61) Factor -> id . plusl
    (62) Factor -> id . minus
    (63) Factor -> id . minusl
    (64) Factor -> id .
    (66) Factor -> id . ( )
    (68) Factor -> id . [ Exp ]
    (69) Factor -> id . [ Exp ] [ Exp ]

  ! shift/reduce conflict for ( resolved as shift
    addeq           shift and go to state 49
    subeq           shift and go to state 50
    addeql          shift and go to state 51
    subeql          shift and go to state 52
    muleq           shift and go to state 53
    diveq           shift and go to state 54
    modeq           shift and go to state 55
    muleql          shift and go to state 56
    diveql          shift and go to state 57
    modeql          shift and go to state 58
    plus            shift and go to state 59
    plusl           shift and go to state 60
    minus           shift and go to state 61
    minusl          shift and go to state 62
    *               reduce using rule 64 (Factor -> id .)
    /               reduce using rule 64 (Factor -> id .)
    %               reduce using rule 64 (Factor -> id .)
    )               reduce using rule 64 (Factor -> id .)
    sup             reduce using rule 64 (Factor -> id .)
    inf             reduce using rule 64 (Factor -> id .)
    supeq           reduce using rule 64 (Factor -> id .)
    infeq           reduce using rule 64 (Factor -> id .)
    eq              reduce using rule 64 (Factor -> id .)
    diff            reduce using rule 64 (Factor -> id .)
    +               reduce using rule 64 (Factor -> id .)
    -               reduce using rule 64 (Factor -> id .)
    }               reduce using rule 64 (Factor -> id .)
    id              reduce using rule 64 (Factor -> id .)
    return          reduce using rule 64 (Factor -> id .)
    print           reduce using rule 64 (Factor -> id .)
    println         reduce using rule 64 (Factor -> id .)
    prints          reduce using rule 64 (Factor -> id .)
    for             reduce using rule 64 (Factor -> id .)
    while           reduce using rule 64 (Factor -> id .)
    read            reduce using rule 64 (Factor -> id .)
    if              reduce using rule 64 (Factor -> id .)
    repeat          reduce using rule 64 (Factor -> id .)
    num             reduce using rule 64 (Factor -> id .)
    ;               reduce using rule 64 (Factor -> id .)
    ]               reduce using rule 64 (Factor -> id .)
    and             reduce using rule 64 (Factor -> id .)
    or              reduce using rule 64 (Factor -> id .)
    (               shift and go to state 63
    [               shift and go to state 114

  ! (               [ reduce using rule 64 (Factor -> id .) ]


state 70

    (50) Term -> Term * . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 93
    num             shift and go to state 36
    (               shift and go to state 30

    Factor                         shift and go to state 115

state 71

    (51) Term -> Term / . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 93
    num             shift and go to state 36
    (               shift and go to state 30

    Factor                         shift and go to state 116

state 72

    (52) Term -> Term % . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 93
    num             shift and go to state 36
    (               shift and go to state 30

    Factor                         shift and go to state 117

state 73

    (27) Print -> print ( . Exp )
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 69
    num             shift and go to state 36
    (               shift and go to state 30

    Exp                            shift and go to state 118
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 74

    (28) Println -> println ( . Exp )
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 69
    num             shift and go to state 36
    (               shift and go to state 30

    Exp                            shift and go to state 119
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 75

    (29) Prints -> prints ( . string )

    string          shift and go to state 120


state 76

    (22) Repeat -> RepeatS ( . num ) { Insts }

    num             shift and go to state 121


state 77

    (24) For -> for ( . Insts ; Cond ; Insts ) { Insts }
    (9) Insts -> . Insts Inst
    (10) Insts -> .

    ;               reduce using rule 10 (Insts -> .)
    id              reduce using rule 10 (Insts -> .)
    return          reduce using rule 10 (Insts -> .)
    print           reduce using rule 10 (Insts -> .)
    println         reduce using rule 10 (Insts -> .)
    prints          reduce using rule 10 (Insts -> .)
    for             reduce using rule 10 (Insts -> .)
    while           reduce using rule 10 (Insts -> .)
    read            reduce using rule 10 (Insts -> .)
    if              reduce using rule 10 (Insts -> .)
    repeat          reduce using rule 10 (Insts -> .)
    num             reduce using rule 10 (Insts -> .)
    (               reduce using rule 10 (Insts -> .)

    Insts                          shift and go to state 122

state 78

    (25) While -> while ( . Cond ) { Insts }
    (74) Cond -> . Cond and Cond
    (75) Cond -> . Cond or Cond
    (76) Cond -> . ( Cond and Cond )
    (77) Cond -> . ( Cond or Cond )
    (78) Cond -> . Exp sup Exp
    (79) Cond -> . Exp inf Exp
    (80) Cond -> . Exp supeq Exp
    (81) Cond -> . Exp infeq Exp
    (82) Cond -> . not Exp
    (83) Cond -> . Exp eq Exp
    (84) Cond -> . Exp diff Exp
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    (               shift and go to state 65
    not             shift and go to state 68
    id              shift and go to state 69
    num             shift and go to state 36

    Cond                           shift and go to state 123
    Exp                            shift and go to state 124
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 79

    (26) Read -> read ( . id )

    id              shift and go to state 125


state 80

    (38) If -> if ( . Cond ) { Insts }
    (39) If -> if ( . Cond ) Inst
    (41) If -> if ( . Cond ) { Insts } else { Insts }
    (74) Cond -> . Cond and Cond
    (75) Cond -> . Cond or Cond
    (76) Cond -> . ( Cond and Cond )
    (77) Cond -> . ( Cond or Cond )
    (78) Cond -> . Exp sup Exp
    (79) Cond -> . Exp inf Exp
    (80) Cond -> . Exp supeq Exp
    (81) Cond -> . Exp infeq Exp
    (82) Cond -> . not Exp
    (83) Cond -> . Exp eq Exp
    (84) Cond -> . Exp diff Exp
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    (               shift and go to state 65
    not             shift and go to state 68
    id              shift and go to state 69
    num             shift and go to state 36

    Cond                           shift and go to state 126
    Exp                            shift and go to state 124
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 81

    (30) Dcl -> int id [ . num ]
    (31) Dcl -> int id [ . num ] [ num ]

    num             shift and go to state 127


state 82

    (33) Dcl -> int id = . num

    num             shift and go to state 128


state 83

    (4) DefBlc -> id { VarBlc Insts } .

    id              reduce using rule 4 (DefBlc -> id { VarBlc Insts } .)
    $end            reduce using rule 4 (DefBlc -> id { VarBlc Insts } .)


state 84

    (43) Exp -> Exp + Term .
    (50) Term -> Term . * Factor
    (51) Term -> Term . / Factor
    (52) Term -> Term . % Factor

    +               reduce using rule 43 (Exp -> Exp + Term .)
    -               reduce using rule 43 (Exp -> Exp + Term .)
    }               reduce using rule 43 (Exp -> Exp + Term .)
    id              reduce using rule 43 (Exp -> Exp + Term .)
    return          reduce using rule 43 (Exp -> Exp + Term .)
    print           reduce using rule 43 (Exp -> Exp + Term .)
    println         reduce using rule 43 (Exp -> Exp + Term .)
    prints          reduce using rule 43 (Exp -> Exp + Term .)
    for             reduce using rule 43 (Exp -> Exp + Term .)
    while           reduce using rule 43 (Exp -> Exp + Term .)
    read            reduce using rule 43 (Exp -> Exp + Term .)
    if              reduce using rule 43 (Exp -> Exp + Term .)
    repeat          reduce using rule 43 (Exp -> Exp + Term .)
    num             reduce using rule 43 (Exp -> Exp + Term .)
    (               reduce using rule 43 (Exp -> Exp + Term .)
    )               reduce using rule 43 (Exp -> Exp + Term .)
    sup             reduce using rule 43 (Exp -> Exp + Term .)
    inf             reduce using rule 43 (Exp -> Exp + Term .)
    supeq           reduce using rule 43 (Exp -> Exp + Term .)
    infeq           reduce using rule 43 (Exp -> Exp + Term .)
    eq              reduce using rule 43 (Exp -> Exp + Term .)
    diff            reduce using rule 43 (Exp -> Exp + Term .)
    ;               reduce using rule 43 (Exp -> Exp + Term .)
    ]               reduce using rule 43 (Exp -> Exp + Term .)
    and             reduce using rule 43 (Exp -> Exp + Term .)
    or              reduce using rule 43 (Exp -> Exp + Term .)
    *               shift and go to state 70
    /               shift and go to state 71
    %               shift and go to state 72


state 85

    (53) Term -> id . muleq Factor
    (54) Term -> id . diveq Factor
    (55) Term -> id . modeq Factor
    (56) Term -> id . muleql Factor
    (57) Term -> id . diveql Factor
    (58) Term -> id . modeql Factor
    (60) Factor -> id . plus
    (61) Factor -> id . plusl
    (62) Factor -> id . minus
    (63) Factor -> id . minusl
    (64) Factor -> id .
    (66) Factor -> id . ( )
    (68) Factor -> id . [ Exp ]
    (69) Factor -> id . [ Exp ] [ Exp ]

  ! shift/reduce conflict for ( resolved as shift
    muleq           shift and go to state 53
    diveq           shift and go to state 54
    modeq           shift and go to state 55
    muleql          shift and go to state 56
    diveql          shift and go to state 57
    modeql          shift and go to state 58
    plus            shift and go to state 59
    plusl           shift and go to state 60
    minus           shift and go to state 61
    minusl          shift and go to state 62
    *               reduce using rule 64 (Factor -> id .)
    /               reduce using rule 64 (Factor -> id .)
    %               reduce using rule 64 (Factor -> id .)
    +               reduce using rule 64 (Factor -> id .)
    -               reduce using rule 64 (Factor -> id .)
    }               reduce using rule 64 (Factor -> id .)
    id              reduce using rule 64 (Factor -> id .)
    return          reduce using rule 64 (Factor -> id .)
    print           reduce using rule 64 (Factor -> id .)
    println         reduce using rule 64 (Factor -> id .)
    prints          reduce using rule 64 (Factor -> id .)
    for             reduce using rule 64 (Factor -> id .)
    while           reduce using rule 64 (Factor -> id .)
    read            reduce using rule 64 (Factor -> id .)
    if              reduce using rule 64 (Factor -> id .)
    repeat          reduce using rule 64 (Factor -> id .)
    num             reduce using rule 64 (Factor -> id .)
    )               reduce using rule 64 (Factor -> id .)
    sup             reduce using rule 64 (Factor -> id .)
    inf             reduce using rule 64 (Factor -> id .)
    supeq           reduce using rule 64 (Factor -> id .)
    infeq           reduce using rule 64 (Factor -> id .)
    eq              reduce using rule 64 (Factor -> id .)
    diff            reduce using rule 64 (Factor -> id .)
    ;               reduce using rule 64 (Factor -> id .)
    ]               reduce using rule 64 (Factor -> id .)
    and             reduce using rule 64 (Factor -> id .)
    or              reduce using rule 64 (Factor -> id .)
    (               shift and go to state 63
    [               shift and go to state 114

  ! (               [ reduce using rule 64 (Factor -> id .) ]


state 86

    (44) Exp -> Exp - Term .
    (50) Term -> Term . * Factor
    (51) Term -> Term . / Factor
    (52) Term -> Term . % Factor

    +               reduce using rule 44 (Exp -> Exp - Term .)
    -               reduce using rule 44 (Exp -> Exp - Term .)
    }               reduce using rule 44 (Exp -> Exp - Term .)
    id              reduce using rule 44 (Exp -> Exp - Term .)
    return          reduce using rule 44 (Exp -> Exp - Term .)
    print           reduce using rule 44 (Exp -> Exp - Term .)
    println         reduce using rule 44 (Exp -> Exp - Term .)
    prints          reduce using rule 44 (Exp -> Exp - Term .)
    for             reduce using rule 44 (Exp -> Exp - Term .)
    while           reduce using rule 44 (Exp -> Exp - Term .)
    read            reduce using rule 44 (Exp -> Exp - Term .)
    if              reduce using rule 44 (Exp -> Exp - Term .)
    repeat          reduce using rule 44 (Exp -> Exp - Term .)
    num             reduce using rule 44 (Exp -> Exp - Term .)
    (               reduce using rule 44 (Exp -> Exp - Term .)
    )               reduce using rule 44 (Exp -> Exp - Term .)
    sup             reduce using rule 44 (Exp -> Exp - Term .)
    inf             reduce using rule 44 (Exp -> Exp - Term .)
    supeq           reduce using rule 44 (Exp -> Exp - Term .)
    infeq           reduce using rule 44 (Exp -> Exp - Term .)
    eq              reduce using rule 44 (Exp -> Exp - Term .)
    diff            reduce using rule 44 (Exp -> Exp - Term .)
    ;               reduce using rule 44 (Exp -> Exp - Term .)
    ]               reduce using rule 44 (Exp -> Exp - Term .)
    and             reduce using rule 44 (Exp -> Exp - Term .)
    or              reduce using rule 44 (Exp -> Exp - Term .)
    *               shift and go to state 70
    /               shift and go to state 71
    %               shift and go to state 72


state 87

    (34) Attr -> id = Exp .
    (43) Exp -> Exp . + Term
    (44) Exp -> Exp . - Term

    }               reduce using rule 34 (Attr -> id = Exp .)
    id              reduce using rule 34 (Attr -> id = Exp .)
    return          reduce using rule 34 (Attr -> id = Exp .)
    print           reduce using rule 34 (Attr -> id = Exp .)
    println         reduce using rule 34 (Attr -> id = Exp .)
    prints          reduce using rule 34 (Attr -> id = Exp .)
    for             reduce using rule 34 (Attr -> id = Exp .)
    while           reduce using rule 34 (Attr -> id = Exp .)
    read            reduce using rule 34 (Attr -> id = Exp .)
    if              reduce using rule 34 (Attr -> id = Exp .)
    repeat          reduce using rule 34 (Attr -> id = Exp .)
    num             reduce using rule 34 (Attr -> id = Exp .)
    (               reduce using rule 34 (Attr -> id = Exp .)
    ;               reduce using rule 34 (Attr -> id = Exp .)
    )               reduce using rule 34 (Attr -> id = Exp .)
    +               shift and go to state 45
    -               shift and go to state 46


state 88

    (35) Attr -> id [ Exp . ] = Exp
    (36) Attr -> id [ Exp . ] [ Exp ] = Exp
    (68) Factor -> id [ Exp . ]
    (69) Factor -> id [ Exp . ] [ Exp ]
    (43) Exp -> Exp . + Term
    (44) Exp -> Exp . - Term

    ]               shift and go to state 129
    +               shift and go to state 45
    -               shift and go to state 46


state 89

    (45) Exp -> id addeq Term .
    (50) Term -> Term . * Factor
    (51) Term -> Term . / Factor
    (52) Term -> Term . % Factor

    +               reduce using rule 45 (Exp -> id addeq Term .)
    -               reduce using rule 45 (Exp -> id addeq Term .)
    }               reduce using rule 45 (Exp -> id addeq Term .)
    id              reduce using rule 45 (Exp -> id addeq Term .)
    return          reduce using rule 45 (Exp -> id addeq Term .)
    print           reduce using rule 45 (Exp -> id addeq Term .)
    println         reduce using rule 45 (Exp -> id addeq Term .)
    prints          reduce using rule 45 (Exp -> id addeq Term .)
    for             reduce using rule 45 (Exp -> id addeq Term .)
    while           reduce using rule 45 (Exp -> id addeq Term .)
    read            reduce using rule 45 (Exp -> id addeq Term .)
    if              reduce using rule 45 (Exp -> id addeq Term .)
    repeat          reduce using rule 45 (Exp -> id addeq Term .)
    num             reduce using rule 45 (Exp -> id addeq Term .)
    (               reduce using rule 45 (Exp -> id addeq Term .)
    )               reduce using rule 45 (Exp -> id addeq Term .)
    sup             reduce using rule 45 (Exp -> id addeq Term .)
    inf             reduce using rule 45 (Exp -> id addeq Term .)
    supeq           reduce using rule 45 (Exp -> id addeq Term .)
    infeq           reduce using rule 45 (Exp -> id addeq Term .)
    eq              reduce using rule 45 (Exp -> id addeq Term .)
    diff            reduce using rule 45 (Exp -> id addeq Term .)
    ;               reduce using rule 45 (Exp -> id addeq Term .)
    ]               reduce using rule 45 (Exp -> id addeq Term .)
    and             reduce using rule 45 (Exp -> id addeq Term .)
    or              reduce using rule 45 (Exp -> id addeq Term .)
    *               shift and go to state 70
    /               shift and go to state 71
    %               shift and go to state 72


state 90

    (46) Exp -> id subeq Term .
    (50) Term -> Term . * Factor
    (51) Term -> Term . / Factor
    (52) Term -> Term . % Factor

    +               reduce using rule 46 (Exp -> id subeq Term .)
    -               reduce using rule 46 (Exp -> id subeq Term .)
    }               reduce using rule 46 (Exp -> id subeq Term .)
    id              reduce using rule 46 (Exp -> id subeq Term .)
    return          reduce using rule 46 (Exp -> id subeq Term .)
    print           reduce using rule 46 (Exp -> id subeq Term .)
    println         reduce using rule 46 (Exp -> id subeq Term .)
    prints          reduce using rule 46 (Exp -> id subeq Term .)
    for             reduce using rule 46 (Exp -> id subeq Term .)
    while           reduce using rule 46 (Exp -> id subeq Term .)
    read            reduce using rule 46 (Exp -> id subeq Term .)
    if              reduce using rule 46 (Exp -> id subeq Term .)
    repeat          reduce using rule 46 (Exp -> id subeq Term .)
    num             reduce using rule 46 (Exp -> id subeq Term .)
    (               reduce using rule 46 (Exp -> id subeq Term .)
    )               reduce using rule 46 (Exp -> id subeq Term .)
    sup             reduce using rule 46 (Exp -> id subeq Term .)
    inf             reduce using rule 46 (Exp -> id subeq Term .)
    supeq           reduce using rule 46 (Exp -> id subeq Term .)
    infeq           reduce using rule 46 (Exp -> id subeq Term .)
    eq              reduce using rule 46 (Exp -> id subeq Term .)
    diff            reduce using rule 46 (Exp -> id subeq Term .)
    ;               reduce using rule 46 (Exp -> id subeq Term .)
    ]               reduce using rule 46 (Exp -> id subeq Term .)
    and             reduce using rule 46 (Exp -> id subeq Term .)
    or              reduce using rule 46 (Exp -> id subeq Term .)
    *               shift and go to state 70
    /               shift and go to state 71
    %               shift and go to state 72


state 91

    (47) Exp -> id addeql Term .
    (50) Term -> Term . * Factor
    (51) Term -> Term . / Factor
    (52) Term -> Term . % Factor

    +               reduce using rule 47 (Exp -> id addeql Term .)
    -               reduce using rule 47 (Exp -> id addeql Term .)
    }               reduce using rule 47 (Exp -> id addeql Term .)
    id              reduce using rule 47 (Exp -> id addeql Term .)
    return          reduce using rule 47 (Exp -> id addeql Term .)
    print           reduce using rule 47 (Exp -> id addeql Term .)
    println         reduce using rule 47 (Exp -> id addeql Term .)
    prints          reduce using rule 47 (Exp -> id addeql Term .)
    for             reduce using rule 47 (Exp -> id addeql Term .)
    while           reduce using rule 47 (Exp -> id addeql Term .)
    read            reduce using rule 47 (Exp -> id addeql Term .)
    if              reduce using rule 47 (Exp -> id addeql Term .)
    repeat          reduce using rule 47 (Exp -> id addeql Term .)
    num             reduce using rule 47 (Exp -> id addeql Term .)
    (               reduce using rule 47 (Exp -> id addeql Term .)
    )               reduce using rule 47 (Exp -> id addeql Term .)
    sup             reduce using rule 47 (Exp -> id addeql Term .)
    inf             reduce using rule 47 (Exp -> id addeql Term .)
    supeq           reduce using rule 47 (Exp -> id addeql Term .)
    infeq           reduce using rule 47 (Exp -> id addeql Term .)
    eq              reduce using rule 47 (Exp -> id addeql Term .)
    diff            reduce using rule 47 (Exp -> id addeql Term .)
    ;               reduce using rule 47 (Exp -> id addeql Term .)
    ]               reduce using rule 47 (Exp -> id addeql Term .)
    and             reduce using rule 47 (Exp -> id addeql Term .)
    or              reduce using rule 47 (Exp -> id addeql Term .)
    *               shift and go to state 70
    /               shift and go to state 71
    %               shift and go to state 72


state 92

    (48) Exp -> id subeql Term .
    (50) Term -> Term . * Factor
    (51) Term -> Term . / Factor
    (52) Term -> Term . % Factor

    +               reduce using rule 48 (Exp -> id subeql Term .)
    -               reduce using rule 48 (Exp -> id subeql Term .)
    }               reduce using rule 48 (Exp -> id subeql Term .)
    id              reduce using rule 48 (Exp -> id subeql Term .)
    return          reduce using rule 48 (Exp -> id subeql Term .)
    print           reduce using rule 48 (Exp -> id subeql Term .)
    println         reduce using rule 48 (Exp -> id subeql Term .)
    prints          reduce using rule 48 (Exp -> id subeql Term .)
    for             reduce using rule 48 (Exp -> id subeql Term .)
    while           reduce using rule 48 (Exp -> id subeql Term .)
    read            reduce using rule 48 (Exp -> id subeql Term .)
    if              reduce using rule 48 (Exp -> id subeql Term .)
    repeat          reduce using rule 48 (Exp -> id subeql Term .)
    num             reduce using rule 48 (Exp -> id subeql Term .)
    (               reduce using rule 48 (Exp -> id subeql Term .)
    )               reduce using rule 48 (Exp -> id subeql Term .)
    sup             reduce using rule 48 (Exp -> id subeql Term .)
    inf             reduce using rule 48 (Exp -> id subeql Term .)
    supeq           reduce using rule 48 (Exp -> id subeql Term .)
    infeq           reduce using rule 48 (Exp -> id subeql Term .)
    eq              reduce using rule 48 (Exp -> id subeql Term .)
    diff            reduce using rule 48 (Exp -> id subeql Term .)
    ;               reduce using rule 48 (Exp -> id subeql Term .)
    ]               reduce using rule 48 (Exp -> id subeql Term .)
    and             reduce using rule 48 (Exp -> id subeql Term .)
    or              reduce using rule 48 (Exp -> id subeql Term .)
    *               shift and go to state 70
    /               shift and go to state 71
    %               shift and go to state 72


state 93

    (60) Factor -> id . plus
    (61) Factor -> id . plusl
    (62) Factor -> id . minus
    (63) Factor -> id . minusl
    (64) Factor -> id .
    (66) Factor -> id . ( )
    (68) Factor -> id . [ Exp ]
    (69) Factor -> id . [ Exp ] [ Exp ]

  ! shift/reduce conflict for ( resolved as shift
    plus            shift and go to state 59
    plusl           shift and go to state 60
    minus           shift and go to state 61
    minusl          shift and go to state 62
    *               reduce using rule 64 (Factor -> id .)
    /               reduce using rule 64 (Factor -> id .)
    %               reduce using rule 64 (Factor -> id .)
    +               reduce using rule 64 (Factor -> id .)
    -               reduce using rule 64 (Factor -> id .)
    }               reduce using rule 64 (Factor -> id .)
    id              reduce using rule 64 (Factor -> id .)
    return          reduce using rule 64 (Factor -> id .)
    print           reduce using rule 64 (Factor -> id .)
    println         reduce using rule 64 (Factor -> id .)
    prints          reduce using rule 64 (Factor -> id .)
    for             reduce using rule 64 (Factor -> id .)
    while           reduce using rule 64 (Factor -> id .)
    read            reduce using rule 64 (Factor -> id .)
    if              reduce using rule 64 (Factor -> id .)
    repeat          reduce using rule 64 (Factor -> id .)
    num             reduce using rule 64 (Factor -> id .)
    )               reduce using rule 64 (Factor -> id .)
    sup             reduce using rule 64 (Factor -> id .)
    inf             reduce using rule 64 (Factor -> id .)
    supeq           reduce using rule 64 (Factor -> id .)
    infeq           reduce using rule 64 (Factor -> id .)
    eq              reduce using rule 64 (Factor -> id .)
    diff            reduce using rule 64 (Factor -> id .)
    ;               reduce using rule 64 (Factor -> id .)
    ]               reduce using rule 64 (Factor -> id .)
    and             reduce using rule 64 (Factor -> id .)
    or              reduce using rule 64 (Factor -> id .)
    (               shift and go to state 63
    [               shift and go to state 114

  ! (               [ reduce using rule 64 (Factor -> id .) ]


state 94

    (53) Term -> id muleq Factor .

    *               reduce using rule 53 (Term -> id muleq Factor .)
    /               reduce using rule 53 (Term -> id muleq Factor .)
    %               reduce using rule 53 (Term -> id muleq Factor .)
    +               reduce using rule 53 (Term -> id muleq Factor .)
    -               reduce using rule 53 (Term -> id muleq Factor .)
    }               reduce using rule 53 (Term -> id muleq Factor .)
    id              reduce using rule 53 (Term -> id muleq Factor .)
    return          reduce using rule 53 (Term -> id muleq Factor .)
    print           reduce using rule 53 (Term -> id muleq Factor .)
    println         reduce using rule 53 (Term -> id muleq Factor .)
    prints          reduce using rule 53 (Term -> id muleq Factor .)
    for             reduce using rule 53 (Term -> id muleq Factor .)
    while           reduce using rule 53 (Term -> id muleq Factor .)
    read            reduce using rule 53 (Term -> id muleq Factor .)
    if              reduce using rule 53 (Term -> id muleq Factor .)
    repeat          reduce using rule 53 (Term -> id muleq Factor .)
    num             reduce using rule 53 (Term -> id muleq Factor .)
    (               reduce using rule 53 (Term -> id muleq Factor .)
    )               reduce using rule 53 (Term -> id muleq Factor .)
    sup             reduce using rule 53 (Term -> id muleq Factor .)
    inf             reduce using rule 53 (Term -> id muleq Factor .)
    supeq           reduce using rule 53 (Term -> id muleq Factor .)
    infeq           reduce using rule 53 (Term -> id muleq Factor .)
    eq              reduce using rule 53 (Term -> id muleq Factor .)
    diff            reduce using rule 53 (Term -> id muleq Factor .)
    ;               reduce using rule 53 (Term -> id muleq Factor .)
    ]               reduce using rule 53 (Term -> id muleq Factor .)
    and             reduce using rule 53 (Term -> id muleq Factor .)
    or              reduce using rule 53 (Term -> id muleq Factor .)


state 95

    (54) Term -> id diveq Factor .

    *               reduce using rule 54 (Term -> id diveq Factor .)
    /               reduce using rule 54 (Term -> id diveq Factor .)
    %               reduce using rule 54 (Term -> id diveq Factor .)
    +               reduce using rule 54 (Term -> id diveq Factor .)
    -               reduce using rule 54 (Term -> id diveq Factor .)
    }               reduce using rule 54 (Term -> id diveq Factor .)
    id              reduce using rule 54 (Term -> id diveq Factor .)
    return          reduce using rule 54 (Term -> id diveq Factor .)
    print           reduce using rule 54 (Term -> id diveq Factor .)
    println         reduce using rule 54 (Term -> id diveq Factor .)
    prints          reduce using rule 54 (Term -> id diveq Factor .)
    for             reduce using rule 54 (Term -> id diveq Factor .)
    while           reduce using rule 54 (Term -> id diveq Factor .)
    read            reduce using rule 54 (Term -> id diveq Factor .)
    if              reduce using rule 54 (Term -> id diveq Factor .)
    repeat          reduce using rule 54 (Term -> id diveq Factor .)
    num             reduce using rule 54 (Term -> id diveq Factor .)
    (               reduce using rule 54 (Term -> id diveq Factor .)
    )               reduce using rule 54 (Term -> id diveq Factor .)
    sup             reduce using rule 54 (Term -> id diveq Factor .)
    inf             reduce using rule 54 (Term -> id diveq Factor .)
    supeq           reduce using rule 54 (Term -> id diveq Factor .)
    infeq           reduce using rule 54 (Term -> id diveq Factor .)
    eq              reduce using rule 54 (Term -> id diveq Factor .)
    diff            reduce using rule 54 (Term -> id diveq Factor .)
    ;               reduce using rule 54 (Term -> id diveq Factor .)
    ]               reduce using rule 54 (Term -> id diveq Factor .)
    and             reduce using rule 54 (Term -> id diveq Factor .)
    or              reduce using rule 54 (Term -> id diveq Factor .)


state 96

    (55) Term -> id modeq Factor .

    *               reduce using rule 55 (Term -> id modeq Factor .)
    /               reduce using rule 55 (Term -> id modeq Factor .)
    %               reduce using rule 55 (Term -> id modeq Factor .)
    +               reduce using rule 55 (Term -> id modeq Factor .)
    -               reduce using rule 55 (Term -> id modeq Factor .)
    }               reduce using rule 55 (Term -> id modeq Factor .)
    id              reduce using rule 55 (Term -> id modeq Factor .)
    return          reduce using rule 55 (Term -> id modeq Factor .)
    print           reduce using rule 55 (Term -> id modeq Factor .)
    println         reduce using rule 55 (Term -> id modeq Factor .)
    prints          reduce using rule 55 (Term -> id modeq Factor .)
    for             reduce using rule 55 (Term -> id modeq Factor .)
    while           reduce using rule 55 (Term -> id modeq Factor .)
    read            reduce using rule 55 (Term -> id modeq Factor .)
    if              reduce using rule 55 (Term -> id modeq Factor .)
    repeat          reduce using rule 55 (Term -> id modeq Factor .)
    num             reduce using rule 55 (Term -> id modeq Factor .)
    (               reduce using rule 55 (Term -> id modeq Factor .)
    )               reduce using rule 55 (Term -> id modeq Factor .)
    sup             reduce using rule 55 (Term -> id modeq Factor .)
    inf             reduce using rule 55 (Term -> id modeq Factor .)
    supeq           reduce using rule 55 (Term -> id modeq Factor .)
    infeq           reduce using rule 55 (Term -> id modeq Factor .)
    eq              reduce using rule 55 (Term -> id modeq Factor .)
    diff            reduce using rule 55 (Term -> id modeq Factor .)
    ;               reduce using rule 55 (Term -> id modeq Factor .)
    ]               reduce using rule 55 (Term -> id modeq Factor .)
    and             reduce using rule 55 (Term -> id modeq Factor .)
    or              reduce using rule 55 (Term -> id modeq Factor .)


state 97

    (56) Term -> id muleql Factor .

    *               reduce using rule 56 (Term -> id muleql Factor .)
    /               reduce using rule 56 (Term -> id muleql Factor .)
    %               reduce using rule 56 (Term -> id muleql Factor .)
    +               reduce using rule 56 (Term -> id muleql Factor .)
    -               reduce using rule 56 (Term -> id muleql Factor .)
    }               reduce using rule 56 (Term -> id muleql Factor .)
    id              reduce using rule 56 (Term -> id muleql Factor .)
    return          reduce using rule 56 (Term -> id muleql Factor .)
    print           reduce using rule 56 (Term -> id muleql Factor .)
    println         reduce using rule 56 (Term -> id muleql Factor .)
    prints          reduce using rule 56 (Term -> id muleql Factor .)
    for             reduce using rule 56 (Term -> id muleql Factor .)
    while           reduce using rule 56 (Term -> id muleql Factor .)
    read            reduce using rule 56 (Term -> id muleql Factor .)
    if              reduce using rule 56 (Term -> id muleql Factor .)
    repeat          reduce using rule 56 (Term -> id muleql Factor .)
    num             reduce using rule 56 (Term -> id muleql Factor .)
    (               reduce using rule 56 (Term -> id muleql Factor .)
    )               reduce using rule 56 (Term -> id muleql Factor .)
    sup             reduce using rule 56 (Term -> id muleql Factor .)
    inf             reduce using rule 56 (Term -> id muleql Factor .)
    supeq           reduce using rule 56 (Term -> id muleql Factor .)
    infeq           reduce using rule 56 (Term -> id muleql Factor .)
    eq              reduce using rule 56 (Term -> id muleql Factor .)
    diff            reduce using rule 56 (Term -> id muleql Factor .)
    ;               reduce using rule 56 (Term -> id muleql Factor .)
    ]               reduce using rule 56 (Term -> id muleql Factor .)
    and             reduce using rule 56 (Term -> id muleql Factor .)
    or              reduce using rule 56 (Term -> id muleql Factor .)


state 98

    (57) Term -> id diveql Factor .

    *               reduce using rule 57 (Term -> id diveql Factor .)
    /               reduce using rule 57 (Term -> id diveql Factor .)
    %               reduce using rule 57 (Term -> id diveql Factor .)
    +               reduce using rule 57 (Term -> id diveql Factor .)
    -               reduce using rule 57 (Term -> id diveql Factor .)
    }               reduce using rule 57 (Term -> id diveql Factor .)
    id              reduce using rule 57 (Term -> id diveql Factor .)
    return          reduce using rule 57 (Term -> id diveql Factor .)
    print           reduce using rule 57 (Term -> id diveql Factor .)
    println         reduce using rule 57 (Term -> id diveql Factor .)
    prints          reduce using rule 57 (Term -> id diveql Factor .)
    for             reduce using rule 57 (Term -> id diveql Factor .)
    while           reduce using rule 57 (Term -> id diveql Factor .)
    read            reduce using rule 57 (Term -> id diveql Factor .)
    if              reduce using rule 57 (Term -> id diveql Factor .)
    repeat          reduce using rule 57 (Term -> id diveql Factor .)
    num             reduce using rule 57 (Term -> id diveql Factor .)
    (               reduce using rule 57 (Term -> id diveql Factor .)
    )               reduce using rule 57 (Term -> id diveql Factor .)
    sup             reduce using rule 57 (Term -> id diveql Factor .)
    inf             reduce using rule 57 (Term -> id diveql Factor .)
    supeq           reduce using rule 57 (Term -> id diveql Factor .)
    infeq           reduce using rule 57 (Term -> id diveql Factor .)
    eq              reduce using rule 57 (Term -> id diveql Factor .)
    diff            reduce using rule 57 (Term -> id diveql Factor .)
    ;               reduce using rule 57 (Term -> id diveql Factor .)
    ]               reduce using rule 57 (Term -> id diveql Factor .)
    and             reduce using rule 57 (Term -> id diveql Factor .)
    or              reduce using rule 57 (Term -> id diveql Factor .)


state 99

    (58) Term -> id modeql Factor .

    *               reduce using rule 58 (Term -> id modeql Factor .)
    /               reduce using rule 58 (Term -> id modeql Factor .)
    %               reduce using rule 58 (Term -> id modeql Factor .)
    +               reduce using rule 58 (Term -> id modeql Factor .)
    -               reduce using rule 58 (Term -> id modeql Factor .)
    }               reduce using rule 58 (Term -> id modeql Factor .)
    id              reduce using rule 58 (Term -> id modeql Factor .)
    return          reduce using rule 58 (Term -> id modeql Factor .)
    print           reduce using rule 58 (Term -> id modeql Factor .)
    println         reduce using rule 58 (Term -> id modeql Factor .)
    prints          reduce using rule 58 (Term -> id modeql Factor .)
    for             reduce using rule 58 (Term -> id modeql Factor .)
    while           reduce using rule 58 (Term -> id modeql Factor .)
    read            reduce using rule 58 (Term -> id modeql Factor .)
    if              reduce using rule 58 (Term -> id modeql Factor .)
    repeat          reduce using rule 58 (Term -> id modeql Factor .)
    num             reduce using rule 58 (Term -> id modeql Factor .)
    (               reduce using rule 58 (Term -> id modeql Factor .)
    )               reduce using rule 58 (Term -> id modeql Factor .)
    sup             reduce using rule 58 (Term -> id modeql Factor .)
    inf             reduce using rule 58 (Term -> id modeql Factor .)
    supeq           reduce using rule 58 (Term -> id modeql Factor .)
    infeq           reduce using rule 58 (Term -> id modeql Factor .)
    eq              reduce using rule 58 (Term -> id modeql Factor .)
    diff            reduce using rule 58 (Term -> id modeql Factor .)
    ;               reduce using rule 58 (Term -> id modeql Factor .)
    ]               reduce using rule 58 (Term -> id modeql Factor .)
    and             reduce using rule 58 (Term -> id modeql Factor .)
    or              reduce using rule 58 (Term -> id modeql Factor .)


state 100

    (66) Factor -> id ( ) .

    *               reduce using rule 66 (Factor -> id ( ) .)
    /               reduce using rule 66 (Factor -> id ( ) .)
    %               reduce using rule 66 (Factor -> id ( ) .)
    +               reduce using rule 66 (Factor -> id ( ) .)
    -               reduce using rule 66 (Factor -> id ( ) .)
    }               reduce using rule 66 (Factor -> id ( ) .)
    id              reduce using rule 66 (Factor -> id ( ) .)
    return          reduce using rule 66 (Factor -> id ( ) .)
    print           reduce using rule 66 (Factor -> id ( ) .)
    println         reduce using rule 66 (Factor -> id ( ) .)
    prints          reduce using rule 66 (Factor -> id ( ) .)
    for             reduce using rule 66 (Factor -> id ( ) .)
    while           reduce using rule 66 (Factor -> id ( ) .)
    read            reduce using rule 66 (Factor -> id ( ) .)
    if              reduce using rule 66 (Factor -> id ( ) .)
    repeat          reduce using rule 66 (Factor -> id ( ) .)
    num             reduce using rule 66 (Factor -> id ( ) .)
    (               reduce using rule 66 (Factor -> id ( ) .)
    )               reduce using rule 66 (Factor -> id ( ) .)
    sup             reduce using rule 66 (Factor -> id ( ) .)
    inf             reduce using rule 66 (Factor -> id ( ) .)
    supeq           reduce using rule 66 (Factor -> id ( ) .)
    infeq           reduce using rule 66 (Factor -> id ( ) .)
    eq              reduce using rule 66 (Factor -> id ( ) .)
    diff            reduce using rule 66 (Factor -> id ( ) .)
    ;               reduce using rule 66 (Factor -> id ( ) .)
    ]               reduce using rule 66 (Factor -> id ( ) .)
    and             reduce using rule 66 (Factor -> id ( ) .)
    or              reduce using rule 66 (Factor -> id ( ) .)


state 101

    (37) Return -> return ( Exp . )
    (43) Exp -> Exp . + Term
    (44) Exp -> Exp . - Term

    )               shift and go to state 130
    +               shift and go to state 45
    -               shift and go to state 46


state 102

    (76) Cond -> ( Cond . and Cond )
    (77) Cond -> ( Cond . or Cond )
    (67) Factor -> ( Cond . )
    (74) Cond -> Cond . and Cond
    (75) Cond -> Cond . or Cond

    and             shift and go to state 131
    or              shift and go to state 132
    )               shift and go to state 103


state 103

    (67) Factor -> ( Cond ) .

    *               reduce using rule 67 (Factor -> ( Cond ) .)
    /               reduce using rule 67 (Factor -> ( Cond ) .)
    %               reduce using rule 67 (Factor -> ( Cond ) .)
    +               reduce using rule 67 (Factor -> ( Cond ) .)
    -               reduce using rule 67 (Factor -> ( Cond ) .)
    }               reduce using rule 67 (Factor -> ( Cond ) .)
    id              reduce using rule 67 (Factor -> ( Cond ) .)
    return          reduce using rule 67 (Factor -> ( Cond ) .)
    print           reduce using rule 67 (Factor -> ( Cond ) .)
    println         reduce using rule 67 (Factor -> ( Cond ) .)
    prints          reduce using rule 67 (Factor -> ( Cond ) .)
    for             reduce using rule 67 (Factor -> ( Cond ) .)
    while           reduce using rule 67 (Factor -> ( Cond ) .)
    read            reduce using rule 67 (Factor -> ( Cond ) .)
    if              reduce using rule 67 (Factor -> ( Cond ) .)
    repeat          reduce using rule 67 (Factor -> ( Cond ) .)
    num             reduce using rule 67 (Factor -> ( Cond ) .)
    (               reduce using rule 67 (Factor -> ( Cond ) .)
    )               reduce using rule 67 (Factor -> ( Cond ) .)
    sup             reduce using rule 67 (Factor -> ( Cond ) .)
    inf             reduce using rule 67 (Factor -> ( Cond ) .)
    supeq           reduce using rule 67 (Factor -> ( Cond ) .)
    infeq           reduce using rule 67 (Factor -> ( Cond ) .)
    eq              reduce using rule 67 (Factor -> ( Cond ) .)
    diff            reduce using rule 67 (Factor -> ( Cond ) .)
    ;               reduce using rule 67 (Factor -> ( Cond ) .)
    ]               reduce using rule 67 (Factor -> ( Cond ) .)
    and             reduce using rule 67 (Factor -> ( Cond ) .)
    or              reduce using rule 67 (Factor -> ( Cond ) .)


state 104

    (74) Cond -> Cond and . Cond
    (74) Cond -> . Cond and Cond
    (75) Cond -> . Cond or Cond
    (76) Cond -> . ( Cond and Cond )
    (77) Cond -> . ( Cond or Cond )
    (78) Cond -> . Exp sup Exp
    (79) Cond -> . Exp inf Exp
    (80) Cond -> . Exp supeq Exp
    (81) Cond -> . Exp infeq Exp
    (82) Cond -> . not Exp
    (83) Cond -> . Exp eq Exp
    (84) Cond -> . Exp diff Exp
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    (               shift and go to state 65
    not             shift and go to state 68
    id              shift and go to state 69
    num             shift and go to state 36

    Cond                           shift and go to state 133
    Exp                            shift and go to state 124
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 105

    (75) Cond -> Cond or . Cond
    (74) Cond -> . Cond and Cond
    (75) Cond -> . Cond or Cond
    (76) Cond -> . ( Cond and Cond )
    (77) Cond -> . ( Cond or Cond )
    (78) Cond -> . Exp sup Exp
    (79) Cond -> . Exp inf Exp
    (80) Cond -> . Exp supeq Exp
    (81) Cond -> . Exp infeq Exp
    (82) Cond -> . not Exp
    (83) Cond -> . Exp eq Exp
    (84) Cond -> . Exp diff Exp
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    (               shift and go to state 65
    not             shift and go to state 68
    id              shift and go to state 69
    num             shift and go to state 36

    Cond                           shift and go to state 134
    Exp                            shift and go to state 124
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 106

    (70) Factor -> ( Exp ) .

    *               reduce using rule 70 (Factor -> ( Exp ) .)
    /               reduce using rule 70 (Factor -> ( Exp ) .)
    %               reduce using rule 70 (Factor -> ( Exp ) .)
    +               reduce using rule 70 (Factor -> ( Exp ) .)
    -               reduce using rule 70 (Factor -> ( Exp ) .)
    }               reduce using rule 70 (Factor -> ( Exp ) .)
    id              reduce using rule 70 (Factor -> ( Exp ) .)
    return          reduce using rule 70 (Factor -> ( Exp ) .)
    print           reduce using rule 70 (Factor -> ( Exp ) .)
    println         reduce using rule 70 (Factor -> ( Exp ) .)
    prints          reduce using rule 70 (Factor -> ( Exp ) .)
    for             reduce using rule 70 (Factor -> ( Exp ) .)
    while           reduce using rule 70 (Factor -> ( Exp ) .)
    read            reduce using rule 70 (Factor -> ( Exp ) .)
    if              reduce using rule 70 (Factor -> ( Exp ) .)
    repeat          reduce using rule 70 (Factor -> ( Exp ) .)
    num             reduce using rule 70 (Factor -> ( Exp ) .)
    (               reduce using rule 70 (Factor -> ( Exp ) .)
    )               reduce using rule 70 (Factor -> ( Exp ) .)
    sup             reduce using rule 70 (Factor -> ( Exp ) .)
    inf             reduce using rule 70 (Factor -> ( Exp ) .)
    supeq           reduce using rule 70 (Factor -> ( Exp ) .)
    infeq           reduce using rule 70 (Factor -> ( Exp ) .)
    eq              reduce using rule 70 (Factor -> ( Exp ) .)
    diff            reduce using rule 70 (Factor -> ( Exp ) .)
    ;               reduce using rule 70 (Factor -> ( Exp ) .)
    ]               reduce using rule 70 (Factor -> ( Exp ) .)
    and             reduce using rule 70 (Factor -> ( Exp ) .)
    or              reduce using rule 70 (Factor -> ( Exp ) .)


state 107

    (78) Cond -> Exp sup . Exp
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 69
    num             shift and go to state 36
    (               shift and go to state 30

    Exp                            shift and go to state 135
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 108

    (79) Cond -> Exp inf . Exp
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 69
    num             shift and go to state 36
    (               shift and go to state 30

    Exp                            shift and go to state 136
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 109

    (80) Cond -> Exp supeq . Exp
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 69
    num             shift and go to state 36
    (               shift and go to state 30

    Exp                            shift and go to state 137
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 110

    (81) Cond -> Exp infeq . Exp
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 69
    num             shift and go to state 36
    (               shift and go to state 30

    Exp                            shift and go to state 138
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 111

    (83) Cond -> Exp eq . Exp
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 69
    num             shift and go to state 36
    (               shift and go to state 30

    Exp                            shift and go to state 139
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 112

    (84) Cond -> Exp diff . Exp
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 69
    num             shift and go to state 36
    (               shift and go to state 30

    Exp                            shift and go to state 140
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 113

    (82) Cond -> not Exp .
    (43) Exp -> Exp . + Term
    (44) Exp -> Exp . - Term

    )               reduce using rule 82 (Cond -> not Exp .)
    and             reduce using rule 82 (Cond -> not Exp .)
    or              reduce using rule 82 (Cond -> not Exp .)
    ;               reduce using rule 82 (Cond -> not Exp .)
    +               shift and go to state 45
    -               shift and go to state 46


state 114

    (68) Factor -> id [ . Exp ]
    (69) Factor -> id [ . Exp ] [ Exp ]
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 69
    num             shift and go to state 36
    (               shift and go to state 30

    Exp                            shift and go to state 141
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 115

    (50) Term -> Term * Factor .

    *               reduce using rule 50 (Term -> Term * Factor .)
    /               reduce using rule 50 (Term -> Term * Factor .)
    %               reduce using rule 50 (Term -> Term * Factor .)
    +               reduce using rule 50 (Term -> Term * Factor .)
    -               reduce using rule 50 (Term -> Term * Factor .)
    }               reduce using rule 50 (Term -> Term * Factor .)
    id              reduce using rule 50 (Term -> Term * Factor .)
    return          reduce using rule 50 (Term -> Term * Factor .)
    print           reduce using rule 50 (Term -> Term * Factor .)
    println         reduce using rule 50 (Term -> Term * Factor .)
    prints          reduce using rule 50 (Term -> Term * Factor .)
    for             reduce using rule 50 (Term -> Term * Factor .)
    while           reduce using rule 50 (Term -> Term * Factor .)
    read            reduce using rule 50 (Term -> Term * Factor .)
    if              reduce using rule 50 (Term -> Term * Factor .)
    repeat          reduce using rule 50 (Term -> Term * Factor .)
    num             reduce using rule 50 (Term -> Term * Factor .)
    (               reduce using rule 50 (Term -> Term * Factor .)
    )               reduce using rule 50 (Term -> Term * Factor .)
    sup             reduce using rule 50 (Term -> Term * Factor .)
    inf             reduce using rule 50 (Term -> Term * Factor .)
    supeq           reduce using rule 50 (Term -> Term * Factor .)
    infeq           reduce using rule 50 (Term -> Term * Factor .)
    eq              reduce using rule 50 (Term -> Term * Factor .)
    diff            reduce using rule 50 (Term -> Term * Factor .)
    ;               reduce using rule 50 (Term -> Term * Factor .)
    ]               reduce using rule 50 (Term -> Term * Factor .)
    and             reduce using rule 50 (Term -> Term * Factor .)
    or              reduce using rule 50 (Term -> Term * Factor .)


state 116

    (51) Term -> Term / Factor .

    *               reduce using rule 51 (Term -> Term / Factor .)
    /               reduce using rule 51 (Term -> Term / Factor .)
    %               reduce using rule 51 (Term -> Term / Factor .)
    +               reduce using rule 51 (Term -> Term / Factor .)
    -               reduce using rule 51 (Term -> Term / Factor .)
    }               reduce using rule 51 (Term -> Term / Factor .)
    id              reduce using rule 51 (Term -> Term / Factor .)
    return          reduce using rule 51 (Term -> Term / Factor .)
    print           reduce using rule 51 (Term -> Term / Factor .)
    println         reduce using rule 51 (Term -> Term / Factor .)
    prints          reduce using rule 51 (Term -> Term / Factor .)
    for             reduce using rule 51 (Term -> Term / Factor .)
    while           reduce using rule 51 (Term -> Term / Factor .)
    read            reduce using rule 51 (Term -> Term / Factor .)
    if              reduce using rule 51 (Term -> Term / Factor .)
    repeat          reduce using rule 51 (Term -> Term / Factor .)
    num             reduce using rule 51 (Term -> Term / Factor .)
    (               reduce using rule 51 (Term -> Term / Factor .)
    )               reduce using rule 51 (Term -> Term / Factor .)
    sup             reduce using rule 51 (Term -> Term / Factor .)
    inf             reduce using rule 51 (Term -> Term / Factor .)
    supeq           reduce using rule 51 (Term -> Term / Factor .)
    infeq           reduce using rule 51 (Term -> Term / Factor .)
    eq              reduce using rule 51 (Term -> Term / Factor .)
    diff            reduce using rule 51 (Term -> Term / Factor .)
    ;               reduce using rule 51 (Term -> Term / Factor .)
    ]               reduce using rule 51 (Term -> Term / Factor .)
    and             reduce using rule 51 (Term -> Term / Factor .)
    or              reduce using rule 51 (Term -> Term / Factor .)


state 117

    (52) Term -> Term % Factor .

    *               reduce using rule 52 (Term -> Term % Factor .)
    /               reduce using rule 52 (Term -> Term % Factor .)
    %               reduce using rule 52 (Term -> Term % Factor .)
    +               reduce using rule 52 (Term -> Term % Factor .)
    -               reduce using rule 52 (Term -> Term % Factor .)
    }               reduce using rule 52 (Term -> Term % Factor .)
    id              reduce using rule 52 (Term -> Term % Factor .)
    return          reduce using rule 52 (Term -> Term % Factor .)
    print           reduce using rule 52 (Term -> Term % Factor .)
    println         reduce using rule 52 (Term -> Term % Factor .)
    prints          reduce using rule 52 (Term -> Term % Factor .)
    for             reduce using rule 52 (Term -> Term % Factor .)
    while           reduce using rule 52 (Term -> Term % Factor .)
    read            reduce using rule 52 (Term -> Term % Factor .)
    if              reduce using rule 52 (Term -> Term % Factor .)
    repeat          reduce using rule 52 (Term -> Term % Factor .)
    num             reduce using rule 52 (Term -> Term % Factor .)
    (               reduce using rule 52 (Term -> Term % Factor .)
    )               reduce using rule 52 (Term -> Term % Factor .)
    sup             reduce using rule 52 (Term -> Term % Factor .)
    inf             reduce using rule 52 (Term -> Term % Factor .)
    supeq           reduce using rule 52 (Term -> Term % Factor .)
    infeq           reduce using rule 52 (Term -> Term % Factor .)
    eq              reduce using rule 52 (Term -> Term % Factor .)
    diff            reduce using rule 52 (Term -> Term % Factor .)
    ;               reduce using rule 52 (Term -> Term % Factor .)
    ]               reduce using rule 52 (Term -> Term % Factor .)
    and             reduce using rule 52 (Term -> Term % Factor .)
    or              reduce using rule 52 (Term -> Term % Factor .)


state 118

    (27) Print -> print ( Exp . )
    (43) Exp -> Exp . + Term
    (44) Exp -> Exp . - Term

    )               shift and go to state 142
    +               shift and go to state 45
    -               shift and go to state 46


state 119

    (28) Println -> println ( Exp . )
    (43) Exp -> Exp . + Term
    (44) Exp -> Exp . - Term

    )               shift and go to state 143
    +               shift and go to state 45
    -               shift and go to state 46


state 120

    (29) Prints -> prints ( string . )

    )               shift and go to state 144


state 121

    (22) Repeat -> RepeatS ( num . ) { Insts }

    )               shift and go to state 145


state 122

    (24) For -> for ( Insts . ; Cond ; Insts ) { Insts }
    (9) Insts -> Insts . Inst
    (11) Inst -> . Attr
    (12) Inst -> . Return
    (13) Inst -> . Exp
    (14) Inst -> . Print
    (15) Inst -> . Println
    (16) Inst -> . Prints
    (17) Inst -> . Repeat
    (18) Inst -> . For
    (19) Inst -> . While
    (20) Inst -> . Read
    (21) Inst -> . If
    (34) Attr -> . id = Exp
    (35) Attr -> . id [ Exp ] = Exp
    (36) Attr -> . id [ Exp ] [ Exp ] = Exp
    (37) Return -> . return ( Exp )
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (27) Print -> . print ( Exp )
    (28) Println -> . println ( Exp )
    (29) Prints -> . prints ( string )
    (22) Repeat -> . RepeatS ( num ) { Insts }
    (24) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (25) While -> . while ( Cond ) { Insts }
    (26) Read -> . read ( id )
    (38) If -> . if ( Cond ) { Insts }
    (39) If -> . if ( Cond ) Inst
    (41) If -> . if ( Cond ) { Insts } else { Insts }
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (23) RepeatS -> . repeat
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    ;               shift and go to state 146
    id              shift and go to state 28
    return          shift and go to state 29
    print           shift and go to state 32
    println         shift and go to state 33
    prints          shift and go to state 34
    for             shift and go to state 37
    while           shift and go to state 38
    read            shift and go to state 39
    if              shift and go to state 40
    repeat          shift and go to state 42
    num             shift and go to state 36
    (               shift and go to state 30

    Inst                           shift and go to state 16
    Attr                           shift and go to state 17
    Return                         shift and go to state 18
    Exp                            shift and go to state 19
    Print                          shift and go to state 20
    Println                        shift and go to state 21
    Prints                         shift and go to state 22
    Repeat                         shift and go to state 23
    For                            shift and go to state 24
    While                          shift and go to state 25
    Read                           shift and go to state 26
    If                             shift and go to state 27
    Term                           shift and go to state 31
    RepeatS                        shift and go to state 35
    Factor                         shift and go to state 41

state 123

    (25) While -> while ( Cond . ) { Insts }
    (74) Cond -> Cond . and Cond
    (75) Cond -> Cond . or Cond

    )               shift and go to state 147
    and             shift and go to state 104
    or              shift and go to state 105


state 124

    (78) Cond -> Exp . sup Exp
    (79) Cond -> Exp . inf Exp
    (80) Cond -> Exp . supeq Exp
    (81) Cond -> Exp . infeq Exp
    (83) Cond -> Exp . eq Exp
    (84) Cond -> Exp . diff Exp
    (43) Exp -> Exp . + Term
    (44) Exp -> Exp . - Term

    sup             shift and go to state 107
    inf             shift and go to state 108
    supeq           shift and go to state 109
    infeq           shift and go to state 110
    eq              shift and go to state 111
    diff            shift and go to state 112
    +               shift and go to state 45
    -               shift and go to state 46


state 125

    (26) Read -> read ( id . )

    )               shift and go to state 148


state 126

    (38) If -> if ( Cond . ) { Insts }
    (39) If -> if ( Cond . ) Inst
    (41) If -> if ( Cond . ) { Insts } else { Insts }
    (74) Cond -> Cond . and Cond
    (75) Cond -> Cond . or Cond

    )               shift and go to state 149
    and             shift and go to state 104
    or              shift and go to state 105


state 127

    (30) Dcl -> int id [ num . ]
    (31) Dcl -> int id [ num . ] [ num ]

    ]               shift and go to state 150


state 128

    (33) Dcl -> int id = num .

    int             reduce using rule 33 (Dcl -> int id = num .)
    }               reduce using rule 33 (Dcl -> int id = num .)
    id              reduce using rule 33 (Dcl -> int id = num .)
    return          reduce using rule 33 (Dcl -> int id = num .)
    print           reduce using rule 33 (Dcl -> int id = num .)
    println         reduce using rule 33 (Dcl -> int id = num .)
    prints          reduce using rule 33 (Dcl -> int id = num .)
    for             reduce using rule 33 (Dcl -> int id = num .)
    while           reduce using rule 33 (Dcl -> int id = num .)
    read            reduce using rule 33 (Dcl -> int id = num .)
    if              reduce using rule 33 (Dcl -> int id = num .)
    repeat          reduce using rule 33 (Dcl -> int id = num .)
    num             reduce using rule 33 (Dcl -> int id = num .)
    (               reduce using rule 33 (Dcl -> int id = num .)


state 129

    (35) Attr -> id [ Exp ] . = Exp
    (36) Attr -> id [ Exp ] . [ Exp ] = Exp
    (68) Factor -> id [ Exp ] .
    (69) Factor -> id [ Exp ] . [ Exp ]

    =               shift and go to state 152
    [               shift and go to state 151
    *               reduce using rule 68 (Factor -> id [ Exp ] .)
    /               reduce using rule 68 (Factor -> id [ Exp ] .)
    %               reduce using rule 68 (Factor -> id [ Exp ] .)
    +               reduce using rule 68 (Factor -> id [ Exp ] .)
    -               reduce using rule 68 (Factor -> id [ Exp ] .)
    }               reduce using rule 68 (Factor -> id [ Exp ] .)
    id              reduce using rule 68 (Factor -> id [ Exp ] .)
    return          reduce using rule 68 (Factor -> id [ Exp ] .)
    print           reduce using rule 68 (Factor -> id [ Exp ] .)
    println         reduce using rule 68 (Factor -> id [ Exp ] .)
    prints          reduce using rule 68 (Factor -> id [ Exp ] .)
    for             reduce using rule 68 (Factor -> id [ Exp ] .)
    while           reduce using rule 68 (Factor -> id [ Exp ] .)
    read            reduce using rule 68 (Factor -> id [ Exp ] .)
    if              reduce using rule 68 (Factor -> id [ Exp ] .)
    repeat          reduce using rule 68 (Factor -> id [ Exp ] .)
    num             reduce using rule 68 (Factor -> id [ Exp ] .)
    (               reduce using rule 68 (Factor -> id [ Exp ] .)
    ;               reduce using rule 68 (Factor -> id [ Exp ] .)
    )               reduce using rule 68 (Factor -> id [ Exp ] .)


state 130

    (37) Return -> return ( Exp ) .

    }               reduce using rule 37 (Return -> return ( Exp ) .)
    id              reduce using rule 37 (Return -> return ( Exp ) .)
    return          reduce using rule 37 (Return -> return ( Exp ) .)
    print           reduce using rule 37 (Return -> return ( Exp ) .)
    println         reduce using rule 37 (Return -> return ( Exp ) .)
    prints          reduce using rule 37 (Return -> return ( Exp ) .)
    for             reduce using rule 37 (Return -> return ( Exp ) .)
    while           reduce using rule 37 (Return -> return ( Exp ) .)
    read            reduce using rule 37 (Return -> return ( Exp ) .)
    if              reduce using rule 37 (Return -> return ( Exp ) .)
    repeat          reduce using rule 37 (Return -> return ( Exp ) .)
    num             reduce using rule 37 (Return -> return ( Exp ) .)
    (               reduce using rule 37 (Return -> return ( Exp ) .)
    ;               reduce using rule 37 (Return -> return ( Exp ) .)
    )               reduce using rule 37 (Return -> return ( Exp ) .)


state 131

    (76) Cond -> ( Cond and . Cond )
    (74) Cond -> Cond and . Cond
    (74) Cond -> . Cond and Cond
    (75) Cond -> . Cond or Cond
    (76) Cond -> . ( Cond and Cond )
    (77) Cond -> . ( Cond or Cond )
    (78) Cond -> . Exp sup Exp
    (79) Cond -> . Exp inf Exp
    (80) Cond -> . Exp supeq Exp
    (81) Cond -> . Exp infeq Exp
    (82) Cond -> . not Exp
    (83) Cond -> . Exp eq Exp
    (84) Cond -> . Exp diff Exp
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    (               shift and go to state 65
    not             shift and go to state 68
    id              shift and go to state 69
    num             shift and go to state 36

    Cond                           shift and go to state 153
    Exp                            shift and go to state 124
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 132

    (77) Cond -> ( Cond or . Cond )
    (75) Cond -> Cond or . Cond
    (74) Cond -> . Cond and Cond
    (75) Cond -> . Cond or Cond
    (76) Cond -> . ( Cond and Cond )
    (77) Cond -> . ( Cond or Cond )
    (78) Cond -> . Exp sup Exp
    (79) Cond -> . Exp inf Exp
    (80) Cond -> . Exp supeq Exp
    (81) Cond -> . Exp infeq Exp
    (82) Cond -> . not Exp
    (83) Cond -> . Exp eq Exp
    (84) Cond -> . Exp diff Exp
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    (               shift and go to state 65
    not             shift and go to state 68
    id              shift and go to state 69
    num             shift and go to state 36

    Cond                           shift and go to state 154
    Exp                            shift and go to state 124
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 133

    (74) Cond -> Cond and Cond .
    (74) Cond -> Cond . and Cond
    (75) Cond -> Cond . or Cond

  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
    )               reduce using rule 74 (Cond -> Cond and Cond .)
    ;               reduce using rule 74 (Cond -> Cond and Cond .)
    and             shift and go to state 104
    or              shift and go to state 105

  ! and             [ reduce using rule 74 (Cond -> Cond and Cond .) ]
  ! or              [ reduce using rule 74 (Cond -> Cond and Cond .) ]


state 134

    (75) Cond -> Cond or Cond .
    (74) Cond -> Cond . and Cond
    (75) Cond -> Cond . or Cond

  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
    )               reduce using rule 75 (Cond -> Cond or Cond .)
    ;               reduce using rule 75 (Cond -> Cond or Cond .)
    and             shift and go to state 104
    or              shift and go to state 105

  ! and             [ reduce using rule 75 (Cond -> Cond or Cond .) ]
  ! or              [ reduce using rule 75 (Cond -> Cond or Cond .) ]


state 135

    (78) Cond -> Exp sup Exp .
    (43) Exp -> Exp . + Term
    (44) Exp -> Exp . - Term

    )               reduce using rule 78 (Cond -> Exp sup Exp .)
    and             reduce using rule 78 (Cond -> Exp sup Exp .)
    or              reduce using rule 78 (Cond -> Exp sup Exp .)
    ;               reduce using rule 78 (Cond -> Exp sup Exp .)
    +               shift and go to state 45
    -               shift and go to state 46


state 136

    (79) Cond -> Exp inf Exp .
    (43) Exp -> Exp . + Term
    (44) Exp -> Exp . - Term

    )               reduce using rule 79 (Cond -> Exp inf Exp .)
    and             reduce using rule 79 (Cond -> Exp inf Exp .)
    or              reduce using rule 79 (Cond -> Exp inf Exp .)
    ;               reduce using rule 79 (Cond -> Exp inf Exp .)
    +               shift and go to state 45
    -               shift and go to state 46


state 137

    (80) Cond -> Exp supeq Exp .
    (43) Exp -> Exp . + Term
    (44) Exp -> Exp . - Term

    )               reduce using rule 80 (Cond -> Exp supeq Exp .)
    and             reduce using rule 80 (Cond -> Exp supeq Exp .)
    or              reduce using rule 80 (Cond -> Exp supeq Exp .)
    ;               reduce using rule 80 (Cond -> Exp supeq Exp .)
    +               shift and go to state 45
    -               shift and go to state 46


state 138

    (81) Cond -> Exp infeq Exp .
    (43) Exp -> Exp . + Term
    (44) Exp -> Exp . - Term

    )               reduce using rule 81 (Cond -> Exp infeq Exp .)
    and             reduce using rule 81 (Cond -> Exp infeq Exp .)
    or              reduce using rule 81 (Cond -> Exp infeq Exp .)
    ;               reduce using rule 81 (Cond -> Exp infeq Exp .)
    +               shift and go to state 45
    -               shift and go to state 46


state 139

    (83) Cond -> Exp eq Exp .
    (43) Exp -> Exp . + Term
    (44) Exp -> Exp . - Term

    )               reduce using rule 83 (Cond -> Exp eq Exp .)
    and             reduce using rule 83 (Cond -> Exp eq Exp .)
    or              reduce using rule 83 (Cond -> Exp eq Exp .)
    ;               reduce using rule 83 (Cond -> Exp eq Exp .)
    +               shift and go to state 45
    -               shift and go to state 46


state 140

    (84) Cond -> Exp diff Exp .
    (43) Exp -> Exp . + Term
    (44) Exp -> Exp . - Term

    )               reduce using rule 84 (Cond -> Exp diff Exp .)
    and             reduce using rule 84 (Cond -> Exp diff Exp .)
    or              reduce using rule 84 (Cond -> Exp diff Exp .)
    ;               reduce using rule 84 (Cond -> Exp diff Exp .)
    +               shift and go to state 45
    -               shift and go to state 46


state 141

    (68) Factor -> id [ Exp . ]
    (69) Factor -> id [ Exp . ] [ Exp ]
    (43) Exp -> Exp . + Term
    (44) Exp -> Exp . - Term

    ]               shift and go to state 155
    +               shift and go to state 45
    -               shift and go to state 46


state 142

    (27) Print -> print ( Exp ) .

    }               reduce using rule 27 (Print -> print ( Exp ) .)
    id              reduce using rule 27 (Print -> print ( Exp ) .)
    return          reduce using rule 27 (Print -> print ( Exp ) .)
    print           reduce using rule 27 (Print -> print ( Exp ) .)
    println         reduce using rule 27 (Print -> print ( Exp ) .)
    prints          reduce using rule 27 (Print -> print ( Exp ) .)
    for             reduce using rule 27 (Print -> print ( Exp ) .)
    while           reduce using rule 27 (Print -> print ( Exp ) .)
    read            reduce using rule 27 (Print -> print ( Exp ) .)
    if              reduce using rule 27 (Print -> print ( Exp ) .)
    repeat          reduce using rule 27 (Print -> print ( Exp ) .)
    num             reduce using rule 27 (Print -> print ( Exp ) .)
    (               reduce using rule 27 (Print -> print ( Exp ) .)
    ;               reduce using rule 27 (Print -> print ( Exp ) .)
    )               reduce using rule 27 (Print -> print ( Exp ) .)


state 143

    (28) Println -> println ( Exp ) .

    }               reduce using rule 28 (Println -> println ( Exp ) .)
    id              reduce using rule 28 (Println -> println ( Exp ) .)
    return          reduce using rule 28 (Println -> println ( Exp ) .)
    print           reduce using rule 28 (Println -> println ( Exp ) .)
    println         reduce using rule 28 (Println -> println ( Exp ) .)
    prints          reduce using rule 28 (Println -> println ( Exp ) .)
    for             reduce using rule 28 (Println -> println ( Exp ) .)
    while           reduce using rule 28 (Println -> println ( Exp ) .)
    read            reduce using rule 28 (Println -> println ( Exp ) .)
    if              reduce using rule 28 (Println -> println ( Exp ) .)
    repeat          reduce using rule 28 (Println -> println ( Exp ) .)
    num             reduce using rule 28 (Println -> println ( Exp ) .)
    (               reduce using rule 28 (Println -> println ( Exp ) .)
    ;               reduce using rule 28 (Println -> println ( Exp ) .)
    )               reduce using rule 28 (Println -> println ( Exp ) .)


state 144

    (29) Prints -> prints ( string ) .

    }               reduce using rule 29 (Prints -> prints ( string ) .)
    id              reduce using rule 29 (Prints -> prints ( string ) .)
    return          reduce using rule 29 (Prints -> prints ( string ) .)
    print           reduce using rule 29 (Prints -> prints ( string ) .)
    println         reduce using rule 29 (Prints -> prints ( string ) .)
    prints          reduce using rule 29 (Prints -> prints ( string ) .)
    for             reduce using rule 29 (Prints -> prints ( string ) .)
    while           reduce using rule 29 (Prints -> prints ( string ) .)
    read            reduce using rule 29 (Prints -> prints ( string ) .)
    if              reduce using rule 29 (Prints -> prints ( string ) .)
    repeat          reduce using rule 29 (Prints -> prints ( string ) .)
    num             reduce using rule 29 (Prints -> prints ( string ) .)
    (               reduce using rule 29 (Prints -> prints ( string ) .)
    ;               reduce using rule 29 (Prints -> prints ( string ) .)
    )               reduce using rule 29 (Prints -> prints ( string ) .)


state 145

    (22) Repeat -> RepeatS ( num ) . { Insts }

    {               shift and go to state 156


state 146

    (24) For -> for ( Insts ; . Cond ; Insts ) { Insts }
    (74) Cond -> . Cond and Cond
    (75) Cond -> . Cond or Cond
    (76) Cond -> . ( Cond and Cond )
    (77) Cond -> . ( Cond or Cond )
    (78) Cond -> . Exp sup Exp
    (79) Cond -> . Exp inf Exp
    (80) Cond -> . Exp supeq Exp
    (81) Cond -> . Exp infeq Exp
    (82) Cond -> . not Exp
    (83) Cond -> . Exp eq Exp
    (84) Cond -> . Exp diff Exp
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    (               shift and go to state 65
    not             shift and go to state 68
    id              shift and go to state 69
    num             shift and go to state 36

    Cond                           shift and go to state 157
    Exp                            shift and go to state 124
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 147

    (25) While -> while ( Cond ) . { Insts }

    {               shift and go to state 158


state 148

    (26) Read -> read ( id ) .

    }               reduce using rule 26 (Read -> read ( id ) .)
    id              reduce using rule 26 (Read -> read ( id ) .)
    return          reduce using rule 26 (Read -> read ( id ) .)
    print           reduce using rule 26 (Read -> read ( id ) .)
    println         reduce using rule 26 (Read -> read ( id ) .)
    prints          reduce using rule 26 (Read -> read ( id ) .)
    for             reduce using rule 26 (Read -> read ( id ) .)
    while           reduce using rule 26 (Read -> read ( id ) .)
    read            reduce using rule 26 (Read -> read ( id ) .)
    if              reduce using rule 26 (Read -> read ( id ) .)
    repeat          reduce using rule 26 (Read -> read ( id ) .)
    num             reduce using rule 26 (Read -> read ( id ) .)
    (               reduce using rule 26 (Read -> read ( id ) .)
    ;               reduce using rule 26 (Read -> read ( id ) .)
    )               reduce using rule 26 (Read -> read ( id ) .)


state 149

    (38) If -> if ( Cond ) . { Insts }
    (39) If -> if ( Cond ) . Inst
    (41) If -> if ( Cond ) . { Insts } else { Insts }
    (11) Inst -> . Attr
    (12) Inst -> . Return
    (13) Inst -> . Exp
    (14) Inst -> . Print
    (15) Inst -> . Println
    (16) Inst -> . Prints
    (17) Inst -> . Repeat
    (18) Inst -> . For
    (19) Inst -> . While
    (20) Inst -> . Read
    (21) Inst -> . If
    (34) Attr -> . id = Exp
    (35) Attr -> . id [ Exp ] = Exp
    (36) Attr -> . id [ Exp ] [ Exp ] = Exp
    (37) Return -> . return ( Exp )
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (27) Print -> . print ( Exp )
    (28) Println -> . println ( Exp )
    (29) Prints -> . prints ( string )
    (22) Repeat -> . RepeatS ( num ) { Insts }
    (24) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (25) While -> . while ( Cond ) { Insts }
    (26) Read -> . read ( id )
    (38) If -> . if ( Cond ) { Insts }
    (39) If -> . if ( Cond ) Inst
    (41) If -> . if ( Cond ) { Insts } else { Insts }
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (23) RepeatS -> . repeat
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    {               shift and go to state 159
    id              shift and go to state 28
    return          shift and go to state 29
    print           shift and go to state 32
    println         shift and go to state 33
    prints          shift and go to state 34
    for             shift and go to state 37
    while           shift and go to state 38
    read            shift and go to state 39
    if              shift and go to state 40
    repeat          shift and go to state 42
    num             shift and go to state 36
    (               shift and go to state 30

    Inst                           shift and go to state 160
    Attr                           shift and go to state 17
    Return                         shift and go to state 18
    Exp                            shift and go to state 19
    Print                          shift and go to state 20
    Println                        shift and go to state 21
    Prints                         shift and go to state 22
    Repeat                         shift and go to state 23
    For                            shift and go to state 24
    While                          shift and go to state 25
    Read                           shift and go to state 26
    If                             shift and go to state 27
    Term                           shift and go to state 31
    RepeatS                        shift and go to state 35
    Factor                         shift and go to state 41

state 150

    (30) Dcl -> int id [ num ] .
    (31) Dcl -> int id [ num ] . [ num ]

    int             reduce using rule 30 (Dcl -> int id [ num ] .)
    }               reduce using rule 30 (Dcl -> int id [ num ] .)
    id              reduce using rule 30 (Dcl -> int id [ num ] .)
    return          reduce using rule 30 (Dcl -> int id [ num ] .)
    print           reduce using rule 30 (Dcl -> int id [ num ] .)
    println         reduce using rule 30 (Dcl -> int id [ num ] .)
    prints          reduce using rule 30 (Dcl -> int id [ num ] .)
    for             reduce using rule 30 (Dcl -> int id [ num ] .)
    while           reduce using rule 30 (Dcl -> int id [ num ] .)
    read            reduce using rule 30 (Dcl -> int id [ num ] .)
    if              reduce using rule 30 (Dcl -> int id [ num ] .)
    repeat          reduce using rule 30 (Dcl -> int id [ num ] .)
    num             reduce using rule 30 (Dcl -> int id [ num ] .)
    (               reduce using rule 30 (Dcl -> int id [ num ] .)
    [               shift and go to state 161


state 151

    (36) Attr -> id [ Exp ] [ . Exp ] = Exp
    (69) Factor -> id [ Exp ] [ . Exp ]
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 69
    num             shift and go to state 36
    (               shift and go to state 30

    Exp                            shift and go to state 162
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 152

    (35) Attr -> id [ Exp ] = . Exp
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 69
    num             shift and go to state 36
    (               shift and go to state 30

    Exp                            shift and go to state 163
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 153

    (76) Cond -> ( Cond and Cond . )
    (74) Cond -> Cond and Cond .
    (74) Cond -> Cond . and Cond
    (75) Cond -> Cond . or Cond

  ! shift/reduce conflict for ) resolved as shift
  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
    )               shift and go to state 164
    and             shift and go to state 104
    or              shift and go to state 105

  ! and             [ reduce using rule 74 (Cond -> Cond and Cond .) ]
  ! or              [ reduce using rule 74 (Cond -> Cond and Cond .) ]
  ! )               [ reduce using rule 74 (Cond -> Cond and Cond .) ]


state 154

    (77) Cond -> ( Cond or Cond . )
    (75) Cond -> Cond or Cond .
    (74) Cond -> Cond . and Cond
    (75) Cond -> Cond . or Cond

  ! shift/reduce conflict for ) resolved as shift
  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
    )               shift and go to state 165
    and             shift and go to state 104
    or              shift and go to state 105

  ! and             [ reduce using rule 75 (Cond -> Cond or Cond .) ]
  ! or              [ reduce using rule 75 (Cond -> Cond or Cond .) ]
  ! )               [ reduce using rule 75 (Cond -> Cond or Cond .) ]


state 155

    (68) Factor -> id [ Exp ] .
    (69) Factor -> id [ Exp ] . [ Exp ]

    *               reduce using rule 68 (Factor -> id [ Exp ] .)
    /               reduce using rule 68 (Factor -> id [ Exp ] .)
    %               reduce using rule 68 (Factor -> id [ Exp ] .)
    )               reduce using rule 68 (Factor -> id [ Exp ] .)
    sup             reduce using rule 68 (Factor -> id [ Exp ] .)
    inf             reduce using rule 68 (Factor -> id [ Exp ] .)
    supeq           reduce using rule 68 (Factor -> id [ Exp ] .)
    infeq           reduce using rule 68 (Factor -> id [ Exp ] .)
    eq              reduce using rule 68 (Factor -> id [ Exp ] .)
    diff            reduce using rule 68 (Factor -> id [ Exp ] .)
    +               reduce using rule 68 (Factor -> id [ Exp ] .)
    -               reduce using rule 68 (Factor -> id [ Exp ] .)
    }               reduce using rule 68 (Factor -> id [ Exp ] .)
    id              reduce using rule 68 (Factor -> id [ Exp ] .)
    return          reduce using rule 68 (Factor -> id [ Exp ] .)
    print           reduce using rule 68 (Factor -> id [ Exp ] .)
    println         reduce using rule 68 (Factor -> id [ Exp ] .)
    prints          reduce using rule 68 (Factor -> id [ Exp ] .)
    for             reduce using rule 68 (Factor -> id [ Exp ] .)
    while           reduce using rule 68 (Factor -> id [ Exp ] .)
    read            reduce using rule 68 (Factor -> id [ Exp ] .)
    if              reduce using rule 68 (Factor -> id [ Exp ] .)
    repeat          reduce using rule 68 (Factor -> id [ Exp ] .)
    num             reduce using rule 68 (Factor -> id [ Exp ] .)
    (               reduce using rule 68 (Factor -> id [ Exp ] .)
    ;               reduce using rule 68 (Factor -> id [ Exp ] .)
    ]               reduce using rule 68 (Factor -> id [ Exp ] .)
    and             reduce using rule 68 (Factor -> id [ Exp ] .)
    or              reduce using rule 68 (Factor -> id [ Exp ] .)
    [               shift and go to state 166


state 156

    (22) Repeat -> RepeatS ( num ) { . Insts }
    (9) Insts -> . Insts Inst
    (10) Insts -> .

    }               reduce using rule 10 (Insts -> .)
    id              reduce using rule 10 (Insts -> .)
    return          reduce using rule 10 (Insts -> .)
    print           reduce using rule 10 (Insts -> .)
    println         reduce using rule 10 (Insts -> .)
    prints          reduce using rule 10 (Insts -> .)
    for             reduce using rule 10 (Insts -> .)
    while           reduce using rule 10 (Insts -> .)
    read            reduce using rule 10 (Insts -> .)
    if              reduce using rule 10 (Insts -> .)
    repeat          reduce using rule 10 (Insts -> .)
    num             reduce using rule 10 (Insts -> .)
    (               reduce using rule 10 (Insts -> .)

    Insts                          shift and go to state 167

state 157

    (24) For -> for ( Insts ; Cond . ; Insts ) { Insts }
    (74) Cond -> Cond . and Cond
    (75) Cond -> Cond . or Cond

    ;               shift and go to state 168
    and             shift and go to state 104
    or              shift and go to state 105


state 158

    (25) While -> while ( Cond ) { . Insts }
    (9) Insts -> . Insts Inst
    (10) Insts -> .

    }               reduce using rule 10 (Insts -> .)
    id              reduce using rule 10 (Insts -> .)
    return          reduce using rule 10 (Insts -> .)
    print           reduce using rule 10 (Insts -> .)
    println         reduce using rule 10 (Insts -> .)
    prints          reduce using rule 10 (Insts -> .)
    for             reduce using rule 10 (Insts -> .)
    while           reduce using rule 10 (Insts -> .)
    read            reduce using rule 10 (Insts -> .)
    if              reduce using rule 10 (Insts -> .)
    repeat          reduce using rule 10 (Insts -> .)
    num             reduce using rule 10 (Insts -> .)
    (               reduce using rule 10 (Insts -> .)

    Insts                          shift and go to state 169

state 159

    (38) If -> if ( Cond ) { . Insts }
    (41) If -> if ( Cond ) { . Insts } else { Insts }
    (9) Insts -> . Insts Inst
    (10) Insts -> .

    }               reduce using rule 10 (Insts -> .)
    id              reduce using rule 10 (Insts -> .)
    return          reduce using rule 10 (Insts -> .)
    print           reduce using rule 10 (Insts -> .)
    println         reduce using rule 10 (Insts -> .)
    prints          reduce using rule 10 (Insts -> .)
    for             reduce using rule 10 (Insts -> .)
    while           reduce using rule 10 (Insts -> .)
    read            reduce using rule 10 (Insts -> .)
    if              reduce using rule 10 (Insts -> .)
    repeat          reduce using rule 10 (Insts -> .)
    num             reduce using rule 10 (Insts -> .)
    (               reduce using rule 10 (Insts -> .)

    Insts                          shift and go to state 170

state 160

    (39) If -> if ( Cond ) Inst .

    }               reduce using rule 39 (If -> if ( Cond ) Inst .)
    id              reduce using rule 39 (If -> if ( Cond ) Inst .)
    return          reduce using rule 39 (If -> if ( Cond ) Inst .)
    print           reduce using rule 39 (If -> if ( Cond ) Inst .)
    println         reduce using rule 39 (If -> if ( Cond ) Inst .)
    prints          reduce using rule 39 (If -> if ( Cond ) Inst .)
    for             reduce using rule 39 (If -> if ( Cond ) Inst .)
    while           reduce using rule 39 (If -> if ( Cond ) Inst .)
    read            reduce using rule 39 (If -> if ( Cond ) Inst .)
    if              reduce using rule 39 (If -> if ( Cond ) Inst .)
    repeat          reduce using rule 39 (If -> if ( Cond ) Inst .)
    num             reduce using rule 39 (If -> if ( Cond ) Inst .)
    (               reduce using rule 39 (If -> if ( Cond ) Inst .)
    ;               reduce using rule 39 (If -> if ( Cond ) Inst .)
    )               reduce using rule 39 (If -> if ( Cond ) Inst .)


state 161

    (31) Dcl -> int id [ num ] [ . num ]

    num             shift and go to state 171


state 162

    (36) Attr -> id [ Exp ] [ Exp . ] = Exp
    (69) Factor -> id [ Exp ] [ Exp . ]
    (43) Exp -> Exp . + Term
    (44) Exp -> Exp . - Term

    ]               shift and go to state 172
    +               shift and go to state 45
    -               shift and go to state 46


state 163

    (35) Attr -> id [ Exp ] = Exp .
    (43) Exp -> Exp . + Term
    (44) Exp -> Exp . - Term

    }               reduce using rule 35 (Attr -> id [ Exp ] = Exp .)
    id              reduce using rule 35 (Attr -> id [ Exp ] = Exp .)
    return          reduce using rule 35 (Attr -> id [ Exp ] = Exp .)
    print           reduce using rule 35 (Attr -> id [ Exp ] = Exp .)
    println         reduce using rule 35 (Attr -> id [ Exp ] = Exp .)
    prints          reduce using rule 35 (Attr -> id [ Exp ] = Exp .)
    for             reduce using rule 35 (Attr -> id [ Exp ] = Exp .)
    while           reduce using rule 35 (Attr -> id [ Exp ] = Exp .)
    read            reduce using rule 35 (Attr -> id [ Exp ] = Exp .)
    if              reduce using rule 35 (Attr -> id [ Exp ] = Exp .)
    repeat          reduce using rule 35 (Attr -> id [ Exp ] = Exp .)
    num             reduce using rule 35 (Attr -> id [ Exp ] = Exp .)
    (               reduce using rule 35 (Attr -> id [ Exp ] = Exp .)
    ;               reduce using rule 35 (Attr -> id [ Exp ] = Exp .)
    )               reduce using rule 35 (Attr -> id [ Exp ] = Exp .)
    +               shift and go to state 45
    -               shift and go to state 46


state 164

    (76) Cond -> ( Cond and Cond ) .

    )               reduce using rule 76 (Cond -> ( Cond and Cond ) .)
    and             reduce using rule 76 (Cond -> ( Cond and Cond ) .)
    or              reduce using rule 76 (Cond -> ( Cond and Cond ) .)
    ;               reduce using rule 76 (Cond -> ( Cond and Cond ) .)


state 165

    (77) Cond -> ( Cond or Cond ) .

    )               reduce using rule 77 (Cond -> ( Cond or Cond ) .)
    and             reduce using rule 77 (Cond -> ( Cond or Cond ) .)
    or              reduce using rule 77 (Cond -> ( Cond or Cond ) .)
    ;               reduce using rule 77 (Cond -> ( Cond or Cond ) .)


state 166

    (69) Factor -> id [ Exp ] [ . Exp ]
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 69
    num             shift and go to state 36
    (               shift and go to state 30

    Exp                            shift and go to state 173
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 167

    (22) Repeat -> RepeatS ( num ) { Insts . }
    (9) Insts -> Insts . Inst
    (11) Inst -> . Attr
    (12) Inst -> . Return
    (13) Inst -> . Exp
    (14) Inst -> . Print
    (15) Inst -> . Println
    (16) Inst -> . Prints
    (17) Inst -> . Repeat
    (18) Inst -> . For
    (19) Inst -> . While
    (20) Inst -> . Read
    (21) Inst -> . If
    (34) Attr -> . id = Exp
    (35) Attr -> . id [ Exp ] = Exp
    (36) Attr -> . id [ Exp ] [ Exp ] = Exp
    (37) Return -> . return ( Exp )
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (27) Print -> . print ( Exp )
    (28) Println -> . println ( Exp )
    (29) Prints -> . prints ( string )
    (22) Repeat -> . RepeatS ( num ) { Insts }
    (24) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (25) While -> . while ( Cond ) { Insts }
    (26) Read -> . read ( id )
    (38) If -> . if ( Cond ) { Insts }
    (39) If -> . if ( Cond ) Inst
    (41) If -> . if ( Cond ) { Insts } else { Insts }
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (23) RepeatS -> . repeat
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    }               shift and go to state 174
    id              shift and go to state 28
    return          shift and go to state 29
    print           shift and go to state 32
    println         shift and go to state 33
    prints          shift and go to state 34
    for             shift and go to state 37
    while           shift and go to state 38
    read            shift and go to state 39
    if              shift and go to state 40
    repeat          shift and go to state 42
    num             shift and go to state 36
    (               shift and go to state 30

    RepeatS                        shift and go to state 35
    Inst                           shift and go to state 16
    Attr                           shift and go to state 17
    Return                         shift and go to state 18
    Exp                            shift and go to state 19
    Print                          shift and go to state 20
    Println                        shift and go to state 21
    Prints                         shift and go to state 22
    Repeat                         shift and go to state 23
    For                            shift and go to state 24
    While                          shift and go to state 25
    Read                           shift and go to state 26
    If                             shift and go to state 27
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 168

    (24) For -> for ( Insts ; Cond ; . Insts ) { Insts }
    (9) Insts -> . Insts Inst
    (10) Insts -> .

    )               reduce using rule 10 (Insts -> .)
    id              reduce using rule 10 (Insts -> .)
    return          reduce using rule 10 (Insts -> .)
    print           reduce using rule 10 (Insts -> .)
    println         reduce using rule 10 (Insts -> .)
    prints          reduce using rule 10 (Insts -> .)
    for             reduce using rule 10 (Insts -> .)
    while           reduce using rule 10 (Insts -> .)
    read            reduce using rule 10 (Insts -> .)
    if              reduce using rule 10 (Insts -> .)
    repeat          reduce using rule 10 (Insts -> .)
    num             reduce using rule 10 (Insts -> .)
    (               reduce using rule 10 (Insts -> .)

    Insts                          shift and go to state 175

state 169

    (25) While -> while ( Cond ) { Insts . }
    (9) Insts -> Insts . Inst
    (11) Inst -> . Attr
    (12) Inst -> . Return
    (13) Inst -> . Exp
    (14) Inst -> . Print
    (15) Inst -> . Println
    (16) Inst -> . Prints
    (17) Inst -> . Repeat
    (18) Inst -> . For
    (19) Inst -> . While
    (20) Inst -> . Read
    (21) Inst -> . If
    (34) Attr -> . id = Exp
    (35) Attr -> . id [ Exp ] = Exp
    (36) Attr -> . id [ Exp ] [ Exp ] = Exp
    (37) Return -> . return ( Exp )
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (27) Print -> . print ( Exp )
    (28) Println -> . println ( Exp )
    (29) Prints -> . prints ( string )
    (22) Repeat -> . RepeatS ( num ) { Insts }
    (24) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (25) While -> . while ( Cond ) { Insts }
    (26) Read -> . read ( id )
    (38) If -> . if ( Cond ) { Insts }
    (39) If -> . if ( Cond ) Inst
    (41) If -> . if ( Cond ) { Insts } else { Insts }
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (23) RepeatS -> . repeat
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    }               shift and go to state 176
    id              shift and go to state 28
    return          shift and go to state 29
    print           shift and go to state 32
    println         shift and go to state 33
    prints          shift and go to state 34
    for             shift and go to state 37
    while           shift and go to state 38
    read            shift and go to state 39
    if              shift and go to state 40
    repeat          shift and go to state 42
    num             shift and go to state 36
    (               shift and go to state 30

    Inst                           shift and go to state 16
    Attr                           shift and go to state 17
    Return                         shift and go to state 18
    Exp                            shift and go to state 19
    Print                          shift and go to state 20
    Println                        shift and go to state 21
    Prints                         shift and go to state 22
    Repeat                         shift and go to state 23
    For                            shift and go to state 24
    While                          shift and go to state 25
    Read                           shift and go to state 26
    If                             shift and go to state 27
    Term                           shift and go to state 31
    RepeatS                        shift and go to state 35
    Factor                         shift and go to state 41

state 170

    (38) If -> if ( Cond ) { Insts . }
    (41) If -> if ( Cond ) { Insts . } else { Insts }
    (9) Insts -> Insts . Inst
    (11) Inst -> . Attr
    (12) Inst -> . Return
    (13) Inst -> . Exp
    (14) Inst -> . Print
    (15) Inst -> . Println
    (16) Inst -> . Prints
    (17) Inst -> . Repeat
    (18) Inst -> . For
    (19) Inst -> . While
    (20) Inst -> . Read
    (21) Inst -> . If
    (34) Attr -> . id = Exp
    (35) Attr -> . id [ Exp ] = Exp
    (36) Attr -> . id [ Exp ] [ Exp ] = Exp
    (37) Return -> . return ( Exp )
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (27) Print -> . print ( Exp )
    (28) Println -> . println ( Exp )
    (29) Prints -> . prints ( string )
    (22) Repeat -> . RepeatS ( num ) { Insts }
    (24) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (25) While -> . while ( Cond ) { Insts }
    (26) Read -> . read ( id )
    (38) If -> . if ( Cond ) { Insts }
    (39) If -> . if ( Cond ) Inst
    (41) If -> . if ( Cond ) { Insts } else { Insts }
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (23) RepeatS -> . repeat
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    }               shift and go to state 177
    id              shift and go to state 28
    return          shift and go to state 29
    print           shift and go to state 32
    println         shift and go to state 33
    prints          shift and go to state 34
    for             shift and go to state 37
    while           shift and go to state 38
    read            shift and go to state 39
    if              shift and go to state 40
    repeat          shift and go to state 42
    num             shift and go to state 36
    (               shift and go to state 30

    Inst                           shift and go to state 16
    Attr                           shift and go to state 17
    Return                         shift and go to state 18
    Exp                            shift and go to state 19
    Print                          shift and go to state 20
    Println                        shift and go to state 21
    Prints                         shift and go to state 22
    Repeat                         shift and go to state 23
    For                            shift and go to state 24
    While                          shift and go to state 25
    Read                           shift and go to state 26
    If                             shift and go to state 27
    Term                           shift and go to state 31
    RepeatS                        shift and go to state 35
    Factor                         shift and go to state 41

state 171

    (31) Dcl -> int id [ num ] [ num . ]

    ]               shift and go to state 178


state 172

    (36) Attr -> id [ Exp ] [ Exp ] . = Exp
    (69) Factor -> id [ Exp ] [ Exp ] .

    =               shift and go to state 179
    *               reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    /               reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    %               reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    +               reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    -               reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    }               reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    id              reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    return          reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    print           reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    println         reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    prints          reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    for             reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    while           reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    read            reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    if              reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    repeat          reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    num             reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    (               reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    ;               reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    )               reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)


state 173

    (69) Factor -> id [ Exp ] [ Exp . ]
    (43) Exp -> Exp . + Term
    (44) Exp -> Exp . - Term

    ]               shift and go to state 180
    +               shift and go to state 45
    -               shift and go to state 46


state 174

    (22) Repeat -> RepeatS ( num ) { Insts } .

    }               reduce using rule 22 (Repeat -> RepeatS ( num ) { Insts } .)
    id              reduce using rule 22 (Repeat -> RepeatS ( num ) { Insts } .)
    return          reduce using rule 22 (Repeat -> RepeatS ( num ) { Insts } .)
    print           reduce using rule 22 (Repeat -> RepeatS ( num ) { Insts } .)
    println         reduce using rule 22 (Repeat -> RepeatS ( num ) { Insts } .)
    prints          reduce using rule 22 (Repeat -> RepeatS ( num ) { Insts } .)
    for             reduce using rule 22 (Repeat -> RepeatS ( num ) { Insts } .)
    while           reduce using rule 22 (Repeat -> RepeatS ( num ) { Insts } .)
    read            reduce using rule 22 (Repeat -> RepeatS ( num ) { Insts } .)
    if              reduce using rule 22 (Repeat -> RepeatS ( num ) { Insts } .)
    repeat          reduce using rule 22 (Repeat -> RepeatS ( num ) { Insts } .)
    num             reduce using rule 22 (Repeat -> RepeatS ( num ) { Insts } .)
    (               reduce using rule 22 (Repeat -> RepeatS ( num ) { Insts } .)
    ;               reduce using rule 22 (Repeat -> RepeatS ( num ) { Insts } .)
    )               reduce using rule 22 (Repeat -> RepeatS ( num ) { Insts } .)


state 175

    (24) For -> for ( Insts ; Cond ; Insts . ) { Insts }
    (9) Insts -> Insts . Inst
    (11) Inst -> . Attr
    (12) Inst -> . Return
    (13) Inst -> . Exp
    (14) Inst -> . Print
    (15) Inst -> . Println
    (16) Inst -> . Prints
    (17) Inst -> . Repeat
    (18) Inst -> . For
    (19) Inst -> . While
    (20) Inst -> . Read
    (21) Inst -> . If
    (34) Attr -> . id = Exp
    (35) Attr -> . id [ Exp ] = Exp
    (36) Attr -> . id [ Exp ] [ Exp ] = Exp
    (37) Return -> . return ( Exp )
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (27) Print -> . print ( Exp )
    (28) Println -> . println ( Exp )
    (29) Prints -> . prints ( string )
    (22) Repeat -> . RepeatS ( num ) { Insts }
    (24) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (25) While -> . while ( Cond ) { Insts }
    (26) Read -> . read ( id )
    (38) If -> . if ( Cond ) { Insts }
    (39) If -> . if ( Cond ) Inst
    (41) If -> . if ( Cond ) { Insts } else { Insts }
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (23) RepeatS -> . repeat
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    )               shift and go to state 181
    id              shift and go to state 28
    return          shift and go to state 29
    print           shift and go to state 32
    println         shift and go to state 33
    prints          shift and go to state 34
    for             shift and go to state 37
    while           shift and go to state 38
    read            shift and go to state 39
    if              shift and go to state 40
    repeat          shift and go to state 42
    num             shift and go to state 36
    (               shift and go to state 30

    Inst                           shift and go to state 16
    Attr                           shift and go to state 17
    Return                         shift and go to state 18
    Exp                            shift and go to state 19
    Print                          shift and go to state 20
    Println                        shift and go to state 21
    Prints                         shift and go to state 22
    Repeat                         shift and go to state 23
    For                            shift and go to state 24
    While                          shift and go to state 25
    Read                           shift and go to state 26
    If                             shift and go to state 27
    Term                           shift and go to state 31
    RepeatS                        shift and go to state 35
    Factor                         shift and go to state 41

state 176

    (25) While -> while ( Cond ) { Insts } .

    }               reduce using rule 25 (While -> while ( Cond ) { Insts } .)
    id              reduce using rule 25 (While -> while ( Cond ) { Insts } .)
    return          reduce using rule 25 (While -> while ( Cond ) { Insts } .)
    print           reduce using rule 25 (While -> while ( Cond ) { Insts } .)
    println         reduce using rule 25 (While -> while ( Cond ) { Insts } .)
    prints          reduce using rule 25 (While -> while ( Cond ) { Insts } .)
    for             reduce using rule 25 (While -> while ( Cond ) { Insts } .)
    while           reduce using rule 25 (While -> while ( Cond ) { Insts } .)
    read            reduce using rule 25 (While -> while ( Cond ) { Insts } .)
    if              reduce using rule 25 (While -> while ( Cond ) { Insts } .)
    repeat          reduce using rule 25 (While -> while ( Cond ) { Insts } .)
    num             reduce using rule 25 (While -> while ( Cond ) { Insts } .)
    (               reduce using rule 25 (While -> while ( Cond ) { Insts } .)
    ;               reduce using rule 25 (While -> while ( Cond ) { Insts } .)
    )               reduce using rule 25 (While -> while ( Cond ) { Insts } .)


state 177

    (38) If -> if ( Cond ) { Insts } .
    (41) If -> if ( Cond ) { Insts } . else { Insts }

    }               reduce using rule 38 (If -> if ( Cond ) { Insts } .)
    id              reduce using rule 38 (If -> if ( Cond ) { Insts } .)
    return          reduce using rule 38 (If -> if ( Cond ) { Insts } .)
    print           reduce using rule 38 (If -> if ( Cond ) { Insts } .)
    println         reduce using rule 38 (If -> if ( Cond ) { Insts } .)
    prints          reduce using rule 38 (If -> if ( Cond ) { Insts } .)
    for             reduce using rule 38 (If -> if ( Cond ) { Insts } .)
    while           reduce using rule 38 (If -> if ( Cond ) { Insts } .)
    read            reduce using rule 38 (If -> if ( Cond ) { Insts } .)
    if              reduce using rule 38 (If -> if ( Cond ) { Insts } .)
    repeat          reduce using rule 38 (If -> if ( Cond ) { Insts } .)
    num             reduce using rule 38 (If -> if ( Cond ) { Insts } .)
    (               reduce using rule 38 (If -> if ( Cond ) { Insts } .)
    ;               reduce using rule 38 (If -> if ( Cond ) { Insts } .)
    )               reduce using rule 38 (If -> if ( Cond ) { Insts } .)
    else            shift and go to state 182


state 178

    (31) Dcl -> int id [ num ] [ num ] .

    int             reduce using rule 31 (Dcl -> int id [ num ] [ num ] .)
    }               reduce using rule 31 (Dcl -> int id [ num ] [ num ] .)
    id              reduce using rule 31 (Dcl -> int id [ num ] [ num ] .)
    return          reduce using rule 31 (Dcl -> int id [ num ] [ num ] .)
    print           reduce using rule 31 (Dcl -> int id [ num ] [ num ] .)
    println         reduce using rule 31 (Dcl -> int id [ num ] [ num ] .)
    prints          reduce using rule 31 (Dcl -> int id [ num ] [ num ] .)
    for             reduce using rule 31 (Dcl -> int id [ num ] [ num ] .)
    while           reduce using rule 31 (Dcl -> int id [ num ] [ num ] .)
    read            reduce using rule 31 (Dcl -> int id [ num ] [ num ] .)
    if              reduce using rule 31 (Dcl -> int id [ num ] [ num ] .)
    repeat          reduce using rule 31 (Dcl -> int id [ num ] [ num ] .)
    num             reduce using rule 31 (Dcl -> int id [ num ] [ num ] .)
    (               reduce using rule 31 (Dcl -> int id [ num ] [ num ] .)


state 179

    (36) Attr -> id [ Exp ] [ Exp ] = . Exp
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    id              shift and go to state 69
    num             shift and go to state 36
    (               shift and go to state 30

    Exp                            shift and go to state 183
    Term                           shift and go to state 31
    Factor                         shift and go to state 41

state 180

    (69) Factor -> id [ Exp ] [ Exp ] .

    *               reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    /               reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    %               reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    )               reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    sup             reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    inf             reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    supeq           reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    infeq           reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    eq              reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    diff            reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    +               reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    -               reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    }               reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    id              reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    return          reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    print           reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    println         reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    prints          reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    for             reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    while           reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    read            reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    if              reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    repeat          reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    num             reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    (               reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    ;               reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    ]               reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    and             reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)
    or              reduce using rule 69 (Factor -> id [ Exp ] [ Exp ] .)


state 181

    (24) For -> for ( Insts ; Cond ; Insts ) . { Insts }

    {               shift and go to state 184


state 182

    (41) If -> if ( Cond ) { Insts } else . { Insts }

    {               shift and go to state 185


state 183

    (36) Attr -> id [ Exp ] [ Exp ] = Exp .
    (43) Exp -> Exp . + Term
    (44) Exp -> Exp . - Term

    }               reduce using rule 36 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    id              reduce using rule 36 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    return          reduce using rule 36 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    print           reduce using rule 36 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    println         reduce using rule 36 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    prints          reduce using rule 36 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    for             reduce using rule 36 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    while           reduce using rule 36 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    read            reduce using rule 36 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    if              reduce using rule 36 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    repeat          reduce using rule 36 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    num             reduce using rule 36 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    (               reduce using rule 36 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    ;               reduce using rule 36 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    )               reduce using rule 36 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    +               shift and go to state 45
    -               shift and go to state 46


state 184

    (24) For -> for ( Insts ; Cond ; Insts ) { . Insts }
    (9) Insts -> . Insts Inst
    (10) Insts -> .

    }               reduce using rule 10 (Insts -> .)
    id              reduce using rule 10 (Insts -> .)
    return          reduce using rule 10 (Insts -> .)
    print           reduce using rule 10 (Insts -> .)
    println         reduce using rule 10 (Insts -> .)
    prints          reduce using rule 10 (Insts -> .)
    for             reduce using rule 10 (Insts -> .)
    while           reduce using rule 10 (Insts -> .)
    read            reduce using rule 10 (Insts -> .)
    if              reduce using rule 10 (Insts -> .)
    repeat          reduce using rule 10 (Insts -> .)
    num             reduce using rule 10 (Insts -> .)
    (               reduce using rule 10 (Insts -> .)

    Insts                          shift and go to state 186

state 185

    (41) If -> if ( Cond ) { Insts } else { . Insts }
    (9) Insts -> . Insts Inst
    (10) Insts -> .

    }               reduce using rule 10 (Insts -> .)
    id              reduce using rule 10 (Insts -> .)
    return          reduce using rule 10 (Insts -> .)
    print           reduce using rule 10 (Insts -> .)
    println         reduce using rule 10 (Insts -> .)
    prints          reduce using rule 10 (Insts -> .)
    for             reduce using rule 10 (Insts -> .)
    while           reduce using rule 10 (Insts -> .)
    read            reduce using rule 10 (Insts -> .)
    if              reduce using rule 10 (Insts -> .)
    repeat          reduce using rule 10 (Insts -> .)
    num             reduce using rule 10 (Insts -> .)
    (               reduce using rule 10 (Insts -> .)

    Insts                          shift and go to state 187

state 186

    (24) For -> for ( Insts ; Cond ; Insts ) { Insts . }
    (9) Insts -> Insts . Inst
    (11) Inst -> . Attr
    (12) Inst -> . Return
    (13) Inst -> . Exp
    (14) Inst -> . Print
    (15) Inst -> . Println
    (16) Inst -> . Prints
    (17) Inst -> . Repeat
    (18) Inst -> . For
    (19) Inst -> . While
    (20) Inst -> . Read
    (21) Inst -> . If
    (34) Attr -> . id = Exp
    (35) Attr -> . id [ Exp ] = Exp
    (36) Attr -> . id [ Exp ] [ Exp ] = Exp
    (37) Return -> . return ( Exp )
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (27) Print -> . print ( Exp )
    (28) Println -> . println ( Exp )
    (29) Prints -> . prints ( string )
    (22) Repeat -> . RepeatS ( num ) { Insts }
    (24) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (25) While -> . while ( Cond ) { Insts }
    (26) Read -> . read ( id )
    (38) If -> . if ( Cond ) { Insts }
    (39) If -> . if ( Cond ) Inst
    (41) If -> . if ( Cond ) { Insts } else { Insts }
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (23) RepeatS -> . repeat
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    }               shift and go to state 188
    id              shift and go to state 28
    return          shift and go to state 29
    print           shift and go to state 32
    println         shift and go to state 33
    prints          shift and go to state 34
    for             shift and go to state 37
    while           shift and go to state 38
    read            shift and go to state 39
    if              shift and go to state 40
    repeat          shift and go to state 42
    num             shift and go to state 36
    (               shift and go to state 30

    Inst                           shift and go to state 16
    Attr                           shift and go to state 17
    Return                         shift and go to state 18
    Exp                            shift and go to state 19
    Print                          shift and go to state 20
    Println                        shift and go to state 21
    Prints                         shift and go to state 22
    Repeat                         shift and go to state 23
    For                            shift and go to state 24
    While                          shift and go to state 25
    Read                           shift and go to state 26
    If                             shift and go to state 27
    Term                           shift and go to state 31
    RepeatS                        shift and go to state 35
    Factor                         shift and go to state 41

state 187

    (41) If -> if ( Cond ) { Insts } else { Insts . }
    (9) Insts -> Insts . Inst
    (11) Inst -> . Attr
    (12) Inst -> . Return
    (13) Inst -> . Exp
    (14) Inst -> . Print
    (15) Inst -> . Println
    (16) Inst -> . Prints
    (17) Inst -> . Repeat
    (18) Inst -> . For
    (19) Inst -> . While
    (20) Inst -> . Read
    (21) Inst -> . If
    (34) Attr -> . id = Exp
    (35) Attr -> . id [ Exp ] = Exp
    (36) Attr -> . id [ Exp ] [ Exp ] = Exp
    (37) Return -> . return ( Exp )
    (43) Exp -> . Exp + Term
    (44) Exp -> . Exp - Term
    (45) Exp -> . id addeq Term
    (46) Exp -> . id subeq Term
    (47) Exp -> . id addeql Term
    (48) Exp -> . id subeql Term
    (49) Exp -> . Term
    (27) Print -> . print ( Exp )
    (28) Println -> . println ( Exp )
    (29) Prints -> . prints ( string )
    (22) Repeat -> . RepeatS ( num ) { Insts }
    (24) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (25) While -> . while ( Cond ) { Insts }
    (26) Read -> . read ( id )
    (38) If -> . if ( Cond ) { Insts }
    (39) If -> . if ( Cond ) Inst
    (41) If -> . if ( Cond ) { Insts } else { Insts }
    (50) Term -> . Term * Factor
    (51) Term -> . Term / Factor
    (52) Term -> . Term % Factor
    (53) Term -> . id muleq Factor
    (54) Term -> . id diveq Factor
    (55) Term -> . id modeq Factor
    (56) Term -> . id muleql Factor
    (57) Term -> . id diveql Factor
    (58) Term -> . id modeql Factor
    (59) Term -> . Factor
    (23) RepeatS -> . repeat
    (60) Factor -> . id plus
    (61) Factor -> . id plusl
    (62) Factor -> . id minus
    (63) Factor -> . id minusl
    (64) Factor -> . id
    (65) Factor -> . num
    (66) Factor -> . id ( )
    (67) Factor -> . ( Cond )
    (68) Factor -> . id [ Exp ]
    (69) Factor -> . id [ Exp ] [ Exp ]
    (70) Factor -> . ( Exp )

    }               shift and go to state 189
    id              shift and go to state 28
    return          shift and go to state 29
    print           shift and go to state 32
    println         shift and go to state 33
    prints          shift and go to state 34
    for             shift and go to state 37
    while           shift and go to state 38
    read            shift and go to state 39
    if              shift and go to state 40
    repeat          shift and go to state 42
    num             shift and go to state 36
    (               shift and go to state 30

    Inst                           shift and go to state 16
    Attr                           shift and go to state 17
    Return                         shift and go to state 18
    Exp                            shift and go to state 19
    Print                          shift and go to state 20
    Println                        shift and go to state 21
    Prints                         shift and go to state 22
    Repeat                         shift and go to state 23
    For                            shift and go to state 24
    While                          shift and go to state 25
    Read                           shift and go to state 26
    If                             shift and go to state 27
    Term                           shift and go to state 31
    RepeatS                        shift and go to state 35
    Factor                         shift and go to state 41

state 188

    (24) For -> for ( Insts ; Cond ; Insts ) { Insts } .

    }               reduce using rule 24 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    id              reduce using rule 24 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    return          reduce using rule 24 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    print           reduce using rule 24 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    println         reduce using rule 24 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    prints          reduce using rule 24 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    for             reduce using rule 24 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    while           reduce using rule 24 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    read            reduce using rule 24 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    if              reduce using rule 24 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    repeat          reduce using rule 24 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    num             reduce using rule 24 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    (               reduce using rule 24 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    ;               reduce using rule 24 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    )               reduce using rule 24 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)


state 189

    (41) If -> if ( Cond ) { Insts } else { Insts } .

    }               reduce using rule 41 (If -> if ( Cond ) { Insts } else { Insts } .)
    id              reduce using rule 41 (If -> if ( Cond ) { Insts } else { Insts } .)
    return          reduce using rule 41 (If -> if ( Cond ) { Insts } else { Insts } .)
    print           reduce using rule 41 (If -> if ( Cond ) { Insts } else { Insts } .)
    println         reduce using rule 41 (If -> if ( Cond ) { Insts } else { Insts } .)
    prints          reduce using rule 41 (If -> if ( Cond ) { Insts } else { Insts } .)
    for             reduce using rule 41 (If -> if ( Cond ) { Insts } else { Insts } .)
    while           reduce using rule 41 (If -> if ( Cond ) { Insts } else { Insts } .)
    read            reduce using rule 41 (If -> if ( Cond ) { Insts } else { Insts } .)
    if              reduce using rule 41 (If -> if ( Cond ) { Insts } else { Insts } .)
    repeat          reduce using rule 41 (If -> if ( Cond ) { Insts } else { Insts } .)
    num             reduce using rule 41 (If -> if ( Cond ) { Insts } else { Insts } .)
    (               reduce using rule 41 (If -> if ( Cond ) { Insts } else { Insts } .)
    ;               reduce using rule 41 (If -> if ( Cond ) { Insts } else { Insts } .)
    )               reduce using rule 41 (If -> if ( Cond ) { Insts } else { Insts } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ( in state 28 resolved as shift
WARNING: shift/reduce conflict for ( in state 69 resolved as shift
WARNING: shift/reduce conflict for ( in state 85 resolved as shift
WARNING: shift/reduce conflict for ( in state 93 resolved as shift
WARNING: shift/reduce conflict for and in state 133 resolved as shift
WARNING: shift/reduce conflict for or in state 133 resolved as shift
WARNING: shift/reduce conflict for and in state 134 resolved as shift
WARNING: shift/reduce conflict for or in state 134 resolved as shift
WARNING: shift/reduce conflict for ) in state 153 resolved as shift
WARNING: shift/reduce conflict for and in state 153 resolved as shift
WARNING: shift/reduce conflict for or in state 153 resolved as shift
WARNING: shift/reduce conflict for ) in state 154 resolved as shift
WARNING: shift/reduce conflict for and in state 154 resolved as shift
WARNING: shift/reduce conflict for or in state 154 resolved as shift
