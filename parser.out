Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    vars

Grammar

Rule 0     S' -> Prog
Rule 1     Prog -> GlobalBlc MainBlc DefBlcs
Rule 2     DefBlcs -> DefBlcs DefBlc
Rule 3     DefBlcs -> <empty>
Rule 4     DefBlc -> id { VarBlc Insts }
Rule 5     VarBlc -> Dcls
Rule 6     GlobalBlc -> global { DclGs }
Rule 7     GlobalBlc -> <empty>
Rule 8     DclGs -> DclGs DclGlobal
Rule 9     DclGs -> <empty>
Rule 10    Dcls -> Dcls Dcl
Rule 11    Dcls -> <empty>
Rule 12    MainBlc -> main { VarBlc Insts }
Rule 13    Insts -> Insts Inst
Rule 14    Insts -> <empty>
Rule 15    Inst -> Attr
Rule 16    Inst -> Return
Rule 17    Inst -> Exp
Rule 18    Inst -> Print
Rule 19    Inst -> Println
Rule 20    Inst -> Prints
Rule 21    Inst -> Repeat
Rule 22    Inst -> For
Rule 23    Inst -> While
Rule 24    Inst -> Read
Rule 25    Inst -> If
Rule 26    Repeat -> RepeatS ( num ) { Insts }
Rule 27    RepeatS -> repeat
Rule 28    For -> for ( Insts ; Cond ; Insts ) { Insts }
Rule 29    While -> while ( Cond ) { Insts }
Rule 30    Read -> read ( id )
Rule 31    Print -> print ( Exp )
Rule 32    Println -> println ( Exp )
Rule 33    Prints -> prints ( string )
Rule 34    Dcl -> int id [ num ]
Rule 35    Dcl -> int id [ num ] [ num ]
Rule 36    Dcl -> int id
Rule 37    Dcl -> int id = num
Rule 38    DclGlobal -> int id [ num ]
Rule 39    DclGlobal -> int id [ num ] [ num ]
Rule 40    DclGlobal -> int id
Rule 41    DclGlobal -> int id = num
Rule 42    Attr -> id = Exp
Rule 43    Attr -> id [ Exp ] = Exp
Rule 44    Attr -> id [ Exp ] [ Exp ] = Exp
Rule 45    Attr -> gid = Exp
Rule 46    Attr -> gid [ Exp ] = Exp
Rule 47    Attr -> gid [ Exp ] [ Exp ] = Exp
Rule 48    Return -> return ( Exp )
Rule 49    If -> if ( Cond ) { Insts }
Rule 50    If -> if ( Cond ) Inst
Rule 51    IfStart -> if ( Cond )
Rule 52    If -> if ( Cond ) { Insts } else { Insts }
Rule 53    ElseStart -> else
Rule 54    Exp -> Exp + Term
Rule 55    Exp -> Exp - Term
Rule 56    Exp -> id addeq Term
Rule 57    Exp -> id subeq Term
Rule 58    Exp -> id addeql Term
Rule 59    Exp -> id subeql Term
Rule 60    Exp -> Term
Rule 61    Term -> Term * Factor
Rule 62    Term -> Term / Factor
Rule 63    Term -> Term % Factor
Rule 64    Term -> id muleq Factor
Rule 65    Term -> id diveq Factor
Rule 66    Term -> id modeq Factor
Rule 67    Term -> id muleql Factor
Rule 68    Term -> id diveql Factor
Rule 69    Term -> id modeql Factor
Rule 70    Term -> Factor
Rule 71    Factor -> id plus
Rule 72    Factor -> id plusl
Rule 73    Factor -> id minus
Rule 74    Factor -> id minusl
Rule 75    Factor -> id
Rule 76    Factor -> gid
Rule 77    Factor -> num
Rule 78    Factor -> id ( )
Rule 79    Factor -> ( Cond )
Rule 80    Factor -> id [ Exp ]
Rule 81    Factor -> id [ Exp ] [ Exp ]
Rule 82    Factor -> gid [ Exp ]
Rule 83    Factor -> gid [ Exp ] [ Exp ]
Rule 84    Factor -> ( Exp )
Rule 85    Id -> id
Rule 86    Id -> id [ Exp ]
Rule 87    Id -> id [ Exp ] [ Exp ]
Rule 88    Cond -> Cond and Cond
Rule 89    Cond -> Cond or Cond
Rule 90    Cond -> ( Cond and Cond )
Rule 91    Cond -> ( Cond or Cond )
Rule 92    Cond -> Exp sup Exp
Rule 93    Cond -> Exp inf Exp
Rule 94    Cond -> Exp supeq Exp
Rule 95    Cond -> Exp infeq Exp
Rule 96    Cond -> not Exp
Rule 97    Cond -> Exp eq Exp
Rule 98    Cond -> Exp diff Exp

Terminals, with rules where they appear

%                    : 63
(                    : 26 28 29 30 31 32 33 48 49 50 51 52 78 79 84 90 91
)                    : 26 28 29 30 31 32 33 48 49 50 51 52 78 79 84 90 91
*                    : 61
+                    : 54
-                    : 55
/                    : 62
;                    : 28 28
=                    : 37 41 42 43 44 45 46 47
[                    : 34 35 35 38 39 39 43 44 44 46 47 47 80 81 81 82 83 83 86 87 87
]                    : 34 35 35 38 39 39 43 44 44 46 47 47 80 81 81 82 83 83 86 87 87
addeq                : 56
addeql               : 58
and                  : 88 90
diff                 : 98
diveq                : 65
diveql               : 68
else                 : 52 53
eq                   : 97
error                : 
for                  : 28
gid                  : 45 46 47 76 82 83
global               : 6
id                   : 4 30 34 35 36 37 38 39 40 41 42 43 44 56 57 58 59 64 65 66 67 68 69 71 72 73 74 75 78 80 81 85 86 87
if                   : 49 50 51 52
inf                  : 93
infeq                : 95
int                  : 34 35 36 37 38 39 40 41
main                 : 12
minus                : 73
minusl               : 74
modeq                : 66
modeql               : 69
muleq                : 64
muleql               : 67
not                  : 96
num                  : 26 34 35 35 37 38 39 39 41 77
or                   : 89 91
plus                 : 71
plusl                : 72
print                : 31
println              : 32
prints               : 33
read                 : 30
repeat               : 27
return               : 48
string               : 33
subeq                : 57
subeql               : 59
sup                  : 92
supeq                : 94
vars                 : 
while                : 29
{                    : 4 6 12 26 28 29 49 52 52
}                    : 4 6 12 26 28 29 49 52 52

Nonterminals, with rules where they appear

Attr                 : 15
Cond                 : 28 29 49 50 51 52 79 88 88 89 89 90 90 91 91
Dcl                  : 10
DclGlobal            : 8
DclGs                : 6 8
Dcls                 : 5 10
DefBlc               : 2
DefBlcs              : 1 2
ElseStart            : 
Exp                  : 17 31 32 42 43 43 44 44 44 45 46 46 47 47 47 48 54 55 80 81 81 82 83 83 84 86 87 87 92 92 93 93 94 94 95 95 96 97 97 98 98
Factor               : 61 62 63 64 65 66 67 68 69 70
For                  : 22
GlobalBlc            : 1
Id                   : 
If                   : 25
IfStart              : 
Inst                 : 13 50
Insts                : 4 12 13 26 28 28 28 29 49 52 52
MainBlc              : 1
Print                : 18
Println              : 19
Prints               : 20
Prog                 : 0
Read                 : 24
Repeat               : 21
RepeatS              : 26
Return               : 16
Term                 : 54 55 56 57 58 59 60 61 62 63
VarBlc               : 4 12
While                : 23

Parsing method: LALR

state 0

    (0) S' -> . Prog
    (1) Prog -> . GlobalBlc MainBlc DefBlcs
    (6) GlobalBlc -> . global { DclGs }
    (7) GlobalBlc -> .

    global          shift and go to state 3
    main            reduce using rule 7 (GlobalBlc -> .)

    Prog                           shift and go to state 1
    GlobalBlc                      shift and go to state 2

state 1

    (0) S' -> Prog .



state 2

    (1) Prog -> GlobalBlc . MainBlc DefBlcs
    (12) MainBlc -> . main { VarBlc Insts }

    main            shift and go to state 5

    MainBlc                        shift and go to state 4

state 3

    (6) GlobalBlc -> global . { DclGs }

    {               shift and go to state 6


state 4

    (1) Prog -> GlobalBlc MainBlc . DefBlcs
    (2) DefBlcs -> . DefBlcs DefBlc
    (3) DefBlcs -> .

    id              reduce using rule 3 (DefBlcs -> .)
    $end            reduce using rule 3 (DefBlcs -> .)

    DefBlcs                        shift and go to state 7

state 5

    (12) MainBlc -> main . { VarBlc Insts }

    {               shift and go to state 8


state 6

    (6) GlobalBlc -> global { . DclGs }
    (8) DclGs -> . DclGs DclGlobal
    (9) DclGs -> .

    }               reduce using rule 9 (DclGs -> .)
    int             reduce using rule 9 (DclGs -> .)

    DclGs                          shift and go to state 9

state 7

    (1) Prog -> GlobalBlc MainBlc DefBlcs .
    (2) DefBlcs -> DefBlcs . DefBlc
    (4) DefBlc -> . id { VarBlc Insts }

    $end            reduce using rule 1 (Prog -> GlobalBlc MainBlc DefBlcs .)
    id              shift and go to state 11

    DefBlc                         shift and go to state 10

state 8

    (12) MainBlc -> main { . VarBlc Insts }
    (5) VarBlc -> . Dcls
    (10) Dcls -> . Dcls Dcl
    (11) Dcls -> .

    int             reduce using rule 11 (Dcls -> .)
    }               reduce using rule 11 (Dcls -> .)
    id              reduce using rule 11 (Dcls -> .)
    gid             reduce using rule 11 (Dcls -> .)
    return          reduce using rule 11 (Dcls -> .)
    print           reduce using rule 11 (Dcls -> .)
    println         reduce using rule 11 (Dcls -> .)
    prints          reduce using rule 11 (Dcls -> .)
    for             reduce using rule 11 (Dcls -> .)
    while           reduce using rule 11 (Dcls -> .)
    read            reduce using rule 11 (Dcls -> .)
    if              reduce using rule 11 (Dcls -> .)
    repeat          reduce using rule 11 (Dcls -> .)
    num             reduce using rule 11 (Dcls -> .)
    (               reduce using rule 11 (Dcls -> .)

    VarBlc                         shift and go to state 12
    Dcls                           shift and go to state 13

state 9

    (6) GlobalBlc -> global { DclGs . }
    (8) DclGs -> DclGs . DclGlobal
    (38) DclGlobal -> . int id [ num ]
    (39) DclGlobal -> . int id [ num ] [ num ]
    (40) DclGlobal -> . int id
    (41) DclGlobal -> . int id = num

    }               shift and go to state 14
    int             shift and go to state 16

    DclGlobal                      shift and go to state 15

state 10

    (2) DefBlcs -> DefBlcs DefBlc .

    id              reduce using rule 2 (DefBlcs -> DefBlcs DefBlc .)
    $end            reduce using rule 2 (DefBlcs -> DefBlcs DefBlc .)


state 11

    (4) DefBlc -> id . { VarBlc Insts }

    {               shift and go to state 17


state 12

    (12) MainBlc -> main { VarBlc . Insts }
    (13) Insts -> . Insts Inst
    (14) Insts -> .

    }               reduce using rule 14 (Insts -> .)
    id              reduce using rule 14 (Insts -> .)
    gid             reduce using rule 14 (Insts -> .)
    return          reduce using rule 14 (Insts -> .)
    print           reduce using rule 14 (Insts -> .)
    println         reduce using rule 14 (Insts -> .)
    prints          reduce using rule 14 (Insts -> .)
    for             reduce using rule 14 (Insts -> .)
    while           reduce using rule 14 (Insts -> .)
    read            reduce using rule 14 (Insts -> .)
    if              reduce using rule 14 (Insts -> .)
    repeat          reduce using rule 14 (Insts -> .)
    num             reduce using rule 14 (Insts -> .)
    (               reduce using rule 14 (Insts -> .)

    Insts                          shift and go to state 18

state 13

    (5) VarBlc -> Dcls .
    (10) Dcls -> Dcls . Dcl
    (34) Dcl -> . int id [ num ]
    (35) Dcl -> . int id [ num ] [ num ]
    (36) Dcl -> . int id
    (37) Dcl -> . int id = num

    }               reduce using rule 5 (VarBlc -> Dcls .)
    id              reduce using rule 5 (VarBlc -> Dcls .)
    gid             reduce using rule 5 (VarBlc -> Dcls .)
    return          reduce using rule 5 (VarBlc -> Dcls .)
    print           reduce using rule 5 (VarBlc -> Dcls .)
    println         reduce using rule 5 (VarBlc -> Dcls .)
    prints          reduce using rule 5 (VarBlc -> Dcls .)
    for             reduce using rule 5 (VarBlc -> Dcls .)
    while           reduce using rule 5 (VarBlc -> Dcls .)
    read            reduce using rule 5 (VarBlc -> Dcls .)
    if              reduce using rule 5 (VarBlc -> Dcls .)
    repeat          reduce using rule 5 (VarBlc -> Dcls .)
    num             reduce using rule 5 (VarBlc -> Dcls .)
    (               reduce using rule 5 (VarBlc -> Dcls .)
    int             shift and go to state 20

    Dcl                            shift and go to state 19

state 14

    (6) GlobalBlc -> global { DclGs } .

    main            reduce using rule 6 (GlobalBlc -> global { DclGs } .)


state 15

    (8) DclGs -> DclGs DclGlobal .

    }               reduce using rule 8 (DclGs -> DclGs DclGlobal .)
    int             reduce using rule 8 (DclGs -> DclGs DclGlobal .)


state 16

    (38) DclGlobal -> int . id [ num ]
    (39) DclGlobal -> int . id [ num ] [ num ]
    (40) DclGlobal -> int . id
    (41) DclGlobal -> int . id = num

    id              shift and go to state 21


state 17

    (4) DefBlc -> id { . VarBlc Insts }
    (5) VarBlc -> . Dcls
    (10) Dcls -> . Dcls Dcl
    (11) Dcls -> .

    int             reduce using rule 11 (Dcls -> .)
    }               reduce using rule 11 (Dcls -> .)
    id              reduce using rule 11 (Dcls -> .)
    gid             reduce using rule 11 (Dcls -> .)
    return          reduce using rule 11 (Dcls -> .)
    print           reduce using rule 11 (Dcls -> .)
    println         reduce using rule 11 (Dcls -> .)
    prints          reduce using rule 11 (Dcls -> .)
    for             reduce using rule 11 (Dcls -> .)
    while           reduce using rule 11 (Dcls -> .)
    read            reduce using rule 11 (Dcls -> .)
    if              reduce using rule 11 (Dcls -> .)
    repeat          reduce using rule 11 (Dcls -> .)
    num             reduce using rule 11 (Dcls -> .)
    (               reduce using rule 11 (Dcls -> .)

    VarBlc                         shift and go to state 22
    Dcls                           shift and go to state 13

state 18

    (12) MainBlc -> main { VarBlc Insts . }
    (13) Insts -> Insts . Inst
    (15) Inst -> . Attr
    (16) Inst -> . Return
    (17) Inst -> . Exp
    (18) Inst -> . Print
    (19) Inst -> . Println
    (20) Inst -> . Prints
    (21) Inst -> . Repeat
    (22) Inst -> . For
    (23) Inst -> . While
    (24) Inst -> . Read
    (25) Inst -> . If
    (42) Attr -> . id = Exp
    (43) Attr -> . id [ Exp ] = Exp
    (44) Attr -> . id [ Exp ] [ Exp ] = Exp
    (45) Attr -> . gid = Exp
    (46) Attr -> . gid [ Exp ] = Exp
    (47) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (48) Return -> . return ( Exp )
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (31) Print -> . print ( Exp )
    (32) Println -> . println ( Exp )
    (33) Prints -> . prints ( string )
    (26) Repeat -> . RepeatS ( num ) { Insts }
    (28) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (29) While -> . while ( Cond ) { Insts }
    (30) Read -> . read ( id )
    (49) If -> . if ( Cond ) { Insts }
    (50) If -> . if ( Cond ) Inst
    (52) If -> . if ( Cond ) { Insts } else { Insts }
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (27) RepeatS -> . repeat
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    }               shift and go to state 23
    id              shift and go to state 36
    gid             shift and go to state 37
    return          shift and go to state 38
    print           shift and go to state 41
    println         shift and go to state 42
    prints          shift and go to state 43
    for             shift and go to state 46
    while           shift and go to state 47
    read            shift and go to state 48
    if              shift and go to state 49
    repeat          shift and go to state 51
    num             shift and go to state 45
    (               shift and go to state 39

    Inst                           shift and go to state 24
    Attr                           shift and go to state 25
    Return                         shift and go to state 26
    Exp                            shift and go to state 27
    Print                          shift and go to state 28
    Println                        shift and go to state 29
    Prints                         shift and go to state 30
    Repeat                         shift and go to state 31
    For                            shift and go to state 32
    While                          shift and go to state 33
    Read                           shift and go to state 34
    If                             shift and go to state 35
    Term                           shift and go to state 40
    RepeatS                        shift and go to state 44
    Factor                         shift and go to state 50

state 19

    (10) Dcls -> Dcls Dcl .

    int             reduce using rule 10 (Dcls -> Dcls Dcl .)
    }               reduce using rule 10 (Dcls -> Dcls Dcl .)
    id              reduce using rule 10 (Dcls -> Dcls Dcl .)
    gid             reduce using rule 10 (Dcls -> Dcls Dcl .)
    return          reduce using rule 10 (Dcls -> Dcls Dcl .)
    print           reduce using rule 10 (Dcls -> Dcls Dcl .)
    println         reduce using rule 10 (Dcls -> Dcls Dcl .)
    prints          reduce using rule 10 (Dcls -> Dcls Dcl .)
    for             reduce using rule 10 (Dcls -> Dcls Dcl .)
    while           reduce using rule 10 (Dcls -> Dcls Dcl .)
    read            reduce using rule 10 (Dcls -> Dcls Dcl .)
    if              reduce using rule 10 (Dcls -> Dcls Dcl .)
    repeat          reduce using rule 10 (Dcls -> Dcls Dcl .)
    num             reduce using rule 10 (Dcls -> Dcls Dcl .)
    (               reduce using rule 10 (Dcls -> Dcls Dcl .)


state 20

    (34) Dcl -> int . id [ num ]
    (35) Dcl -> int . id [ num ] [ num ]
    (36) Dcl -> int . id
    (37) Dcl -> int . id = num

    id              shift and go to state 52


state 21

    (38) DclGlobal -> int id . [ num ]
    (39) DclGlobal -> int id . [ num ] [ num ]
    (40) DclGlobal -> int id .
    (41) DclGlobal -> int id . = num

    [               shift and go to state 53
    }               reduce using rule 40 (DclGlobal -> int id .)
    int             reduce using rule 40 (DclGlobal -> int id .)
    =               shift and go to state 54


state 22

    (4) DefBlc -> id { VarBlc . Insts }
    (13) Insts -> . Insts Inst
    (14) Insts -> .

    }               reduce using rule 14 (Insts -> .)
    id              reduce using rule 14 (Insts -> .)
    gid             reduce using rule 14 (Insts -> .)
    return          reduce using rule 14 (Insts -> .)
    print           reduce using rule 14 (Insts -> .)
    println         reduce using rule 14 (Insts -> .)
    prints          reduce using rule 14 (Insts -> .)
    for             reduce using rule 14 (Insts -> .)
    while           reduce using rule 14 (Insts -> .)
    read            reduce using rule 14 (Insts -> .)
    if              reduce using rule 14 (Insts -> .)
    repeat          reduce using rule 14 (Insts -> .)
    num             reduce using rule 14 (Insts -> .)
    (               reduce using rule 14 (Insts -> .)

    Insts                          shift and go to state 55

state 23

    (12) MainBlc -> main { VarBlc Insts } .

    id              reduce using rule 12 (MainBlc -> main { VarBlc Insts } .)
    $end            reduce using rule 12 (MainBlc -> main { VarBlc Insts } .)


state 24

    (13) Insts -> Insts Inst .

    }               reduce using rule 13 (Insts -> Insts Inst .)
    id              reduce using rule 13 (Insts -> Insts Inst .)
    gid             reduce using rule 13 (Insts -> Insts Inst .)
    return          reduce using rule 13 (Insts -> Insts Inst .)
    print           reduce using rule 13 (Insts -> Insts Inst .)
    println         reduce using rule 13 (Insts -> Insts Inst .)
    prints          reduce using rule 13 (Insts -> Insts Inst .)
    for             reduce using rule 13 (Insts -> Insts Inst .)
    while           reduce using rule 13 (Insts -> Insts Inst .)
    read            reduce using rule 13 (Insts -> Insts Inst .)
    if              reduce using rule 13 (Insts -> Insts Inst .)
    repeat          reduce using rule 13 (Insts -> Insts Inst .)
    num             reduce using rule 13 (Insts -> Insts Inst .)
    (               reduce using rule 13 (Insts -> Insts Inst .)
    ;               reduce using rule 13 (Insts -> Insts Inst .)
    )               reduce using rule 13 (Insts -> Insts Inst .)


state 25

    (15) Inst -> Attr .

    }               reduce using rule 15 (Inst -> Attr .)
    id              reduce using rule 15 (Inst -> Attr .)
    gid             reduce using rule 15 (Inst -> Attr .)
    return          reduce using rule 15 (Inst -> Attr .)
    print           reduce using rule 15 (Inst -> Attr .)
    println         reduce using rule 15 (Inst -> Attr .)
    prints          reduce using rule 15 (Inst -> Attr .)
    for             reduce using rule 15 (Inst -> Attr .)
    while           reduce using rule 15 (Inst -> Attr .)
    read            reduce using rule 15 (Inst -> Attr .)
    if              reduce using rule 15 (Inst -> Attr .)
    repeat          reduce using rule 15 (Inst -> Attr .)
    num             reduce using rule 15 (Inst -> Attr .)
    (               reduce using rule 15 (Inst -> Attr .)
    ;               reduce using rule 15 (Inst -> Attr .)
    )               reduce using rule 15 (Inst -> Attr .)


state 26

    (16) Inst -> Return .

    }               reduce using rule 16 (Inst -> Return .)
    id              reduce using rule 16 (Inst -> Return .)
    gid             reduce using rule 16 (Inst -> Return .)
    return          reduce using rule 16 (Inst -> Return .)
    print           reduce using rule 16 (Inst -> Return .)
    println         reduce using rule 16 (Inst -> Return .)
    prints          reduce using rule 16 (Inst -> Return .)
    for             reduce using rule 16 (Inst -> Return .)
    while           reduce using rule 16 (Inst -> Return .)
    read            reduce using rule 16 (Inst -> Return .)
    if              reduce using rule 16 (Inst -> Return .)
    repeat          reduce using rule 16 (Inst -> Return .)
    num             reduce using rule 16 (Inst -> Return .)
    (               reduce using rule 16 (Inst -> Return .)
    ;               reduce using rule 16 (Inst -> Return .)
    )               reduce using rule 16 (Inst -> Return .)


state 27

    (17) Inst -> Exp .
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    }               reduce using rule 17 (Inst -> Exp .)
    id              reduce using rule 17 (Inst -> Exp .)
    gid             reduce using rule 17 (Inst -> Exp .)
    return          reduce using rule 17 (Inst -> Exp .)
    print           reduce using rule 17 (Inst -> Exp .)
    println         reduce using rule 17 (Inst -> Exp .)
    prints          reduce using rule 17 (Inst -> Exp .)
    for             reduce using rule 17 (Inst -> Exp .)
    while           reduce using rule 17 (Inst -> Exp .)
    read            reduce using rule 17 (Inst -> Exp .)
    if              reduce using rule 17 (Inst -> Exp .)
    repeat          reduce using rule 17 (Inst -> Exp .)
    num             reduce using rule 17 (Inst -> Exp .)
    (               reduce using rule 17 (Inst -> Exp .)
    ;               reduce using rule 17 (Inst -> Exp .)
    )               reduce using rule 17 (Inst -> Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 28

    (18) Inst -> Print .

    }               reduce using rule 18 (Inst -> Print .)
    id              reduce using rule 18 (Inst -> Print .)
    gid             reduce using rule 18 (Inst -> Print .)
    return          reduce using rule 18 (Inst -> Print .)
    print           reduce using rule 18 (Inst -> Print .)
    println         reduce using rule 18 (Inst -> Print .)
    prints          reduce using rule 18 (Inst -> Print .)
    for             reduce using rule 18 (Inst -> Print .)
    while           reduce using rule 18 (Inst -> Print .)
    read            reduce using rule 18 (Inst -> Print .)
    if              reduce using rule 18 (Inst -> Print .)
    repeat          reduce using rule 18 (Inst -> Print .)
    num             reduce using rule 18 (Inst -> Print .)
    (               reduce using rule 18 (Inst -> Print .)
    ;               reduce using rule 18 (Inst -> Print .)
    )               reduce using rule 18 (Inst -> Print .)


state 29

    (19) Inst -> Println .

    }               reduce using rule 19 (Inst -> Println .)
    id              reduce using rule 19 (Inst -> Println .)
    gid             reduce using rule 19 (Inst -> Println .)
    return          reduce using rule 19 (Inst -> Println .)
    print           reduce using rule 19 (Inst -> Println .)
    println         reduce using rule 19 (Inst -> Println .)
    prints          reduce using rule 19 (Inst -> Println .)
    for             reduce using rule 19 (Inst -> Println .)
    while           reduce using rule 19 (Inst -> Println .)
    read            reduce using rule 19 (Inst -> Println .)
    if              reduce using rule 19 (Inst -> Println .)
    repeat          reduce using rule 19 (Inst -> Println .)
    num             reduce using rule 19 (Inst -> Println .)
    (               reduce using rule 19 (Inst -> Println .)
    ;               reduce using rule 19 (Inst -> Println .)
    )               reduce using rule 19 (Inst -> Println .)


state 30

    (20) Inst -> Prints .

    }               reduce using rule 20 (Inst -> Prints .)
    id              reduce using rule 20 (Inst -> Prints .)
    gid             reduce using rule 20 (Inst -> Prints .)
    return          reduce using rule 20 (Inst -> Prints .)
    print           reduce using rule 20 (Inst -> Prints .)
    println         reduce using rule 20 (Inst -> Prints .)
    prints          reduce using rule 20 (Inst -> Prints .)
    for             reduce using rule 20 (Inst -> Prints .)
    while           reduce using rule 20 (Inst -> Prints .)
    read            reduce using rule 20 (Inst -> Prints .)
    if              reduce using rule 20 (Inst -> Prints .)
    repeat          reduce using rule 20 (Inst -> Prints .)
    num             reduce using rule 20 (Inst -> Prints .)
    (               reduce using rule 20 (Inst -> Prints .)
    ;               reduce using rule 20 (Inst -> Prints .)
    )               reduce using rule 20 (Inst -> Prints .)


state 31

    (21) Inst -> Repeat .

    }               reduce using rule 21 (Inst -> Repeat .)
    id              reduce using rule 21 (Inst -> Repeat .)
    gid             reduce using rule 21 (Inst -> Repeat .)
    return          reduce using rule 21 (Inst -> Repeat .)
    print           reduce using rule 21 (Inst -> Repeat .)
    println         reduce using rule 21 (Inst -> Repeat .)
    prints          reduce using rule 21 (Inst -> Repeat .)
    for             reduce using rule 21 (Inst -> Repeat .)
    while           reduce using rule 21 (Inst -> Repeat .)
    read            reduce using rule 21 (Inst -> Repeat .)
    if              reduce using rule 21 (Inst -> Repeat .)
    repeat          reduce using rule 21 (Inst -> Repeat .)
    num             reduce using rule 21 (Inst -> Repeat .)
    (               reduce using rule 21 (Inst -> Repeat .)
    ;               reduce using rule 21 (Inst -> Repeat .)
    )               reduce using rule 21 (Inst -> Repeat .)


state 32

    (22) Inst -> For .

    }               reduce using rule 22 (Inst -> For .)
    id              reduce using rule 22 (Inst -> For .)
    gid             reduce using rule 22 (Inst -> For .)
    return          reduce using rule 22 (Inst -> For .)
    print           reduce using rule 22 (Inst -> For .)
    println         reduce using rule 22 (Inst -> For .)
    prints          reduce using rule 22 (Inst -> For .)
    for             reduce using rule 22 (Inst -> For .)
    while           reduce using rule 22 (Inst -> For .)
    read            reduce using rule 22 (Inst -> For .)
    if              reduce using rule 22 (Inst -> For .)
    repeat          reduce using rule 22 (Inst -> For .)
    num             reduce using rule 22 (Inst -> For .)
    (               reduce using rule 22 (Inst -> For .)
    ;               reduce using rule 22 (Inst -> For .)
    )               reduce using rule 22 (Inst -> For .)


state 33

    (23) Inst -> While .

    }               reduce using rule 23 (Inst -> While .)
    id              reduce using rule 23 (Inst -> While .)
    gid             reduce using rule 23 (Inst -> While .)
    return          reduce using rule 23 (Inst -> While .)
    print           reduce using rule 23 (Inst -> While .)
    println         reduce using rule 23 (Inst -> While .)
    prints          reduce using rule 23 (Inst -> While .)
    for             reduce using rule 23 (Inst -> While .)
    while           reduce using rule 23 (Inst -> While .)
    read            reduce using rule 23 (Inst -> While .)
    if              reduce using rule 23 (Inst -> While .)
    repeat          reduce using rule 23 (Inst -> While .)
    num             reduce using rule 23 (Inst -> While .)
    (               reduce using rule 23 (Inst -> While .)
    ;               reduce using rule 23 (Inst -> While .)
    )               reduce using rule 23 (Inst -> While .)


state 34

    (24) Inst -> Read .

    }               reduce using rule 24 (Inst -> Read .)
    id              reduce using rule 24 (Inst -> Read .)
    gid             reduce using rule 24 (Inst -> Read .)
    return          reduce using rule 24 (Inst -> Read .)
    print           reduce using rule 24 (Inst -> Read .)
    println         reduce using rule 24 (Inst -> Read .)
    prints          reduce using rule 24 (Inst -> Read .)
    for             reduce using rule 24 (Inst -> Read .)
    while           reduce using rule 24 (Inst -> Read .)
    read            reduce using rule 24 (Inst -> Read .)
    if              reduce using rule 24 (Inst -> Read .)
    repeat          reduce using rule 24 (Inst -> Read .)
    num             reduce using rule 24 (Inst -> Read .)
    (               reduce using rule 24 (Inst -> Read .)
    ;               reduce using rule 24 (Inst -> Read .)
    )               reduce using rule 24 (Inst -> Read .)


state 35

    (25) Inst -> If .

    }               reduce using rule 25 (Inst -> If .)
    id              reduce using rule 25 (Inst -> If .)
    gid             reduce using rule 25 (Inst -> If .)
    return          reduce using rule 25 (Inst -> If .)
    print           reduce using rule 25 (Inst -> If .)
    println         reduce using rule 25 (Inst -> If .)
    prints          reduce using rule 25 (Inst -> If .)
    for             reduce using rule 25 (Inst -> If .)
    while           reduce using rule 25 (Inst -> If .)
    read            reduce using rule 25 (Inst -> If .)
    if              reduce using rule 25 (Inst -> If .)
    repeat          reduce using rule 25 (Inst -> If .)
    num             reduce using rule 25 (Inst -> If .)
    (               reduce using rule 25 (Inst -> If .)
    ;               reduce using rule 25 (Inst -> If .)
    )               reduce using rule 25 (Inst -> If .)


state 36

    (42) Attr -> id . = Exp
    (43) Attr -> id . [ Exp ] = Exp
    (44) Attr -> id . [ Exp ] [ Exp ] = Exp
    (56) Exp -> id . addeq Term
    (57) Exp -> id . subeq Term
    (58) Exp -> id . addeql Term
    (59) Exp -> id . subeql Term
    (64) Term -> id . muleq Factor
    (65) Term -> id . diveq Factor
    (66) Term -> id . modeq Factor
    (67) Term -> id . muleql Factor
    (68) Term -> id . diveql Factor
    (69) Term -> id . modeql Factor
    (71) Factor -> id . plus
    (72) Factor -> id . plusl
    (73) Factor -> id . minus
    (74) Factor -> id . minusl
    (75) Factor -> id .
    (78) Factor -> id . ( )
    (80) Factor -> id . [ Exp ]
    (81) Factor -> id . [ Exp ] [ Exp ]

  ! shift/reduce conflict for ( resolved as shift
    =               shift and go to state 58
    [               shift and go to state 59
    addeq           shift and go to state 60
    subeq           shift and go to state 61
    addeql          shift and go to state 62
    subeql          shift and go to state 63
    muleq           shift and go to state 64
    diveq           shift and go to state 65
    modeq           shift and go to state 66
    muleql          shift and go to state 67
    diveql          shift and go to state 68
    modeql          shift and go to state 69
    plus            shift and go to state 70
    plusl           shift and go to state 71
    minus           shift and go to state 72
    minusl          shift and go to state 73
    *               reduce using rule 75 (Factor -> id .)
    /               reduce using rule 75 (Factor -> id .)
    %               reduce using rule 75 (Factor -> id .)
    +               reduce using rule 75 (Factor -> id .)
    -               reduce using rule 75 (Factor -> id .)
    }               reduce using rule 75 (Factor -> id .)
    id              reduce using rule 75 (Factor -> id .)
    gid             reduce using rule 75 (Factor -> id .)
    return          reduce using rule 75 (Factor -> id .)
    print           reduce using rule 75 (Factor -> id .)
    println         reduce using rule 75 (Factor -> id .)
    prints          reduce using rule 75 (Factor -> id .)
    for             reduce using rule 75 (Factor -> id .)
    while           reduce using rule 75 (Factor -> id .)
    read            reduce using rule 75 (Factor -> id .)
    if              reduce using rule 75 (Factor -> id .)
    repeat          reduce using rule 75 (Factor -> id .)
    num             reduce using rule 75 (Factor -> id .)
    ;               reduce using rule 75 (Factor -> id .)
    )               reduce using rule 75 (Factor -> id .)
    (               shift and go to state 74

  ! (               [ reduce using rule 75 (Factor -> id .) ]


state 37

    (45) Attr -> gid . = Exp
    (46) Attr -> gid . [ Exp ] = Exp
    (47) Attr -> gid . [ Exp ] [ Exp ] = Exp
    (76) Factor -> gid .
    (82) Factor -> gid . [ Exp ]
    (83) Factor -> gid . [ Exp ] [ Exp ]

    =               shift and go to state 75
    [               shift and go to state 76
    *               reduce using rule 76 (Factor -> gid .)
    /               reduce using rule 76 (Factor -> gid .)
    %               reduce using rule 76 (Factor -> gid .)
    +               reduce using rule 76 (Factor -> gid .)
    -               reduce using rule 76 (Factor -> gid .)
    }               reduce using rule 76 (Factor -> gid .)
    id              reduce using rule 76 (Factor -> gid .)
    gid             reduce using rule 76 (Factor -> gid .)
    return          reduce using rule 76 (Factor -> gid .)
    print           reduce using rule 76 (Factor -> gid .)
    println         reduce using rule 76 (Factor -> gid .)
    prints          reduce using rule 76 (Factor -> gid .)
    for             reduce using rule 76 (Factor -> gid .)
    while           reduce using rule 76 (Factor -> gid .)
    read            reduce using rule 76 (Factor -> gid .)
    if              reduce using rule 76 (Factor -> gid .)
    repeat          reduce using rule 76 (Factor -> gid .)
    num             reduce using rule 76 (Factor -> gid .)
    (               reduce using rule 76 (Factor -> gid .)
    ;               reduce using rule 76 (Factor -> gid .)
    )               reduce using rule 76 (Factor -> gid .)


state 38

    (48) Return -> return . ( Exp )

    (               shift and go to state 77


state 39

    (79) Factor -> ( . Cond )
    (84) Factor -> ( . Exp )
    (88) Cond -> . Cond and Cond
    (89) Cond -> . Cond or Cond
    (90) Cond -> . ( Cond and Cond )
    (91) Cond -> . ( Cond or Cond )
    (92) Cond -> . Exp sup Exp
    (93) Cond -> . Exp inf Exp
    (94) Cond -> . Exp supeq Exp
    (95) Cond -> . Exp infeq Exp
    (96) Cond -> . not Exp
    (97) Cond -> . Exp eq Exp
    (98) Cond -> . Exp diff Exp
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    (               shift and go to state 78
    not             shift and go to state 81
    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45

    Cond                           shift and go to state 79
    Exp                            shift and go to state 80
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 40

    (60) Exp -> Term .
    (61) Term -> Term . * Factor
    (62) Term -> Term . / Factor
    (63) Term -> Term . % Factor

    +               reduce using rule 60 (Exp -> Term .)
    -               reduce using rule 60 (Exp -> Term .)
    }               reduce using rule 60 (Exp -> Term .)
    id              reduce using rule 60 (Exp -> Term .)
    gid             reduce using rule 60 (Exp -> Term .)
    return          reduce using rule 60 (Exp -> Term .)
    print           reduce using rule 60 (Exp -> Term .)
    println         reduce using rule 60 (Exp -> Term .)
    prints          reduce using rule 60 (Exp -> Term .)
    for             reduce using rule 60 (Exp -> Term .)
    while           reduce using rule 60 (Exp -> Term .)
    read            reduce using rule 60 (Exp -> Term .)
    if              reduce using rule 60 (Exp -> Term .)
    repeat          reduce using rule 60 (Exp -> Term .)
    num             reduce using rule 60 (Exp -> Term .)
    (               reduce using rule 60 (Exp -> Term .)
    )               reduce using rule 60 (Exp -> Term .)
    sup             reduce using rule 60 (Exp -> Term .)
    inf             reduce using rule 60 (Exp -> Term .)
    supeq           reduce using rule 60 (Exp -> Term .)
    infeq           reduce using rule 60 (Exp -> Term .)
    eq              reduce using rule 60 (Exp -> Term .)
    diff            reduce using rule 60 (Exp -> Term .)
    ;               reduce using rule 60 (Exp -> Term .)
    ]               reduce using rule 60 (Exp -> Term .)
    and             reduce using rule 60 (Exp -> Term .)
    or              reduce using rule 60 (Exp -> Term .)
    *               shift and go to state 84
    /               shift and go to state 85
    %               shift and go to state 86


state 41

    (31) Print -> print . ( Exp )

    (               shift and go to state 87


state 42

    (32) Println -> println . ( Exp )

    (               shift and go to state 88


state 43

    (33) Prints -> prints . ( string )

    (               shift and go to state 89


state 44

    (26) Repeat -> RepeatS . ( num ) { Insts }

    (               shift and go to state 90


state 45

    (77) Factor -> num .

    *               reduce using rule 77 (Factor -> num .)
    /               reduce using rule 77 (Factor -> num .)
    %               reduce using rule 77 (Factor -> num .)
    +               reduce using rule 77 (Factor -> num .)
    -               reduce using rule 77 (Factor -> num .)
    }               reduce using rule 77 (Factor -> num .)
    id              reduce using rule 77 (Factor -> num .)
    gid             reduce using rule 77 (Factor -> num .)
    return          reduce using rule 77 (Factor -> num .)
    print           reduce using rule 77 (Factor -> num .)
    println         reduce using rule 77 (Factor -> num .)
    prints          reduce using rule 77 (Factor -> num .)
    for             reduce using rule 77 (Factor -> num .)
    while           reduce using rule 77 (Factor -> num .)
    read            reduce using rule 77 (Factor -> num .)
    if              reduce using rule 77 (Factor -> num .)
    repeat          reduce using rule 77 (Factor -> num .)
    num             reduce using rule 77 (Factor -> num .)
    (               reduce using rule 77 (Factor -> num .)
    )               reduce using rule 77 (Factor -> num .)
    sup             reduce using rule 77 (Factor -> num .)
    inf             reduce using rule 77 (Factor -> num .)
    supeq           reduce using rule 77 (Factor -> num .)
    infeq           reduce using rule 77 (Factor -> num .)
    eq              reduce using rule 77 (Factor -> num .)
    diff            reduce using rule 77 (Factor -> num .)
    ;               reduce using rule 77 (Factor -> num .)
    ]               reduce using rule 77 (Factor -> num .)
    and             reduce using rule 77 (Factor -> num .)
    or              reduce using rule 77 (Factor -> num .)


state 46

    (28) For -> for . ( Insts ; Cond ; Insts ) { Insts }

    (               shift and go to state 91


state 47

    (29) While -> while . ( Cond ) { Insts }

    (               shift and go to state 92


state 48

    (30) Read -> read . ( id )

    (               shift and go to state 93


state 49

    (49) If -> if . ( Cond ) { Insts }
    (50) If -> if . ( Cond ) Inst
    (52) If -> if . ( Cond ) { Insts } else { Insts }

    (               shift and go to state 94


state 50

    (70) Term -> Factor .

    *               reduce using rule 70 (Term -> Factor .)
    /               reduce using rule 70 (Term -> Factor .)
    %               reduce using rule 70 (Term -> Factor .)
    +               reduce using rule 70 (Term -> Factor .)
    -               reduce using rule 70 (Term -> Factor .)
    }               reduce using rule 70 (Term -> Factor .)
    id              reduce using rule 70 (Term -> Factor .)
    gid             reduce using rule 70 (Term -> Factor .)
    return          reduce using rule 70 (Term -> Factor .)
    print           reduce using rule 70 (Term -> Factor .)
    println         reduce using rule 70 (Term -> Factor .)
    prints          reduce using rule 70 (Term -> Factor .)
    for             reduce using rule 70 (Term -> Factor .)
    while           reduce using rule 70 (Term -> Factor .)
    read            reduce using rule 70 (Term -> Factor .)
    if              reduce using rule 70 (Term -> Factor .)
    repeat          reduce using rule 70 (Term -> Factor .)
    num             reduce using rule 70 (Term -> Factor .)
    (               reduce using rule 70 (Term -> Factor .)
    )               reduce using rule 70 (Term -> Factor .)
    sup             reduce using rule 70 (Term -> Factor .)
    inf             reduce using rule 70 (Term -> Factor .)
    supeq           reduce using rule 70 (Term -> Factor .)
    infeq           reduce using rule 70 (Term -> Factor .)
    eq              reduce using rule 70 (Term -> Factor .)
    diff            reduce using rule 70 (Term -> Factor .)
    ;               reduce using rule 70 (Term -> Factor .)
    ]               reduce using rule 70 (Term -> Factor .)
    and             reduce using rule 70 (Term -> Factor .)
    or              reduce using rule 70 (Term -> Factor .)


state 51

    (27) RepeatS -> repeat .

    (               reduce using rule 27 (RepeatS -> repeat .)


state 52

    (34) Dcl -> int id . [ num ]
    (35) Dcl -> int id . [ num ] [ num ]
    (36) Dcl -> int id .
    (37) Dcl -> int id . = num

    [               shift and go to state 95
    int             reduce using rule 36 (Dcl -> int id .)
    }               reduce using rule 36 (Dcl -> int id .)
    id              reduce using rule 36 (Dcl -> int id .)
    gid             reduce using rule 36 (Dcl -> int id .)
    return          reduce using rule 36 (Dcl -> int id .)
    print           reduce using rule 36 (Dcl -> int id .)
    println         reduce using rule 36 (Dcl -> int id .)
    prints          reduce using rule 36 (Dcl -> int id .)
    for             reduce using rule 36 (Dcl -> int id .)
    while           reduce using rule 36 (Dcl -> int id .)
    read            reduce using rule 36 (Dcl -> int id .)
    if              reduce using rule 36 (Dcl -> int id .)
    repeat          reduce using rule 36 (Dcl -> int id .)
    num             reduce using rule 36 (Dcl -> int id .)
    (               reduce using rule 36 (Dcl -> int id .)
    =               shift and go to state 96


state 53

    (38) DclGlobal -> int id [ . num ]
    (39) DclGlobal -> int id [ . num ] [ num ]

    num             shift and go to state 97


state 54

    (41) DclGlobal -> int id = . num

    num             shift and go to state 98


state 55

    (4) DefBlc -> id { VarBlc Insts . }
    (13) Insts -> Insts . Inst
    (15) Inst -> . Attr
    (16) Inst -> . Return
    (17) Inst -> . Exp
    (18) Inst -> . Print
    (19) Inst -> . Println
    (20) Inst -> . Prints
    (21) Inst -> . Repeat
    (22) Inst -> . For
    (23) Inst -> . While
    (24) Inst -> . Read
    (25) Inst -> . If
    (42) Attr -> . id = Exp
    (43) Attr -> . id [ Exp ] = Exp
    (44) Attr -> . id [ Exp ] [ Exp ] = Exp
    (45) Attr -> . gid = Exp
    (46) Attr -> . gid [ Exp ] = Exp
    (47) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (48) Return -> . return ( Exp )
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (31) Print -> . print ( Exp )
    (32) Println -> . println ( Exp )
    (33) Prints -> . prints ( string )
    (26) Repeat -> . RepeatS ( num ) { Insts }
    (28) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (29) While -> . while ( Cond ) { Insts }
    (30) Read -> . read ( id )
    (49) If -> . if ( Cond ) { Insts }
    (50) If -> . if ( Cond ) Inst
    (52) If -> . if ( Cond ) { Insts } else { Insts }
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (27) RepeatS -> . repeat
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    }               shift and go to state 99
    id              shift and go to state 36
    gid             shift and go to state 37
    return          shift and go to state 38
    print           shift and go to state 41
    println         shift and go to state 42
    prints          shift and go to state 43
    for             shift and go to state 46
    while           shift and go to state 47
    read            shift and go to state 48
    if              shift and go to state 49
    repeat          shift and go to state 51
    num             shift and go to state 45
    (               shift and go to state 39

    Inst                           shift and go to state 24
    Attr                           shift and go to state 25
    Return                         shift and go to state 26
    Exp                            shift and go to state 27
    Print                          shift and go to state 28
    Println                        shift and go to state 29
    Prints                         shift and go to state 30
    Repeat                         shift and go to state 31
    For                            shift and go to state 32
    While                          shift and go to state 33
    Read                           shift and go to state 34
    If                             shift and go to state 35
    Term                           shift and go to state 40
    RepeatS                        shift and go to state 44
    Factor                         shift and go to state 50

state 56

    (54) Exp -> Exp + . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 101
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Term                           shift and go to state 100
    Factor                         shift and go to state 50

state 57

    (55) Exp -> Exp - . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 101
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Term                           shift and go to state 102
    Factor                         shift and go to state 50

state 58

    (42) Attr -> id = . Exp
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 103
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 59

    (43) Attr -> id [ . Exp ] = Exp
    (44) Attr -> id [ . Exp ] [ Exp ] = Exp
    (80) Factor -> id [ . Exp ]
    (81) Factor -> id [ . Exp ] [ Exp ]
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 104
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 60

    (56) Exp -> id addeq . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 101
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Term                           shift and go to state 105
    Factor                         shift and go to state 50

state 61

    (57) Exp -> id subeq . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 101
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Term                           shift and go to state 106
    Factor                         shift and go to state 50

state 62

    (58) Exp -> id addeql . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 101
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Term                           shift and go to state 107
    Factor                         shift and go to state 50

state 63

    (59) Exp -> id subeql . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 101
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Term                           shift and go to state 108
    Factor                         shift and go to state 50

state 64

    (64) Term -> id muleq . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 109
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Factor                         shift and go to state 110

state 65

    (65) Term -> id diveq . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 109
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Factor                         shift and go to state 111

state 66

    (66) Term -> id modeq . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 109
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Factor                         shift and go to state 112

state 67

    (67) Term -> id muleql . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 109
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Factor                         shift and go to state 113

state 68

    (68) Term -> id diveql . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 109
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Factor                         shift and go to state 114

state 69

    (69) Term -> id modeql . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 109
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Factor                         shift and go to state 115

state 70

    (71) Factor -> id plus .

    *               reduce using rule 71 (Factor -> id plus .)
    /               reduce using rule 71 (Factor -> id plus .)
    %               reduce using rule 71 (Factor -> id plus .)
    +               reduce using rule 71 (Factor -> id plus .)
    -               reduce using rule 71 (Factor -> id plus .)
    }               reduce using rule 71 (Factor -> id plus .)
    id              reduce using rule 71 (Factor -> id plus .)
    gid             reduce using rule 71 (Factor -> id plus .)
    return          reduce using rule 71 (Factor -> id plus .)
    print           reduce using rule 71 (Factor -> id plus .)
    println         reduce using rule 71 (Factor -> id plus .)
    prints          reduce using rule 71 (Factor -> id plus .)
    for             reduce using rule 71 (Factor -> id plus .)
    while           reduce using rule 71 (Factor -> id plus .)
    read            reduce using rule 71 (Factor -> id plus .)
    if              reduce using rule 71 (Factor -> id plus .)
    repeat          reduce using rule 71 (Factor -> id plus .)
    num             reduce using rule 71 (Factor -> id plus .)
    (               reduce using rule 71 (Factor -> id plus .)
    )               reduce using rule 71 (Factor -> id plus .)
    sup             reduce using rule 71 (Factor -> id plus .)
    inf             reduce using rule 71 (Factor -> id plus .)
    supeq           reduce using rule 71 (Factor -> id plus .)
    infeq           reduce using rule 71 (Factor -> id plus .)
    eq              reduce using rule 71 (Factor -> id plus .)
    diff            reduce using rule 71 (Factor -> id plus .)
    ;               reduce using rule 71 (Factor -> id plus .)
    ]               reduce using rule 71 (Factor -> id plus .)
    and             reduce using rule 71 (Factor -> id plus .)
    or              reduce using rule 71 (Factor -> id plus .)


state 71

    (72) Factor -> id plusl .

    *               reduce using rule 72 (Factor -> id plusl .)
    /               reduce using rule 72 (Factor -> id plusl .)
    %               reduce using rule 72 (Factor -> id plusl .)
    +               reduce using rule 72 (Factor -> id plusl .)
    -               reduce using rule 72 (Factor -> id plusl .)
    }               reduce using rule 72 (Factor -> id plusl .)
    id              reduce using rule 72 (Factor -> id plusl .)
    gid             reduce using rule 72 (Factor -> id plusl .)
    return          reduce using rule 72 (Factor -> id plusl .)
    print           reduce using rule 72 (Factor -> id plusl .)
    println         reduce using rule 72 (Factor -> id plusl .)
    prints          reduce using rule 72 (Factor -> id plusl .)
    for             reduce using rule 72 (Factor -> id plusl .)
    while           reduce using rule 72 (Factor -> id plusl .)
    read            reduce using rule 72 (Factor -> id plusl .)
    if              reduce using rule 72 (Factor -> id plusl .)
    repeat          reduce using rule 72 (Factor -> id plusl .)
    num             reduce using rule 72 (Factor -> id plusl .)
    (               reduce using rule 72 (Factor -> id plusl .)
    )               reduce using rule 72 (Factor -> id plusl .)
    sup             reduce using rule 72 (Factor -> id plusl .)
    inf             reduce using rule 72 (Factor -> id plusl .)
    supeq           reduce using rule 72 (Factor -> id plusl .)
    infeq           reduce using rule 72 (Factor -> id plusl .)
    eq              reduce using rule 72 (Factor -> id plusl .)
    diff            reduce using rule 72 (Factor -> id plusl .)
    ;               reduce using rule 72 (Factor -> id plusl .)
    ]               reduce using rule 72 (Factor -> id plusl .)
    and             reduce using rule 72 (Factor -> id plusl .)
    or              reduce using rule 72 (Factor -> id plusl .)


state 72

    (73) Factor -> id minus .

    *               reduce using rule 73 (Factor -> id minus .)
    /               reduce using rule 73 (Factor -> id minus .)
    %               reduce using rule 73 (Factor -> id minus .)
    +               reduce using rule 73 (Factor -> id minus .)
    -               reduce using rule 73 (Factor -> id minus .)
    }               reduce using rule 73 (Factor -> id minus .)
    id              reduce using rule 73 (Factor -> id minus .)
    gid             reduce using rule 73 (Factor -> id minus .)
    return          reduce using rule 73 (Factor -> id minus .)
    print           reduce using rule 73 (Factor -> id minus .)
    println         reduce using rule 73 (Factor -> id minus .)
    prints          reduce using rule 73 (Factor -> id minus .)
    for             reduce using rule 73 (Factor -> id minus .)
    while           reduce using rule 73 (Factor -> id minus .)
    read            reduce using rule 73 (Factor -> id minus .)
    if              reduce using rule 73 (Factor -> id minus .)
    repeat          reduce using rule 73 (Factor -> id minus .)
    num             reduce using rule 73 (Factor -> id minus .)
    (               reduce using rule 73 (Factor -> id minus .)
    )               reduce using rule 73 (Factor -> id minus .)
    sup             reduce using rule 73 (Factor -> id minus .)
    inf             reduce using rule 73 (Factor -> id minus .)
    supeq           reduce using rule 73 (Factor -> id minus .)
    infeq           reduce using rule 73 (Factor -> id minus .)
    eq              reduce using rule 73 (Factor -> id minus .)
    diff            reduce using rule 73 (Factor -> id minus .)
    ;               reduce using rule 73 (Factor -> id minus .)
    ]               reduce using rule 73 (Factor -> id minus .)
    and             reduce using rule 73 (Factor -> id minus .)
    or              reduce using rule 73 (Factor -> id minus .)


state 73

    (74) Factor -> id minusl .

    *               reduce using rule 74 (Factor -> id minusl .)
    /               reduce using rule 74 (Factor -> id minusl .)
    %               reduce using rule 74 (Factor -> id minusl .)
    +               reduce using rule 74 (Factor -> id minusl .)
    -               reduce using rule 74 (Factor -> id minusl .)
    }               reduce using rule 74 (Factor -> id minusl .)
    id              reduce using rule 74 (Factor -> id minusl .)
    gid             reduce using rule 74 (Factor -> id minusl .)
    return          reduce using rule 74 (Factor -> id minusl .)
    print           reduce using rule 74 (Factor -> id minusl .)
    println         reduce using rule 74 (Factor -> id minusl .)
    prints          reduce using rule 74 (Factor -> id minusl .)
    for             reduce using rule 74 (Factor -> id minusl .)
    while           reduce using rule 74 (Factor -> id minusl .)
    read            reduce using rule 74 (Factor -> id minusl .)
    if              reduce using rule 74 (Factor -> id minusl .)
    repeat          reduce using rule 74 (Factor -> id minusl .)
    num             reduce using rule 74 (Factor -> id minusl .)
    (               reduce using rule 74 (Factor -> id minusl .)
    )               reduce using rule 74 (Factor -> id minusl .)
    sup             reduce using rule 74 (Factor -> id minusl .)
    inf             reduce using rule 74 (Factor -> id minusl .)
    supeq           reduce using rule 74 (Factor -> id minusl .)
    infeq           reduce using rule 74 (Factor -> id minusl .)
    eq              reduce using rule 74 (Factor -> id minusl .)
    diff            reduce using rule 74 (Factor -> id minusl .)
    ;               reduce using rule 74 (Factor -> id minusl .)
    ]               reduce using rule 74 (Factor -> id minusl .)
    and             reduce using rule 74 (Factor -> id minusl .)
    or              reduce using rule 74 (Factor -> id minusl .)


state 74

    (78) Factor -> id ( . )

    )               shift and go to state 116


state 75

    (45) Attr -> gid = . Exp
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 117
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 76

    (46) Attr -> gid [ . Exp ] = Exp
    (47) Attr -> gid [ . Exp ] [ Exp ] = Exp
    (82) Factor -> gid [ . Exp ]
    (83) Factor -> gid [ . Exp ] [ Exp ]
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 118
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 77

    (48) Return -> return ( . Exp )
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 119
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 78

    (90) Cond -> ( . Cond and Cond )
    (91) Cond -> ( . Cond or Cond )
    (79) Factor -> ( . Cond )
    (84) Factor -> ( . Exp )
    (88) Cond -> . Cond and Cond
    (89) Cond -> . Cond or Cond
    (90) Cond -> . ( Cond and Cond )
    (91) Cond -> . ( Cond or Cond )
    (92) Cond -> . Exp sup Exp
    (93) Cond -> . Exp inf Exp
    (94) Cond -> . Exp supeq Exp
    (95) Cond -> . Exp infeq Exp
    (96) Cond -> . not Exp
    (97) Cond -> . Exp eq Exp
    (98) Cond -> . Exp diff Exp
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    (               shift and go to state 78
    not             shift and go to state 81
    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45

    Cond                           shift and go to state 120
    Exp                            shift and go to state 80
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 79

    (79) Factor -> ( Cond . )
    (88) Cond -> Cond . and Cond
    (89) Cond -> Cond . or Cond

    )               shift and go to state 121
    and             shift and go to state 122
    or              shift and go to state 123


state 80

    (84) Factor -> ( Exp . )
    (92) Cond -> Exp . sup Exp
    (93) Cond -> Exp . inf Exp
    (94) Cond -> Exp . supeq Exp
    (95) Cond -> Exp . infeq Exp
    (97) Cond -> Exp . eq Exp
    (98) Cond -> Exp . diff Exp
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    )               shift and go to state 124
    sup             shift and go to state 125
    inf             shift and go to state 126
    supeq           shift and go to state 127
    infeq           shift and go to state 128
    eq              shift and go to state 129
    diff            shift and go to state 130
    +               shift and go to state 56
    -               shift and go to state 57


state 81

    (96) Cond -> not . Exp
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 131
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 82

    (56) Exp -> id . addeq Term
    (57) Exp -> id . subeq Term
    (58) Exp -> id . addeql Term
    (59) Exp -> id . subeql Term
    (64) Term -> id . muleq Factor
    (65) Term -> id . diveq Factor
    (66) Term -> id . modeq Factor
    (67) Term -> id . muleql Factor
    (68) Term -> id . diveql Factor
    (69) Term -> id . modeql Factor
    (71) Factor -> id . plus
    (72) Factor -> id . plusl
    (73) Factor -> id . minus
    (74) Factor -> id . minusl
    (75) Factor -> id .
    (78) Factor -> id . ( )
    (80) Factor -> id . [ Exp ]
    (81) Factor -> id . [ Exp ] [ Exp ]

  ! shift/reduce conflict for ( resolved as shift
    addeq           shift and go to state 60
    subeq           shift and go to state 61
    addeql          shift and go to state 62
    subeql          shift and go to state 63
    muleq           shift and go to state 64
    diveq           shift and go to state 65
    modeq           shift and go to state 66
    muleql          shift and go to state 67
    diveql          shift and go to state 68
    modeql          shift and go to state 69
    plus            shift and go to state 70
    plusl           shift and go to state 71
    minus           shift and go to state 72
    minusl          shift and go to state 73
    *               reduce using rule 75 (Factor -> id .)
    /               reduce using rule 75 (Factor -> id .)
    %               reduce using rule 75 (Factor -> id .)
    )               reduce using rule 75 (Factor -> id .)
    sup             reduce using rule 75 (Factor -> id .)
    inf             reduce using rule 75 (Factor -> id .)
    supeq           reduce using rule 75 (Factor -> id .)
    infeq           reduce using rule 75 (Factor -> id .)
    eq              reduce using rule 75 (Factor -> id .)
    diff            reduce using rule 75 (Factor -> id .)
    +               reduce using rule 75 (Factor -> id .)
    -               reduce using rule 75 (Factor -> id .)
    }               reduce using rule 75 (Factor -> id .)
    id              reduce using rule 75 (Factor -> id .)
    gid             reduce using rule 75 (Factor -> id .)
    return          reduce using rule 75 (Factor -> id .)
    print           reduce using rule 75 (Factor -> id .)
    println         reduce using rule 75 (Factor -> id .)
    prints          reduce using rule 75 (Factor -> id .)
    for             reduce using rule 75 (Factor -> id .)
    while           reduce using rule 75 (Factor -> id .)
    read            reduce using rule 75 (Factor -> id .)
    if              reduce using rule 75 (Factor -> id .)
    repeat          reduce using rule 75 (Factor -> id .)
    num             reduce using rule 75 (Factor -> id .)
    ;               reduce using rule 75 (Factor -> id .)
    ]               reduce using rule 75 (Factor -> id .)
    and             reduce using rule 75 (Factor -> id .)
    or              reduce using rule 75 (Factor -> id .)
    (               shift and go to state 74
    [               shift and go to state 132

  ! (               [ reduce using rule 75 (Factor -> id .) ]


state 83

    (76) Factor -> gid .
    (82) Factor -> gid . [ Exp ]
    (83) Factor -> gid . [ Exp ] [ Exp ]

    *               reduce using rule 76 (Factor -> gid .)
    /               reduce using rule 76 (Factor -> gid .)
    %               reduce using rule 76 (Factor -> gid .)
    )               reduce using rule 76 (Factor -> gid .)
    sup             reduce using rule 76 (Factor -> gid .)
    inf             reduce using rule 76 (Factor -> gid .)
    supeq           reduce using rule 76 (Factor -> gid .)
    infeq           reduce using rule 76 (Factor -> gid .)
    eq              reduce using rule 76 (Factor -> gid .)
    diff            reduce using rule 76 (Factor -> gid .)
    +               reduce using rule 76 (Factor -> gid .)
    -               reduce using rule 76 (Factor -> gid .)
    }               reduce using rule 76 (Factor -> gid .)
    id              reduce using rule 76 (Factor -> gid .)
    gid             reduce using rule 76 (Factor -> gid .)
    return          reduce using rule 76 (Factor -> gid .)
    print           reduce using rule 76 (Factor -> gid .)
    println         reduce using rule 76 (Factor -> gid .)
    prints          reduce using rule 76 (Factor -> gid .)
    for             reduce using rule 76 (Factor -> gid .)
    while           reduce using rule 76 (Factor -> gid .)
    read            reduce using rule 76 (Factor -> gid .)
    if              reduce using rule 76 (Factor -> gid .)
    repeat          reduce using rule 76 (Factor -> gid .)
    num             reduce using rule 76 (Factor -> gid .)
    (               reduce using rule 76 (Factor -> gid .)
    ;               reduce using rule 76 (Factor -> gid .)
    ]               reduce using rule 76 (Factor -> gid .)
    and             reduce using rule 76 (Factor -> gid .)
    or              reduce using rule 76 (Factor -> gid .)
    [               shift and go to state 133


state 84

    (61) Term -> Term * . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 109
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Factor                         shift and go to state 134

state 85

    (62) Term -> Term / . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 109
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Factor                         shift and go to state 135

state 86

    (63) Term -> Term % . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 109
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Factor                         shift and go to state 136

state 87

    (31) Print -> print ( . Exp )
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 137
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 88

    (32) Println -> println ( . Exp )
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 138
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 89

    (33) Prints -> prints ( . string )

    string          shift and go to state 139


state 90

    (26) Repeat -> RepeatS ( . num ) { Insts }

    num             shift and go to state 140


state 91

    (28) For -> for ( . Insts ; Cond ; Insts ) { Insts }
    (13) Insts -> . Insts Inst
    (14) Insts -> .

    ;               reduce using rule 14 (Insts -> .)
    id              reduce using rule 14 (Insts -> .)
    gid             reduce using rule 14 (Insts -> .)
    return          reduce using rule 14 (Insts -> .)
    print           reduce using rule 14 (Insts -> .)
    println         reduce using rule 14 (Insts -> .)
    prints          reduce using rule 14 (Insts -> .)
    for             reduce using rule 14 (Insts -> .)
    while           reduce using rule 14 (Insts -> .)
    read            reduce using rule 14 (Insts -> .)
    if              reduce using rule 14 (Insts -> .)
    repeat          reduce using rule 14 (Insts -> .)
    num             reduce using rule 14 (Insts -> .)
    (               reduce using rule 14 (Insts -> .)

    Insts                          shift and go to state 141

state 92

    (29) While -> while ( . Cond ) { Insts }
    (88) Cond -> . Cond and Cond
    (89) Cond -> . Cond or Cond
    (90) Cond -> . ( Cond and Cond )
    (91) Cond -> . ( Cond or Cond )
    (92) Cond -> . Exp sup Exp
    (93) Cond -> . Exp inf Exp
    (94) Cond -> . Exp supeq Exp
    (95) Cond -> . Exp infeq Exp
    (96) Cond -> . not Exp
    (97) Cond -> . Exp eq Exp
    (98) Cond -> . Exp diff Exp
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    (               shift and go to state 78
    not             shift and go to state 81
    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45

    Cond                           shift and go to state 142
    Exp                            shift and go to state 143
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 93

    (30) Read -> read ( . id )

    id              shift and go to state 144


state 94

    (49) If -> if ( . Cond ) { Insts }
    (50) If -> if ( . Cond ) Inst
    (52) If -> if ( . Cond ) { Insts } else { Insts }
    (88) Cond -> . Cond and Cond
    (89) Cond -> . Cond or Cond
    (90) Cond -> . ( Cond and Cond )
    (91) Cond -> . ( Cond or Cond )
    (92) Cond -> . Exp sup Exp
    (93) Cond -> . Exp inf Exp
    (94) Cond -> . Exp supeq Exp
    (95) Cond -> . Exp infeq Exp
    (96) Cond -> . not Exp
    (97) Cond -> . Exp eq Exp
    (98) Cond -> . Exp diff Exp
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    (               shift and go to state 78
    not             shift and go to state 81
    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45

    Cond                           shift and go to state 145
    Exp                            shift and go to state 143
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 95

    (34) Dcl -> int id [ . num ]
    (35) Dcl -> int id [ . num ] [ num ]

    num             shift and go to state 146


state 96

    (37) Dcl -> int id = . num

    num             shift and go to state 147


state 97

    (38) DclGlobal -> int id [ num . ]
    (39) DclGlobal -> int id [ num . ] [ num ]

    ]               shift and go to state 148


state 98

    (41) DclGlobal -> int id = num .

    }               reduce using rule 41 (DclGlobal -> int id = num .)
    int             reduce using rule 41 (DclGlobal -> int id = num .)


state 99

    (4) DefBlc -> id { VarBlc Insts } .

    id              reduce using rule 4 (DefBlc -> id { VarBlc Insts } .)
    $end            reduce using rule 4 (DefBlc -> id { VarBlc Insts } .)


state 100

    (54) Exp -> Exp + Term .
    (61) Term -> Term . * Factor
    (62) Term -> Term . / Factor
    (63) Term -> Term . % Factor

    +               reduce using rule 54 (Exp -> Exp + Term .)
    -               reduce using rule 54 (Exp -> Exp + Term .)
    }               reduce using rule 54 (Exp -> Exp + Term .)
    id              reduce using rule 54 (Exp -> Exp + Term .)
    gid             reduce using rule 54 (Exp -> Exp + Term .)
    return          reduce using rule 54 (Exp -> Exp + Term .)
    print           reduce using rule 54 (Exp -> Exp + Term .)
    println         reduce using rule 54 (Exp -> Exp + Term .)
    prints          reduce using rule 54 (Exp -> Exp + Term .)
    for             reduce using rule 54 (Exp -> Exp + Term .)
    while           reduce using rule 54 (Exp -> Exp + Term .)
    read            reduce using rule 54 (Exp -> Exp + Term .)
    if              reduce using rule 54 (Exp -> Exp + Term .)
    repeat          reduce using rule 54 (Exp -> Exp + Term .)
    num             reduce using rule 54 (Exp -> Exp + Term .)
    (               reduce using rule 54 (Exp -> Exp + Term .)
    )               reduce using rule 54 (Exp -> Exp + Term .)
    sup             reduce using rule 54 (Exp -> Exp + Term .)
    inf             reduce using rule 54 (Exp -> Exp + Term .)
    supeq           reduce using rule 54 (Exp -> Exp + Term .)
    infeq           reduce using rule 54 (Exp -> Exp + Term .)
    eq              reduce using rule 54 (Exp -> Exp + Term .)
    diff            reduce using rule 54 (Exp -> Exp + Term .)
    ;               reduce using rule 54 (Exp -> Exp + Term .)
    ]               reduce using rule 54 (Exp -> Exp + Term .)
    and             reduce using rule 54 (Exp -> Exp + Term .)
    or              reduce using rule 54 (Exp -> Exp + Term .)
    *               shift and go to state 84
    /               shift and go to state 85
    %               shift and go to state 86


state 101

    (64) Term -> id . muleq Factor
    (65) Term -> id . diveq Factor
    (66) Term -> id . modeq Factor
    (67) Term -> id . muleql Factor
    (68) Term -> id . diveql Factor
    (69) Term -> id . modeql Factor
    (71) Factor -> id . plus
    (72) Factor -> id . plusl
    (73) Factor -> id . minus
    (74) Factor -> id . minusl
    (75) Factor -> id .
    (78) Factor -> id . ( )
    (80) Factor -> id . [ Exp ]
    (81) Factor -> id . [ Exp ] [ Exp ]

  ! shift/reduce conflict for ( resolved as shift
    muleq           shift and go to state 64
    diveq           shift and go to state 65
    modeq           shift and go to state 66
    muleql          shift and go to state 67
    diveql          shift and go to state 68
    modeql          shift and go to state 69
    plus            shift and go to state 70
    plusl           shift and go to state 71
    minus           shift and go to state 72
    minusl          shift and go to state 73
    *               reduce using rule 75 (Factor -> id .)
    /               reduce using rule 75 (Factor -> id .)
    %               reduce using rule 75 (Factor -> id .)
    +               reduce using rule 75 (Factor -> id .)
    -               reduce using rule 75 (Factor -> id .)
    }               reduce using rule 75 (Factor -> id .)
    id              reduce using rule 75 (Factor -> id .)
    gid             reduce using rule 75 (Factor -> id .)
    return          reduce using rule 75 (Factor -> id .)
    print           reduce using rule 75 (Factor -> id .)
    println         reduce using rule 75 (Factor -> id .)
    prints          reduce using rule 75 (Factor -> id .)
    for             reduce using rule 75 (Factor -> id .)
    while           reduce using rule 75 (Factor -> id .)
    read            reduce using rule 75 (Factor -> id .)
    if              reduce using rule 75 (Factor -> id .)
    repeat          reduce using rule 75 (Factor -> id .)
    num             reduce using rule 75 (Factor -> id .)
    )               reduce using rule 75 (Factor -> id .)
    sup             reduce using rule 75 (Factor -> id .)
    inf             reduce using rule 75 (Factor -> id .)
    supeq           reduce using rule 75 (Factor -> id .)
    infeq           reduce using rule 75 (Factor -> id .)
    eq              reduce using rule 75 (Factor -> id .)
    diff            reduce using rule 75 (Factor -> id .)
    ;               reduce using rule 75 (Factor -> id .)
    ]               reduce using rule 75 (Factor -> id .)
    and             reduce using rule 75 (Factor -> id .)
    or              reduce using rule 75 (Factor -> id .)
    (               shift and go to state 74
    [               shift and go to state 132

  ! (               [ reduce using rule 75 (Factor -> id .) ]


state 102

    (55) Exp -> Exp - Term .
    (61) Term -> Term . * Factor
    (62) Term -> Term . / Factor
    (63) Term -> Term . % Factor

    +               reduce using rule 55 (Exp -> Exp - Term .)
    -               reduce using rule 55 (Exp -> Exp - Term .)
    }               reduce using rule 55 (Exp -> Exp - Term .)
    id              reduce using rule 55 (Exp -> Exp - Term .)
    gid             reduce using rule 55 (Exp -> Exp - Term .)
    return          reduce using rule 55 (Exp -> Exp - Term .)
    print           reduce using rule 55 (Exp -> Exp - Term .)
    println         reduce using rule 55 (Exp -> Exp - Term .)
    prints          reduce using rule 55 (Exp -> Exp - Term .)
    for             reduce using rule 55 (Exp -> Exp - Term .)
    while           reduce using rule 55 (Exp -> Exp - Term .)
    read            reduce using rule 55 (Exp -> Exp - Term .)
    if              reduce using rule 55 (Exp -> Exp - Term .)
    repeat          reduce using rule 55 (Exp -> Exp - Term .)
    num             reduce using rule 55 (Exp -> Exp - Term .)
    (               reduce using rule 55 (Exp -> Exp - Term .)
    )               reduce using rule 55 (Exp -> Exp - Term .)
    sup             reduce using rule 55 (Exp -> Exp - Term .)
    inf             reduce using rule 55 (Exp -> Exp - Term .)
    supeq           reduce using rule 55 (Exp -> Exp - Term .)
    infeq           reduce using rule 55 (Exp -> Exp - Term .)
    eq              reduce using rule 55 (Exp -> Exp - Term .)
    diff            reduce using rule 55 (Exp -> Exp - Term .)
    ;               reduce using rule 55 (Exp -> Exp - Term .)
    ]               reduce using rule 55 (Exp -> Exp - Term .)
    and             reduce using rule 55 (Exp -> Exp - Term .)
    or              reduce using rule 55 (Exp -> Exp - Term .)
    *               shift and go to state 84
    /               shift and go to state 85
    %               shift and go to state 86


state 103

    (42) Attr -> id = Exp .
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    }               reduce using rule 42 (Attr -> id = Exp .)
    id              reduce using rule 42 (Attr -> id = Exp .)
    gid             reduce using rule 42 (Attr -> id = Exp .)
    return          reduce using rule 42 (Attr -> id = Exp .)
    print           reduce using rule 42 (Attr -> id = Exp .)
    println         reduce using rule 42 (Attr -> id = Exp .)
    prints          reduce using rule 42 (Attr -> id = Exp .)
    for             reduce using rule 42 (Attr -> id = Exp .)
    while           reduce using rule 42 (Attr -> id = Exp .)
    read            reduce using rule 42 (Attr -> id = Exp .)
    if              reduce using rule 42 (Attr -> id = Exp .)
    repeat          reduce using rule 42 (Attr -> id = Exp .)
    num             reduce using rule 42 (Attr -> id = Exp .)
    (               reduce using rule 42 (Attr -> id = Exp .)
    ;               reduce using rule 42 (Attr -> id = Exp .)
    )               reduce using rule 42 (Attr -> id = Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 104

    (43) Attr -> id [ Exp . ] = Exp
    (44) Attr -> id [ Exp . ] [ Exp ] = Exp
    (80) Factor -> id [ Exp . ]
    (81) Factor -> id [ Exp . ] [ Exp ]
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    ]               shift and go to state 149
    +               shift and go to state 56
    -               shift and go to state 57


state 105

    (56) Exp -> id addeq Term .
    (61) Term -> Term . * Factor
    (62) Term -> Term . / Factor
    (63) Term -> Term . % Factor

    +               reduce using rule 56 (Exp -> id addeq Term .)
    -               reduce using rule 56 (Exp -> id addeq Term .)
    }               reduce using rule 56 (Exp -> id addeq Term .)
    id              reduce using rule 56 (Exp -> id addeq Term .)
    gid             reduce using rule 56 (Exp -> id addeq Term .)
    return          reduce using rule 56 (Exp -> id addeq Term .)
    print           reduce using rule 56 (Exp -> id addeq Term .)
    println         reduce using rule 56 (Exp -> id addeq Term .)
    prints          reduce using rule 56 (Exp -> id addeq Term .)
    for             reduce using rule 56 (Exp -> id addeq Term .)
    while           reduce using rule 56 (Exp -> id addeq Term .)
    read            reduce using rule 56 (Exp -> id addeq Term .)
    if              reduce using rule 56 (Exp -> id addeq Term .)
    repeat          reduce using rule 56 (Exp -> id addeq Term .)
    num             reduce using rule 56 (Exp -> id addeq Term .)
    (               reduce using rule 56 (Exp -> id addeq Term .)
    )               reduce using rule 56 (Exp -> id addeq Term .)
    sup             reduce using rule 56 (Exp -> id addeq Term .)
    inf             reduce using rule 56 (Exp -> id addeq Term .)
    supeq           reduce using rule 56 (Exp -> id addeq Term .)
    infeq           reduce using rule 56 (Exp -> id addeq Term .)
    eq              reduce using rule 56 (Exp -> id addeq Term .)
    diff            reduce using rule 56 (Exp -> id addeq Term .)
    ;               reduce using rule 56 (Exp -> id addeq Term .)
    ]               reduce using rule 56 (Exp -> id addeq Term .)
    and             reduce using rule 56 (Exp -> id addeq Term .)
    or              reduce using rule 56 (Exp -> id addeq Term .)
    *               shift and go to state 84
    /               shift and go to state 85
    %               shift and go to state 86


state 106

    (57) Exp -> id subeq Term .
    (61) Term -> Term . * Factor
    (62) Term -> Term . / Factor
    (63) Term -> Term . % Factor

    +               reduce using rule 57 (Exp -> id subeq Term .)
    -               reduce using rule 57 (Exp -> id subeq Term .)
    }               reduce using rule 57 (Exp -> id subeq Term .)
    id              reduce using rule 57 (Exp -> id subeq Term .)
    gid             reduce using rule 57 (Exp -> id subeq Term .)
    return          reduce using rule 57 (Exp -> id subeq Term .)
    print           reduce using rule 57 (Exp -> id subeq Term .)
    println         reduce using rule 57 (Exp -> id subeq Term .)
    prints          reduce using rule 57 (Exp -> id subeq Term .)
    for             reduce using rule 57 (Exp -> id subeq Term .)
    while           reduce using rule 57 (Exp -> id subeq Term .)
    read            reduce using rule 57 (Exp -> id subeq Term .)
    if              reduce using rule 57 (Exp -> id subeq Term .)
    repeat          reduce using rule 57 (Exp -> id subeq Term .)
    num             reduce using rule 57 (Exp -> id subeq Term .)
    (               reduce using rule 57 (Exp -> id subeq Term .)
    )               reduce using rule 57 (Exp -> id subeq Term .)
    sup             reduce using rule 57 (Exp -> id subeq Term .)
    inf             reduce using rule 57 (Exp -> id subeq Term .)
    supeq           reduce using rule 57 (Exp -> id subeq Term .)
    infeq           reduce using rule 57 (Exp -> id subeq Term .)
    eq              reduce using rule 57 (Exp -> id subeq Term .)
    diff            reduce using rule 57 (Exp -> id subeq Term .)
    ;               reduce using rule 57 (Exp -> id subeq Term .)
    ]               reduce using rule 57 (Exp -> id subeq Term .)
    and             reduce using rule 57 (Exp -> id subeq Term .)
    or              reduce using rule 57 (Exp -> id subeq Term .)
    *               shift and go to state 84
    /               shift and go to state 85
    %               shift and go to state 86


state 107

    (58) Exp -> id addeql Term .
    (61) Term -> Term . * Factor
    (62) Term -> Term . / Factor
    (63) Term -> Term . % Factor

    +               reduce using rule 58 (Exp -> id addeql Term .)
    -               reduce using rule 58 (Exp -> id addeql Term .)
    }               reduce using rule 58 (Exp -> id addeql Term .)
    id              reduce using rule 58 (Exp -> id addeql Term .)
    gid             reduce using rule 58 (Exp -> id addeql Term .)
    return          reduce using rule 58 (Exp -> id addeql Term .)
    print           reduce using rule 58 (Exp -> id addeql Term .)
    println         reduce using rule 58 (Exp -> id addeql Term .)
    prints          reduce using rule 58 (Exp -> id addeql Term .)
    for             reduce using rule 58 (Exp -> id addeql Term .)
    while           reduce using rule 58 (Exp -> id addeql Term .)
    read            reduce using rule 58 (Exp -> id addeql Term .)
    if              reduce using rule 58 (Exp -> id addeql Term .)
    repeat          reduce using rule 58 (Exp -> id addeql Term .)
    num             reduce using rule 58 (Exp -> id addeql Term .)
    (               reduce using rule 58 (Exp -> id addeql Term .)
    )               reduce using rule 58 (Exp -> id addeql Term .)
    sup             reduce using rule 58 (Exp -> id addeql Term .)
    inf             reduce using rule 58 (Exp -> id addeql Term .)
    supeq           reduce using rule 58 (Exp -> id addeql Term .)
    infeq           reduce using rule 58 (Exp -> id addeql Term .)
    eq              reduce using rule 58 (Exp -> id addeql Term .)
    diff            reduce using rule 58 (Exp -> id addeql Term .)
    ;               reduce using rule 58 (Exp -> id addeql Term .)
    ]               reduce using rule 58 (Exp -> id addeql Term .)
    and             reduce using rule 58 (Exp -> id addeql Term .)
    or              reduce using rule 58 (Exp -> id addeql Term .)
    *               shift and go to state 84
    /               shift and go to state 85
    %               shift and go to state 86


state 108

    (59) Exp -> id subeql Term .
    (61) Term -> Term . * Factor
    (62) Term -> Term . / Factor
    (63) Term -> Term . % Factor

    +               reduce using rule 59 (Exp -> id subeql Term .)
    -               reduce using rule 59 (Exp -> id subeql Term .)
    }               reduce using rule 59 (Exp -> id subeql Term .)
    id              reduce using rule 59 (Exp -> id subeql Term .)
    gid             reduce using rule 59 (Exp -> id subeql Term .)
    return          reduce using rule 59 (Exp -> id subeql Term .)
    print           reduce using rule 59 (Exp -> id subeql Term .)
    println         reduce using rule 59 (Exp -> id subeql Term .)
    prints          reduce using rule 59 (Exp -> id subeql Term .)
    for             reduce using rule 59 (Exp -> id subeql Term .)
    while           reduce using rule 59 (Exp -> id subeql Term .)
    read            reduce using rule 59 (Exp -> id subeql Term .)
    if              reduce using rule 59 (Exp -> id subeql Term .)
    repeat          reduce using rule 59 (Exp -> id subeql Term .)
    num             reduce using rule 59 (Exp -> id subeql Term .)
    (               reduce using rule 59 (Exp -> id subeql Term .)
    )               reduce using rule 59 (Exp -> id subeql Term .)
    sup             reduce using rule 59 (Exp -> id subeql Term .)
    inf             reduce using rule 59 (Exp -> id subeql Term .)
    supeq           reduce using rule 59 (Exp -> id subeql Term .)
    infeq           reduce using rule 59 (Exp -> id subeql Term .)
    eq              reduce using rule 59 (Exp -> id subeql Term .)
    diff            reduce using rule 59 (Exp -> id subeql Term .)
    ;               reduce using rule 59 (Exp -> id subeql Term .)
    ]               reduce using rule 59 (Exp -> id subeql Term .)
    and             reduce using rule 59 (Exp -> id subeql Term .)
    or              reduce using rule 59 (Exp -> id subeql Term .)
    *               shift and go to state 84
    /               shift and go to state 85
    %               shift and go to state 86


state 109

    (71) Factor -> id . plus
    (72) Factor -> id . plusl
    (73) Factor -> id . minus
    (74) Factor -> id . minusl
    (75) Factor -> id .
    (78) Factor -> id . ( )
    (80) Factor -> id . [ Exp ]
    (81) Factor -> id . [ Exp ] [ Exp ]

  ! shift/reduce conflict for ( resolved as shift
    plus            shift and go to state 70
    plusl           shift and go to state 71
    minus           shift and go to state 72
    minusl          shift and go to state 73
    *               reduce using rule 75 (Factor -> id .)
    /               reduce using rule 75 (Factor -> id .)
    %               reduce using rule 75 (Factor -> id .)
    +               reduce using rule 75 (Factor -> id .)
    -               reduce using rule 75 (Factor -> id .)
    }               reduce using rule 75 (Factor -> id .)
    id              reduce using rule 75 (Factor -> id .)
    gid             reduce using rule 75 (Factor -> id .)
    return          reduce using rule 75 (Factor -> id .)
    print           reduce using rule 75 (Factor -> id .)
    println         reduce using rule 75 (Factor -> id .)
    prints          reduce using rule 75 (Factor -> id .)
    for             reduce using rule 75 (Factor -> id .)
    while           reduce using rule 75 (Factor -> id .)
    read            reduce using rule 75 (Factor -> id .)
    if              reduce using rule 75 (Factor -> id .)
    repeat          reduce using rule 75 (Factor -> id .)
    num             reduce using rule 75 (Factor -> id .)
    )               reduce using rule 75 (Factor -> id .)
    sup             reduce using rule 75 (Factor -> id .)
    inf             reduce using rule 75 (Factor -> id .)
    supeq           reduce using rule 75 (Factor -> id .)
    infeq           reduce using rule 75 (Factor -> id .)
    eq              reduce using rule 75 (Factor -> id .)
    diff            reduce using rule 75 (Factor -> id .)
    ;               reduce using rule 75 (Factor -> id .)
    ]               reduce using rule 75 (Factor -> id .)
    and             reduce using rule 75 (Factor -> id .)
    or              reduce using rule 75 (Factor -> id .)
    (               shift and go to state 74
    [               shift and go to state 132

  ! (               [ reduce using rule 75 (Factor -> id .) ]


state 110

    (64) Term -> id muleq Factor .

    *               reduce using rule 64 (Term -> id muleq Factor .)
    /               reduce using rule 64 (Term -> id muleq Factor .)
    %               reduce using rule 64 (Term -> id muleq Factor .)
    +               reduce using rule 64 (Term -> id muleq Factor .)
    -               reduce using rule 64 (Term -> id muleq Factor .)
    }               reduce using rule 64 (Term -> id muleq Factor .)
    id              reduce using rule 64 (Term -> id muleq Factor .)
    gid             reduce using rule 64 (Term -> id muleq Factor .)
    return          reduce using rule 64 (Term -> id muleq Factor .)
    print           reduce using rule 64 (Term -> id muleq Factor .)
    println         reduce using rule 64 (Term -> id muleq Factor .)
    prints          reduce using rule 64 (Term -> id muleq Factor .)
    for             reduce using rule 64 (Term -> id muleq Factor .)
    while           reduce using rule 64 (Term -> id muleq Factor .)
    read            reduce using rule 64 (Term -> id muleq Factor .)
    if              reduce using rule 64 (Term -> id muleq Factor .)
    repeat          reduce using rule 64 (Term -> id muleq Factor .)
    num             reduce using rule 64 (Term -> id muleq Factor .)
    (               reduce using rule 64 (Term -> id muleq Factor .)
    )               reduce using rule 64 (Term -> id muleq Factor .)
    sup             reduce using rule 64 (Term -> id muleq Factor .)
    inf             reduce using rule 64 (Term -> id muleq Factor .)
    supeq           reduce using rule 64 (Term -> id muleq Factor .)
    infeq           reduce using rule 64 (Term -> id muleq Factor .)
    eq              reduce using rule 64 (Term -> id muleq Factor .)
    diff            reduce using rule 64 (Term -> id muleq Factor .)
    ;               reduce using rule 64 (Term -> id muleq Factor .)
    ]               reduce using rule 64 (Term -> id muleq Factor .)
    and             reduce using rule 64 (Term -> id muleq Factor .)
    or              reduce using rule 64 (Term -> id muleq Factor .)


state 111

    (65) Term -> id diveq Factor .

    *               reduce using rule 65 (Term -> id diveq Factor .)
    /               reduce using rule 65 (Term -> id diveq Factor .)
    %               reduce using rule 65 (Term -> id diveq Factor .)
    +               reduce using rule 65 (Term -> id diveq Factor .)
    -               reduce using rule 65 (Term -> id diveq Factor .)
    }               reduce using rule 65 (Term -> id diveq Factor .)
    id              reduce using rule 65 (Term -> id diveq Factor .)
    gid             reduce using rule 65 (Term -> id diveq Factor .)
    return          reduce using rule 65 (Term -> id diveq Factor .)
    print           reduce using rule 65 (Term -> id diveq Factor .)
    println         reduce using rule 65 (Term -> id diveq Factor .)
    prints          reduce using rule 65 (Term -> id diveq Factor .)
    for             reduce using rule 65 (Term -> id diveq Factor .)
    while           reduce using rule 65 (Term -> id diveq Factor .)
    read            reduce using rule 65 (Term -> id diveq Factor .)
    if              reduce using rule 65 (Term -> id diveq Factor .)
    repeat          reduce using rule 65 (Term -> id diveq Factor .)
    num             reduce using rule 65 (Term -> id diveq Factor .)
    (               reduce using rule 65 (Term -> id diveq Factor .)
    )               reduce using rule 65 (Term -> id diveq Factor .)
    sup             reduce using rule 65 (Term -> id diveq Factor .)
    inf             reduce using rule 65 (Term -> id diveq Factor .)
    supeq           reduce using rule 65 (Term -> id diveq Factor .)
    infeq           reduce using rule 65 (Term -> id diveq Factor .)
    eq              reduce using rule 65 (Term -> id diveq Factor .)
    diff            reduce using rule 65 (Term -> id diveq Factor .)
    ;               reduce using rule 65 (Term -> id diveq Factor .)
    ]               reduce using rule 65 (Term -> id diveq Factor .)
    and             reduce using rule 65 (Term -> id diveq Factor .)
    or              reduce using rule 65 (Term -> id diveq Factor .)


state 112

    (66) Term -> id modeq Factor .

    *               reduce using rule 66 (Term -> id modeq Factor .)
    /               reduce using rule 66 (Term -> id modeq Factor .)
    %               reduce using rule 66 (Term -> id modeq Factor .)
    +               reduce using rule 66 (Term -> id modeq Factor .)
    -               reduce using rule 66 (Term -> id modeq Factor .)
    }               reduce using rule 66 (Term -> id modeq Factor .)
    id              reduce using rule 66 (Term -> id modeq Factor .)
    gid             reduce using rule 66 (Term -> id modeq Factor .)
    return          reduce using rule 66 (Term -> id modeq Factor .)
    print           reduce using rule 66 (Term -> id modeq Factor .)
    println         reduce using rule 66 (Term -> id modeq Factor .)
    prints          reduce using rule 66 (Term -> id modeq Factor .)
    for             reduce using rule 66 (Term -> id modeq Factor .)
    while           reduce using rule 66 (Term -> id modeq Factor .)
    read            reduce using rule 66 (Term -> id modeq Factor .)
    if              reduce using rule 66 (Term -> id modeq Factor .)
    repeat          reduce using rule 66 (Term -> id modeq Factor .)
    num             reduce using rule 66 (Term -> id modeq Factor .)
    (               reduce using rule 66 (Term -> id modeq Factor .)
    )               reduce using rule 66 (Term -> id modeq Factor .)
    sup             reduce using rule 66 (Term -> id modeq Factor .)
    inf             reduce using rule 66 (Term -> id modeq Factor .)
    supeq           reduce using rule 66 (Term -> id modeq Factor .)
    infeq           reduce using rule 66 (Term -> id modeq Factor .)
    eq              reduce using rule 66 (Term -> id modeq Factor .)
    diff            reduce using rule 66 (Term -> id modeq Factor .)
    ;               reduce using rule 66 (Term -> id modeq Factor .)
    ]               reduce using rule 66 (Term -> id modeq Factor .)
    and             reduce using rule 66 (Term -> id modeq Factor .)
    or              reduce using rule 66 (Term -> id modeq Factor .)


state 113

    (67) Term -> id muleql Factor .

    *               reduce using rule 67 (Term -> id muleql Factor .)
    /               reduce using rule 67 (Term -> id muleql Factor .)
    %               reduce using rule 67 (Term -> id muleql Factor .)
    +               reduce using rule 67 (Term -> id muleql Factor .)
    -               reduce using rule 67 (Term -> id muleql Factor .)
    }               reduce using rule 67 (Term -> id muleql Factor .)
    id              reduce using rule 67 (Term -> id muleql Factor .)
    gid             reduce using rule 67 (Term -> id muleql Factor .)
    return          reduce using rule 67 (Term -> id muleql Factor .)
    print           reduce using rule 67 (Term -> id muleql Factor .)
    println         reduce using rule 67 (Term -> id muleql Factor .)
    prints          reduce using rule 67 (Term -> id muleql Factor .)
    for             reduce using rule 67 (Term -> id muleql Factor .)
    while           reduce using rule 67 (Term -> id muleql Factor .)
    read            reduce using rule 67 (Term -> id muleql Factor .)
    if              reduce using rule 67 (Term -> id muleql Factor .)
    repeat          reduce using rule 67 (Term -> id muleql Factor .)
    num             reduce using rule 67 (Term -> id muleql Factor .)
    (               reduce using rule 67 (Term -> id muleql Factor .)
    )               reduce using rule 67 (Term -> id muleql Factor .)
    sup             reduce using rule 67 (Term -> id muleql Factor .)
    inf             reduce using rule 67 (Term -> id muleql Factor .)
    supeq           reduce using rule 67 (Term -> id muleql Factor .)
    infeq           reduce using rule 67 (Term -> id muleql Factor .)
    eq              reduce using rule 67 (Term -> id muleql Factor .)
    diff            reduce using rule 67 (Term -> id muleql Factor .)
    ;               reduce using rule 67 (Term -> id muleql Factor .)
    ]               reduce using rule 67 (Term -> id muleql Factor .)
    and             reduce using rule 67 (Term -> id muleql Factor .)
    or              reduce using rule 67 (Term -> id muleql Factor .)


state 114

    (68) Term -> id diveql Factor .

    *               reduce using rule 68 (Term -> id diveql Factor .)
    /               reduce using rule 68 (Term -> id diveql Factor .)
    %               reduce using rule 68 (Term -> id diveql Factor .)
    +               reduce using rule 68 (Term -> id diveql Factor .)
    -               reduce using rule 68 (Term -> id diveql Factor .)
    }               reduce using rule 68 (Term -> id diveql Factor .)
    id              reduce using rule 68 (Term -> id diveql Factor .)
    gid             reduce using rule 68 (Term -> id diveql Factor .)
    return          reduce using rule 68 (Term -> id diveql Factor .)
    print           reduce using rule 68 (Term -> id diveql Factor .)
    println         reduce using rule 68 (Term -> id diveql Factor .)
    prints          reduce using rule 68 (Term -> id diveql Factor .)
    for             reduce using rule 68 (Term -> id diveql Factor .)
    while           reduce using rule 68 (Term -> id diveql Factor .)
    read            reduce using rule 68 (Term -> id diveql Factor .)
    if              reduce using rule 68 (Term -> id diveql Factor .)
    repeat          reduce using rule 68 (Term -> id diveql Factor .)
    num             reduce using rule 68 (Term -> id diveql Factor .)
    (               reduce using rule 68 (Term -> id diveql Factor .)
    )               reduce using rule 68 (Term -> id diveql Factor .)
    sup             reduce using rule 68 (Term -> id diveql Factor .)
    inf             reduce using rule 68 (Term -> id diveql Factor .)
    supeq           reduce using rule 68 (Term -> id diveql Factor .)
    infeq           reduce using rule 68 (Term -> id diveql Factor .)
    eq              reduce using rule 68 (Term -> id diveql Factor .)
    diff            reduce using rule 68 (Term -> id diveql Factor .)
    ;               reduce using rule 68 (Term -> id diveql Factor .)
    ]               reduce using rule 68 (Term -> id diveql Factor .)
    and             reduce using rule 68 (Term -> id diveql Factor .)
    or              reduce using rule 68 (Term -> id diveql Factor .)


state 115

    (69) Term -> id modeql Factor .

    *               reduce using rule 69 (Term -> id modeql Factor .)
    /               reduce using rule 69 (Term -> id modeql Factor .)
    %               reduce using rule 69 (Term -> id modeql Factor .)
    +               reduce using rule 69 (Term -> id modeql Factor .)
    -               reduce using rule 69 (Term -> id modeql Factor .)
    }               reduce using rule 69 (Term -> id modeql Factor .)
    id              reduce using rule 69 (Term -> id modeql Factor .)
    gid             reduce using rule 69 (Term -> id modeql Factor .)
    return          reduce using rule 69 (Term -> id modeql Factor .)
    print           reduce using rule 69 (Term -> id modeql Factor .)
    println         reduce using rule 69 (Term -> id modeql Factor .)
    prints          reduce using rule 69 (Term -> id modeql Factor .)
    for             reduce using rule 69 (Term -> id modeql Factor .)
    while           reduce using rule 69 (Term -> id modeql Factor .)
    read            reduce using rule 69 (Term -> id modeql Factor .)
    if              reduce using rule 69 (Term -> id modeql Factor .)
    repeat          reduce using rule 69 (Term -> id modeql Factor .)
    num             reduce using rule 69 (Term -> id modeql Factor .)
    (               reduce using rule 69 (Term -> id modeql Factor .)
    )               reduce using rule 69 (Term -> id modeql Factor .)
    sup             reduce using rule 69 (Term -> id modeql Factor .)
    inf             reduce using rule 69 (Term -> id modeql Factor .)
    supeq           reduce using rule 69 (Term -> id modeql Factor .)
    infeq           reduce using rule 69 (Term -> id modeql Factor .)
    eq              reduce using rule 69 (Term -> id modeql Factor .)
    diff            reduce using rule 69 (Term -> id modeql Factor .)
    ;               reduce using rule 69 (Term -> id modeql Factor .)
    ]               reduce using rule 69 (Term -> id modeql Factor .)
    and             reduce using rule 69 (Term -> id modeql Factor .)
    or              reduce using rule 69 (Term -> id modeql Factor .)


state 116

    (78) Factor -> id ( ) .

    *               reduce using rule 78 (Factor -> id ( ) .)
    /               reduce using rule 78 (Factor -> id ( ) .)
    %               reduce using rule 78 (Factor -> id ( ) .)
    +               reduce using rule 78 (Factor -> id ( ) .)
    -               reduce using rule 78 (Factor -> id ( ) .)
    }               reduce using rule 78 (Factor -> id ( ) .)
    id              reduce using rule 78 (Factor -> id ( ) .)
    gid             reduce using rule 78 (Factor -> id ( ) .)
    return          reduce using rule 78 (Factor -> id ( ) .)
    print           reduce using rule 78 (Factor -> id ( ) .)
    println         reduce using rule 78 (Factor -> id ( ) .)
    prints          reduce using rule 78 (Factor -> id ( ) .)
    for             reduce using rule 78 (Factor -> id ( ) .)
    while           reduce using rule 78 (Factor -> id ( ) .)
    read            reduce using rule 78 (Factor -> id ( ) .)
    if              reduce using rule 78 (Factor -> id ( ) .)
    repeat          reduce using rule 78 (Factor -> id ( ) .)
    num             reduce using rule 78 (Factor -> id ( ) .)
    (               reduce using rule 78 (Factor -> id ( ) .)
    )               reduce using rule 78 (Factor -> id ( ) .)
    sup             reduce using rule 78 (Factor -> id ( ) .)
    inf             reduce using rule 78 (Factor -> id ( ) .)
    supeq           reduce using rule 78 (Factor -> id ( ) .)
    infeq           reduce using rule 78 (Factor -> id ( ) .)
    eq              reduce using rule 78 (Factor -> id ( ) .)
    diff            reduce using rule 78 (Factor -> id ( ) .)
    ;               reduce using rule 78 (Factor -> id ( ) .)
    ]               reduce using rule 78 (Factor -> id ( ) .)
    and             reduce using rule 78 (Factor -> id ( ) .)
    or              reduce using rule 78 (Factor -> id ( ) .)


state 117

    (45) Attr -> gid = Exp .
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    }               reduce using rule 45 (Attr -> gid = Exp .)
    id              reduce using rule 45 (Attr -> gid = Exp .)
    gid             reduce using rule 45 (Attr -> gid = Exp .)
    return          reduce using rule 45 (Attr -> gid = Exp .)
    print           reduce using rule 45 (Attr -> gid = Exp .)
    println         reduce using rule 45 (Attr -> gid = Exp .)
    prints          reduce using rule 45 (Attr -> gid = Exp .)
    for             reduce using rule 45 (Attr -> gid = Exp .)
    while           reduce using rule 45 (Attr -> gid = Exp .)
    read            reduce using rule 45 (Attr -> gid = Exp .)
    if              reduce using rule 45 (Attr -> gid = Exp .)
    repeat          reduce using rule 45 (Attr -> gid = Exp .)
    num             reduce using rule 45 (Attr -> gid = Exp .)
    (               reduce using rule 45 (Attr -> gid = Exp .)
    ;               reduce using rule 45 (Attr -> gid = Exp .)
    )               reduce using rule 45 (Attr -> gid = Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 118

    (46) Attr -> gid [ Exp . ] = Exp
    (47) Attr -> gid [ Exp . ] [ Exp ] = Exp
    (82) Factor -> gid [ Exp . ]
    (83) Factor -> gid [ Exp . ] [ Exp ]
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    ]               shift and go to state 150
    +               shift and go to state 56
    -               shift and go to state 57


state 119

    (48) Return -> return ( Exp . )
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    )               shift and go to state 151
    +               shift and go to state 56
    -               shift and go to state 57


state 120

    (90) Cond -> ( Cond . and Cond )
    (91) Cond -> ( Cond . or Cond )
    (79) Factor -> ( Cond . )
    (88) Cond -> Cond . and Cond
    (89) Cond -> Cond . or Cond

    and             shift and go to state 152
    or              shift and go to state 153
    )               shift and go to state 121


state 121

    (79) Factor -> ( Cond ) .

    *               reduce using rule 79 (Factor -> ( Cond ) .)
    /               reduce using rule 79 (Factor -> ( Cond ) .)
    %               reduce using rule 79 (Factor -> ( Cond ) .)
    +               reduce using rule 79 (Factor -> ( Cond ) .)
    -               reduce using rule 79 (Factor -> ( Cond ) .)
    }               reduce using rule 79 (Factor -> ( Cond ) .)
    id              reduce using rule 79 (Factor -> ( Cond ) .)
    gid             reduce using rule 79 (Factor -> ( Cond ) .)
    return          reduce using rule 79 (Factor -> ( Cond ) .)
    print           reduce using rule 79 (Factor -> ( Cond ) .)
    println         reduce using rule 79 (Factor -> ( Cond ) .)
    prints          reduce using rule 79 (Factor -> ( Cond ) .)
    for             reduce using rule 79 (Factor -> ( Cond ) .)
    while           reduce using rule 79 (Factor -> ( Cond ) .)
    read            reduce using rule 79 (Factor -> ( Cond ) .)
    if              reduce using rule 79 (Factor -> ( Cond ) .)
    repeat          reduce using rule 79 (Factor -> ( Cond ) .)
    num             reduce using rule 79 (Factor -> ( Cond ) .)
    (               reduce using rule 79 (Factor -> ( Cond ) .)
    )               reduce using rule 79 (Factor -> ( Cond ) .)
    sup             reduce using rule 79 (Factor -> ( Cond ) .)
    inf             reduce using rule 79 (Factor -> ( Cond ) .)
    supeq           reduce using rule 79 (Factor -> ( Cond ) .)
    infeq           reduce using rule 79 (Factor -> ( Cond ) .)
    eq              reduce using rule 79 (Factor -> ( Cond ) .)
    diff            reduce using rule 79 (Factor -> ( Cond ) .)
    ;               reduce using rule 79 (Factor -> ( Cond ) .)
    ]               reduce using rule 79 (Factor -> ( Cond ) .)
    and             reduce using rule 79 (Factor -> ( Cond ) .)
    or              reduce using rule 79 (Factor -> ( Cond ) .)


state 122

    (88) Cond -> Cond and . Cond
    (88) Cond -> . Cond and Cond
    (89) Cond -> . Cond or Cond
    (90) Cond -> . ( Cond and Cond )
    (91) Cond -> . ( Cond or Cond )
    (92) Cond -> . Exp sup Exp
    (93) Cond -> . Exp inf Exp
    (94) Cond -> . Exp supeq Exp
    (95) Cond -> . Exp infeq Exp
    (96) Cond -> . not Exp
    (97) Cond -> . Exp eq Exp
    (98) Cond -> . Exp diff Exp
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    (               shift and go to state 78
    not             shift and go to state 81
    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45

    Cond                           shift and go to state 154
    Exp                            shift and go to state 143
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 123

    (89) Cond -> Cond or . Cond
    (88) Cond -> . Cond and Cond
    (89) Cond -> . Cond or Cond
    (90) Cond -> . ( Cond and Cond )
    (91) Cond -> . ( Cond or Cond )
    (92) Cond -> . Exp sup Exp
    (93) Cond -> . Exp inf Exp
    (94) Cond -> . Exp supeq Exp
    (95) Cond -> . Exp infeq Exp
    (96) Cond -> . not Exp
    (97) Cond -> . Exp eq Exp
    (98) Cond -> . Exp diff Exp
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    (               shift and go to state 78
    not             shift and go to state 81
    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45

    Cond                           shift and go to state 155
    Exp                            shift and go to state 143
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 124

    (84) Factor -> ( Exp ) .

    *               reduce using rule 84 (Factor -> ( Exp ) .)
    /               reduce using rule 84 (Factor -> ( Exp ) .)
    %               reduce using rule 84 (Factor -> ( Exp ) .)
    +               reduce using rule 84 (Factor -> ( Exp ) .)
    -               reduce using rule 84 (Factor -> ( Exp ) .)
    }               reduce using rule 84 (Factor -> ( Exp ) .)
    id              reduce using rule 84 (Factor -> ( Exp ) .)
    gid             reduce using rule 84 (Factor -> ( Exp ) .)
    return          reduce using rule 84 (Factor -> ( Exp ) .)
    print           reduce using rule 84 (Factor -> ( Exp ) .)
    println         reduce using rule 84 (Factor -> ( Exp ) .)
    prints          reduce using rule 84 (Factor -> ( Exp ) .)
    for             reduce using rule 84 (Factor -> ( Exp ) .)
    while           reduce using rule 84 (Factor -> ( Exp ) .)
    read            reduce using rule 84 (Factor -> ( Exp ) .)
    if              reduce using rule 84 (Factor -> ( Exp ) .)
    repeat          reduce using rule 84 (Factor -> ( Exp ) .)
    num             reduce using rule 84 (Factor -> ( Exp ) .)
    (               reduce using rule 84 (Factor -> ( Exp ) .)
    )               reduce using rule 84 (Factor -> ( Exp ) .)
    sup             reduce using rule 84 (Factor -> ( Exp ) .)
    inf             reduce using rule 84 (Factor -> ( Exp ) .)
    supeq           reduce using rule 84 (Factor -> ( Exp ) .)
    infeq           reduce using rule 84 (Factor -> ( Exp ) .)
    eq              reduce using rule 84 (Factor -> ( Exp ) .)
    diff            reduce using rule 84 (Factor -> ( Exp ) .)
    ;               reduce using rule 84 (Factor -> ( Exp ) .)
    ]               reduce using rule 84 (Factor -> ( Exp ) .)
    and             reduce using rule 84 (Factor -> ( Exp ) .)
    or              reduce using rule 84 (Factor -> ( Exp ) .)


state 125

    (92) Cond -> Exp sup . Exp
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 156
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 126

    (93) Cond -> Exp inf . Exp
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 157
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 127

    (94) Cond -> Exp supeq . Exp
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 158
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 128

    (95) Cond -> Exp infeq . Exp
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 159
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 129

    (97) Cond -> Exp eq . Exp
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 160
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 130

    (98) Cond -> Exp diff . Exp
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 161
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 131

    (96) Cond -> not Exp .
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    )               reduce using rule 96 (Cond -> not Exp .)
    and             reduce using rule 96 (Cond -> not Exp .)
    or              reduce using rule 96 (Cond -> not Exp .)
    ;               reduce using rule 96 (Cond -> not Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 132

    (80) Factor -> id [ . Exp ]
    (81) Factor -> id [ . Exp ] [ Exp ]
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 162
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 133

    (82) Factor -> gid [ . Exp ]
    (83) Factor -> gid [ . Exp ] [ Exp ]
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 163
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 134

    (61) Term -> Term * Factor .

    *               reduce using rule 61 (Term -> Term * Factor .)
    /               reduce using rule 61 (Term -> Term * Factor .)
    %               reduce using rule 61 (Term -> Term * Factor .)
    +               reduce using rule 61 (Term -> Term * Factor .)
    -               reduce using rule 61 (Term -> Term * Factor .)
    }               reduce using rule 61 (Term -> Term * Factor .)
    id              reduce using rule 61 (Term -> Term * Factor .)
    gid             reduce using rule 61 (Term -> Term * Factor .)
    return          reduce using rule 61 (Term -> Term * Factor .)
    print           reduce using rule 61 (Term -> Term * Factor .)
    println         reduce using rule 61 (Term -> Term * Factor .)
    prints          reduce using rule 61 (Term -> Term * Factor .)
    for             reduce using rule 61 (Term -> Term * Factor .)
    while           reduce using rule 61 (Term -> Term * Factor .)
    read            reduce using rule 61 (Term -> Term * Factor .)
    if              reduce using rule 61 (Term -> Term * Factor .)
    repeat          reduce using rule 61 (Term -> Term * Factor .)
    num             reduce using rule 61 (Term -> Term * Factor .)
    (               reduce using rule 61 (Term -> Term * Factor .)
    )               reduce using rule 61 (Term -> Term * Factor .)
    sup             reduce using rule 61 (Term -> Term * Factor .)
    inf             reduce using rule 61 (Term -> Term * Factor .)
    supeq           reduce using rule 61 (Term -> Term * Factor .)
    infeq           reduce using rule 61 (Term -> Term * Factor .)
    eq              reduce using rule 61 (Term -> Term * Factor .)
    diff            reduce using rule 61 (Term -> Term * Factor .)
    ;               reduce using rule 61 (Term -> Term * Factor .)
    ]               reduce using rule 61 (Term -> Term * Factor .)
    and             reduce using rule 61 (Term -> Term * Factor .)
    or              reduce using rule 61 (Term -> Term * Factor .)


state 135

    (62) Term -> Term / Factor .

    *               reduce using rule 62 (Term -> Term / Factor .)
    /               reduce using rule 62 (Term -> Term / Factor .)
    %               reduce using rule 62 (Term -> Term / Factor .)
    +               reduce using rule 62 (Term -> Term / Factor .)
    -               reduce using rule 62 (Term -> Term / Factor .)
    }               reduce using rule 62 (Term -> Term / Factor .)
    id              reduce using rule 62 (Term -> Term / Factor .)
    gid             reduce using rule 62 (Term -> Term / Factor .)
    return          reduce using rule 62 (Term -> Term / Factor .)
    print           reduce using rule 62 (Term -> Term / Factor .)
    println         reduce using rule 62 (Term -> Term / Factor .)
    prints          reduce using rule 62 (Term -> Term / Factor .)
    for             reduce using rule 62 (Term -> Term / Factor .)
    while           reduce using rule 62 (Term -> Term / Factor .)
    read            reduce using rule 62 (Term -> Term / Factor .)
    if              reduce using rule 62 (Term -> Term / Factor .)
    repeat          reduce using rule 62 (Term -> Term / Factor .)
    num             reduce using rule 62 (Term -> Term / Factor .)
    (               reduce using rule 62 (Term -> Term / Factor .)
    )               reduce using rule 62 (Term -> Term / Factor .)
    sup             reduce using rule 62 (Term -> Term / Factor .)
    inf             reduce using rule 62 (Term -> Term / Factor .)
    supeq           reduce using rule 62 (Term -> Term / Factor .)
    infeq           reduce using rule 62 (Term -> Term / Factor .)
    eq              reduce using rule 62 (Term -> Term / Factor .)
    diff            reduce using rule 62 (Term -> Term / Factor .)
    ;               reduce using rule 62 (Term -> Term / Factor .)
    ]               reduce using rule 62 (Term -> Term / Factor .)
    and             reduce using rule 62 (Term -> Term / Factor .)
    or              reduce using rule 62 (Term -> Term / Factor .)


state 136

    (63) Term -> Term % Factor .

    *               reduce using rule 63 (Term -> Term % Factor .)
    /               reduce using rule 63 (Term -> Term % Factor .)
    %               reduce using rule 63 (Term -> Term % Factor .)
    +               reduce using rule 63 (Term -> Term % Factor .)
    -               reduce using rule 63 (Term -> Term % Factor .)
    }               reduce using rule 63 (Term -> Term % Factor .)
    id              reduce using rule 63 (Term -> Term % Factor .)
    gid             reduce using rule 63 (Term -> Term % Factor .)
    return          reduce using rule 63 (Term -> Term % Factor .)
    print           reduce using rule 63 (Term -> Term % Factor .)
    println         reduce using rule 63 (Term -> Term % Factor .)
    prints          reduce using rule 63 (Term -> Term % Factor .)
    for             reduce using rule 63 (Term -> Term % Factor .)
    while           reduce using rule 63 (Term -> Term % Factor .)
    read            reduce using rule 63 (Term -> Term % Factor .)
    if              reduce using rule 63 (Term -> Term % Factor .)
    repeat          reduce using rule 63 (Term -> Term % Factor .)
    num             reduce using rule 63 (Term -> Term % Factor .)
    (               reduce using rule 63 (Term -> Term % Factor .)
    )               reduce using rule 63 (Term -> Term % Factor .)
    sup             reduce using rule 63 (Term -> Term % Factor .)
    inf             reduce using rule 63 (Term -> Term % Factor .)
    supeq           reduce using rule 63 (Term -> Term % Factor .)
    infeq           reduce using rule 63 (Term -> Term % Factor .)
    eq              reduce using rule 63 (Term -> Term % Factor .)
    diff            reduce using rule 63 (Term -> Term % Factor .)
    ;               reduce using rule 63 (Term -> Term % Factor .)
    ]               reduce using rule 63 (Term -> Term % Factor .)
    and             reduce using rule 63 (Term -> Term % Factor .)
    or              reduce using rule 63 (Term -> Term % Factor .)


state 137

    (31) Print -> print ( Exp . )
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    )               shift and go to state 164
    +               shift and go to state 56
    -               shift and go to state 57


state 138

    (32) Println -> println ( Exp . )
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    )               shift and go to state 165
    +               shift and go to state 56
    -               shift and go to state 57


state 139

    (33) Prints -> prints ( string . )

    )               shift and go to state 166


state 140

    (26) Repeat -> RepeatS ( num . ) { Insts }

    )               shift and go to state 167


state 141

    (28) For -> for ( Insts . ; Cond ; Insts ) { Insts }
    (13) Insts -> Insts . Inst
    (15) Inst -> . Attr
    (16) Inst -> . Return
    (17) Inst -> . Exp
    (18) Inst -> . Print
    (19) Inst -> . Println
    (20) Inst -> . Prints
    (21) Inst -> . Repeat
    (22) Inst -> . For
    (23) Inst -> . While
    (24) Inst -> . Read
    (25) Inst -> . If
    (42) Attr -> . id = Exp
    (43) Attr -> . id [ Exp ] = Exp
    (44) Attr -> . id [ Exp ] [ Exp ] = Exp
    (45) Attr -> . gid = Exp
    (46) Attr -> . gid [ Exp ] = Exp
    (47) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (48) Return -> . return ( Exp )
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (31) Print -> . print ( Exp )
    (32) Println -> . println ( Exp )
    (33) Prints -> . prints ( string )
    (26) Repeat -> . RepeatS ( num ) { Insts }
    (28) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (29) While -> . while ( Cond ) { Insts }
    (30) Read -> . read ( id )
    (49) If -> . if ( Cond ) { Insts }
    (50) If -> . if ( Cond ) Inst
    (52) If -> . if ( Cond ) { Insts } else { Insts }
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (27) RepeatS -> . repeat
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    ;               shift and go to state 168
    id              shift and go to state 36
    gid             shift and go to state 37
    return          shift and go to state 38
    print           shift and go to state 41
    println         shift and go to state 42
    prints          shift and go to state 43
    for             shift and go to state 46
    while           shift and go to state 47
    read            shift and go to state 48
    if              shift and go to state 49
    repeat          shift and go to state 51
    num             shift and go to state 45
    (               shift and go to state 39

    Inst                           shift and go to state 24
    Attr                           shift and go to state 25
    Return                         shift and go to state 26
    Exp                            shift and go to state 27
    Print                          shift and go to state 28
    Println                        shift and go to state 29
    Prints                         shift and go to state 30
    Repeat                         shift and go to state 31
    For                            shift and go to state 32
    While                          shift and go to state 33
    Read                           shift and go to state 34
    If                             shift and go to state 35
    Term                           shift and go to state 40
    RepeatS                        shift and go to state 44
    Factor                         shift and go to state 50

state 142

    (29) While -> while ( Cond . ) { Insts }
    (88) Cond -> Cond . and Cond
    (89) Cond -> Cond . or Cond

    )               shift and go to state 169
    and             shift and go to state 122
    or              shift and go to state 123


state 143

    (92) Cond -> Exp . sup Exp
    (93) Cond -> Exp . inf Exp
    (94) Cond -> Exp . supeq Exp
    (95) Cond -> Exp . infeq Exp
    (97) Cond -> Exp . eq Exp
    (98) Cond -> Exp . diff Exp
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    sup             shift and go to state 125
    inf             shift and go to state 126
    supeq           shift and go to state 127
    infeq           shift and go to state 128
    eq              shift and go to state 129
    diff            shift and go to state 130
    +               shift and go to state 56
    -               shift and go to state 57


state 144

    (30) Read -> read ( id . )

    )               shift and go to state 170


state 145

    (49) If -> if ( Cond . ) { Insts }
    (50) If -> if ( Cond . ) Inst
    (52) If -> if ( Cond . ) { Insts } else { Insts }
    (88) Cond -> Cond . and Cond
    (89) Cond -> Cond . or Cond

    )               shift and go to state 171
    and             shift and go to state 122
    or              shift and go to state 123


state 146

    (34) Dcl -> int id [ num . ]
    (35) Dcl -> int id [ num . ] [ num ]

    ]               shift and go to state 172


state 147

    (37) Dcl -> int id = num .

    int             reduce using rule 37 (Dcl -> int id = num .)
    }               reduce using rule 37 (Dcl -> int id = num .)
    id              reduce using rule 37 (Dcl -> int id = num .)
    gid             reduce using rule 37 (Dcl -> int id = num .)
    return          reduce using rule 37 (Dcl -> int id = num .)
    print           reduce using rule 37 (Dcl -> int id = num .)
    println         reduce using rule 37 (Dcl -> int id = num .)
    prints          reduce using rule 37 (Dcl -> int id = num .)
    for             reduce using rule 37 (Dcl -> int id = num .)
    while           reduce using rule 37 (Dcl -> int id = num .)
    read            reduce using rule 37 (Dcl -> int id = num .)
    if              reduce using rule 37 (Dcl -> int id = num .)
    repeat          reduce using rule 37 (Dcl -> int id = num .)
    num             reduce using rule 37 (Dcl -> int id = num .)
    (               reduce using rule 37 (Dcl -> int id = num .)


state 148

    (38) DclGlobal -> int id [ num ] .
    (39) DclGlobal -> int id [ num ] . [ num ]

    }               reduce using rule 38 (DclGlobal -> int id [ num ] .)
    int             reduce using rule 38 (DclGlobal -> int id [ num ] .)
    [               shift and go to state 173


state 149

    (43) Attr -> id [ Exp ] . = Exp
    (44) Attr -> id [ Exp ] . [ Exp ] = Exp
    (80) Factor -> id [ Exp ] .
    (81) Factor -> id [ Exp ] . [ Exp ]

    =               shift and go to state 175
    [               shift and go to state 174
    *               reduce using rule 80 (Factor -> id [ Exp ] .)
    /               reduce using rule 80 (Factor -> id [ Exp ] .)
    %               reduce using rule 80 (Factor -> id [ Exp ] .)
    +               reduce using rule 80 (Factor -> id [ Exp ] .)
    -               reduce using rule 80 (Factor -> id [ Exp ] .)
    }               reduce using rule 80 (Factor -> id [ Exp ] .)
    id              reduce using rule 80 (Factor -> id [ Exp ] .)
    gid             reduce using rule 80 (Factor -> id [ Exp ] .)
    return          reduce using rule 80 (Factor -> id [ Exp ] .)
    print           reduce using rule 80 (Factor -> id [ Exp ] .)
    println         reduce using rule 80 (Factor -> id [ Exp ] .)
    prints          reduce using rule 80 (Factor -> id [ Exp ] .)
    for             reduce using rule 80 (Factor -> id [ Exp ] .)
    while           reduce using rule 80 (Factor -> id [ Exp ] .)
    read            reduce using rule 80 (Factor -> id [ Exp ] .)
    if              reduce using rule 80 (Factor -> id [ Exp ] .)
    repeat          reduce using rule 80 (Factor -> id [ Exp ] .)
    num             reduce using rule 80 (Factor -> id [ Exp ] .)
    (               reduce using rule 80 (Factor -> id [ Exp ] .)
    ;               reduce using rule 80 (Factor -> id [ Exp ] .)
    )               reduce using rule 80 (Factor -> id [ Exp ] .)


state 150

    (46) Attr -> gid [ Exp ] . = Exp
    (47) Attr -> gid [ Exp ] . [ Exp ] = Exp
    (82) Factor -> gid [ Exp ] .
    (83) Factor -> gid [ Exp ] . [ Exp ]

    =               shift and go to state 177
    [               shift and go to state 176
    *               reduce using rule 82 (Factor -> gid [ Exp ] .)
    /               reduce using rule 82 (Factor -> gid [ Exp ] .)
    %               reduce using rule 82 (Factor -> gid [ Exp ] .)
    +               reduce using rule 82 (Factor -> gid [ Exp ] .)
    -               reduce using rule 82 (Factor -> gid [ Exp ] .)
    }               reduce using rule 82 (Factor -> gid [ Exp ] .)
    id              reduce using rule 82 (Factor -> gid [ Exp ] .)
    gid             reduce using rule 82 (Factor -> gid [ Exp ] .)
    return          reduce using rule 82 (Factor -> gid [ Exp ] .)
    print           reduce using rule 82 (Factor -> gid [ Exp ] .)
    println         reduce using rule 82 (Factor -> gid [ Exp ] .)
    prints          reduce using rule 82 (Factor -> gid [ Exp ] .)
    for             reduce using rule 82 (Factor -> gid [ Exp ] .)
    while           reduce using rule 82 (Factor -> gid [ Exp ] .)
    read            reduce using rule 82 (Factor -> gid [ Exp ] .)
    if              reduce using rule 82 (Factor -> gid [ Exp ] .)
    repeat          reduce using rule 82 (Factor -> gid [ Exp ] .)
    num             reduce using rule 82 (Factor -> gid [ Exp ] .)
    (               reduce using rule 82 (Factor -> gid [ Exp ] .)
    ;               reduce using rule 82 (Factor -> gid [ Exp ] .)
    )               reduce using rule 82 (Factor -> gid [ Exp ] .)


state 151

    (48) Return -> return ( Exp ) .

    }               reduce using rule 48 (Return -> return ( Exp ) .)
    id              reduce using rule 48 (Return -> return ( Exp ) .)
    gid             reduce using rule 48 (Return -> return ( Exp ) .)
    return          reduce using rule 48 (Return -> return ( Exp ) .)
    print           reduce using rule 48 (Return -> return ( Exp ) .)
    println         reduce using rule 48 (Return -> return ( Exp ) .)
    prints          reduce using rule 48 (Return -> return ( Exp ) .)
    for             reduce using rule 48 (Return -> return ( Exp ) .)
    while           reduce using rule 48 (Return -> return ( Exp ) .)
    read            reduce using rule 48 (Return -> return ( Exp ) .)
    if              reduce using rule 48 (Return -> return ( Exp ) .)
    repeat          reduce using rule 48 (Return -> return ( Exp ) .)
    num             reduce using rule 48 (Return -> return ( Exp ) .)
    (               reduce using rule 48 (Return -> return ( Exp ) .)
    ;               reduce using rule 48 (Return -> return ( Exp ) .)
    )               reduce using rule 48 (Return -> return ( Exp ) .)


state 152

    (90) Cond -> ( Cond and . Cond )
    (88) Cond -> Cond and . Cond
    (88) Cond -> . Cond and Cond
    (89) Cond -> . Cond or Cond
    (90) Cond -> . ( Cond and Cond )
    (91) Cond -> . ( Cond or Cond )
    (92) Cond -> . Exp sup Exp
    (93) Cond -> . Exp inf Exp
    (94) Cond -> . Exp supeq Exp
    (95) Cond -> . Exp infeq Exp
    (96) Cond -> . not Exp
    (97) Cond -> . Exp eq Exp
    (98) Cond -> . Exp diff Exp
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    (               shift and go to state 78
    not             shift and go to state 81
    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45

    Cond                           shift and go to state 178
    Exp                            shift and go to state 143
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 153

    (91) Cond -> ( Cond or . Cond )
    (89) Cond -> Cond or . Cond
    (88) Cond -> . Cond and Cond
    (89) Cond -> . Cond or Cond
    (90) Cond -> . ( Cond and Cond )
    (91) Cond -> . ( Cond or Cond )
    (92) Cond -> . Exp sup Exp
    (93) Cond -> . Exp inf Exp
    (94) Cond -> . Exp supeq Exp
    (95) Cond -> . Exp infeq Exp
    (96) Cond -> . not Exp
    (97) Cond -> . Exp eq Exp
    (98) Cond -> . Exp diff Exp
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    (               shift and go to state 78
    not             shift and go to state 81
    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45

    Cond                           shift and go to state 179
    Exp                            shift and go to state 143
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 154

    (88) Cond -> Cond and Cond .
    (88) Cond -> Cond . and Cond
    (89) Cond -> Cond . or Cond

  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
    )               reduce using rule 88 (Cond -> Cond and Cond .)
    ;               reduce using rule 88 (Cond -> Cond and Cond .)
    and             shift and go to state 122
    or              shift and go to state 123

  ! and             [ reduce using rule 88 (Cond -> Cond and Cond .) ]
  ! or              [ reduce using rule 88 (Cond -> Cond and Cond .) ]


state 155

    (89) Cond -> Cond or Cond .
    (88) Cond -> Cond . and Cond
    (89) Cond -> Cond . or Cond

  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
    )               reduce using rule 89 (Cond -> Cond or Cond .)
    ;               reduce using rule 89 (Cond -> Cond or Cond .)
    and             shift and go to state 122
    or              shift and go to state 123

  ! and             [ reduce using rule 89 (Cond -> Cond or Cond .) ]
  ! or              [ reduce using rule 89 (Cond -> Cond or Cond .) ]


state 156

    (92) Cond -> Exp sup Exp .
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    )               reduce using rule 92 (Cond -> Exp sup Exp .)
    and             reduce using rule 92 (Cond -> Exp sup Exp .)
    or              reduce using rule 92 (Cond -> Exp sup Exp .)
    ;               reduce using rule 92 (Cond -> Exp sup Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 157

    (93) Cond -> Exp inf Exp .
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    )               reduce using rule 93 (Cond -> Exp inf Exp .)
    and             reduce using rule 93 (Cond -> Exp inf Exp .)
    or              reduce using rule 93 (Cond -> Exp inf Exp .)
    ;               reduce using rule 93 (Cond -> Exp inf Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 158

    (94) Cond -> Exp supeq Exp .
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    )               reduce using rule 94 (Cond -> Exp supeq Exp .)
    and             reduce using rule 94 (Cond -> Exp supeq Exp .)
    or              reduce using rule 94 (Cond -> Exp supeq Exp .)
    ;               reduce using rule 94 (Cond -> Exp supeq Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 159

    (95) Cond -> Exp infeq Exp .
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    )               reduce using rule 95 (Cond -> Exp infeq Exp .)
    and             reduce using rule 95 (Cond -> Exp infeq Exp .)
    or              reduce using rule 95 (Cond -> Exp infeq Exp .)
    ;               reduce using rule 95 (Cond -> Exp infeq Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 160

    (97) Cond -> Exp eq Exp .
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    )               reduce using rule 97 (Cond -> Exp eq Exp .)
    and             reduce using rule 97 (Cond -> Exp eq Exp .)
    or              reduce using rule 97 (Cond -> Exp eq Exp .)
    ;               reduce using rule 97 (Cond -> Exp eq Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 161

    (98) Cond -> Exp diff Exp .
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    )               reduce using rule 98 (Cond -> Exp diff Exp .)
    and             reduce using rule 98 (Cond -> Exp diff Exp .)
    or              reduce using rule 98 (Cond -> Exp diff Exp .)
    ;               reduce using rule 98 (Cond -> Exp diff Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 162

    (80) Factor -> id [ Exp . ]
    (81) Factor -> id [ Exp . ] [ Exp ]
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    ]               shift and go to state 180
    +               shift and go to state 56
    -               shift and go to state 57


state 163

    (82) Factor -> gid [ Exp . ]
    (83) Factor -> gid [ Exp . ] [ Exp ]
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    ]               shift and go to state 181
    +               shift and go to state 56
    -               shift and go to state 57


state 164

    (31) Print -> print ( Exp ) .

    }               reduce using rule 31 (Print -> print ( Exp ) .)
    id              reduce using rule 31 (Print -> print ( Exp ) .)
    gid             reduce using rule 31 (Print -> print ( Exp ) .)
    return          reduce using rule 31 (Print -> print ( Exp ) .)
    print           reduce using rule 31 (Print -> print ( Exp ) .)
    println         reduce using rule 31 (Print -> print ( Exp ) .)
    prints          reduce using rule 31 (Print -> print ( Exp ) .)
    for             reduce using rule 31 (Print -> print ( Exp ) .)
    while           reduce using rule 31 (Print -> print ( Exp ) .)
    read            reduce using rule 31 (Print -> print ( Exp ) .)
    if              reduce using rule 31 (Print -> print ( Exp ) .)
    repeat          reduce using rule 31 (Print -> print ( Exp ) .)
    num             reduce using rule 31 (Print -> print ( Exp ) .)
    (               reduce using rule 31 (Print -> print ( Exp ) .)
    ;               reduce using rule 31 (Print -> print ( Exp ) .)
    )               reduce using rule 31 (Print -> print ( Exp ) .)


state 165

    (32) Println -> println ( Exp ) .

    }               reduce using rule 32 (Println -> println ( Exp ) .)
    id              reduce using rule 32 (Println -> println ( Exp ) .)
    gid             reduce using rule 32 (Println -> println ( Exp ) .)
    return          reduce using rule 32 (Println -> println ( Exp ) .)
    print           reduce using rule 32 (Println -> println ( Exp ) .)
    println         reduce using rule 32 (Println -> println ( Exp ) .)
    prints          reduce using rule 32 (Println -> println ( Exp ) .)
    for             reduce using rule 32 (Println -> println ( Exp ) .)
    while           reduce using rule 32 (Println -> println ( Exp ) .)
    read            reduce using rule 32 (Println -> println ( Exp ) .)
    if              reduce using rule 32 (Println -> println ( Exp ) .)
    repeat          reduce using rule 32 (Println -> println ( Exp ) .)
    num             reduce using rule 32 (Println -> println ( Exp ) .)
    (               reduce using rule 32 (Println -> println ( Exp ) .)
    ;               reduce using rule 32 (Println -> println ( Exp ) .)
    )               reduce using rule 32 (Println -> println ( Exp ) .)


state 166

    (33) Prints -> prints ( string ) .

    }               reduce using rule 33 (Prints -> prints ( string ) .)
    id              reduce using rule 33 (Prints -> prints ( string ) .)
    gid             reduce using rule 33 (Prints -> prints ( string ) .)
    return          reduce using rule 33 (Prints -> prints ( string ) .)
    print           reduce using rule 33 (Prints -> prints ( string ) .)
    println         reduce using rule 33 (Prints -> prints ( string ) .)
    prints          reduce using rule 33 (Prints -> prints ( string ) .)
    for             reduce using rule 33 (Prints -> prints ( string ) .)
    while           reduce using rule 33 (Prints -> prints ( string ) .)
    read            reduce using rule 33 (Prints -> prints ( string ) .)
    if              reduce using rule 33 (Prints -> prints ( string ) .)
    repeat          reduce using rule 33 (Prints -> prints ( string ) .)
    num             reduce using rule 33 (Prints -> prints ( string ) .)
    (               reduce using rule 33 (Prints -> prints ( string ) .)
    ;               reduce using rule 33 (Prints -> prints ( string ) .)
    )               reduce using rule 33 (Prints -> prints ( string ) .)


state 167

    (26) Repeat -> RepeatS ( num ) . { Insts }

    {               shift and go to state 182


state 168

    (28) For -> for ( Insts ; . Cond ; Insts ) { Insts }
    (88) Cond -> . Cond and Cond
    (89) Cond -> . Cond or Cond
    (90) Cond -> . ( Cond and Cond )
    (91) Cond -> . ( Cond or Cond )
    (92) Cond -> . Exp sup Exp
    (93) Cond -> . Exp inf Exp
    (94) Cond -> . Exp supeq Exp
    (95) Cond -> . Exp infeq Exp
    (96) Cond -> . not Exp
    (97) Cond -> . Exp eq Exp
    (98) Cond -> . Exp diff Exp
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    (               shift and go to state 78
    not             shift and go to state 81
    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45

    Cond                           shift and go to state 183
    Exp                            shift and go to state 143
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 169

    (29) While -> while ( Cond ) . { Insts }

    {               shift and go to state 184


state 170

    (30) Read -> read ( id ) .

    }               reduce using rule 30 (Read -> read ( id ) .)
    id              reduce using rule 30 (Read -> read ( id ) .)
    gid             reduce using rule 30 (Read -> read ( id ) .)
    return          reduce using rule 30 (Read -> read ( id ) .)
    print           reduce using rule 30 (Read -> read ( id ) .)
    println         reduce using rule 30 (Read -> read ( id ) .)
    prints          reduce using rule 30 (Read -> read ( id ) .)
    for             reduce using rule 30 (Read -> read ( id ) .)
    while           reduce using rule 30 (Read -> read ( id ) .)
    read            reduce using rule 30 (Read -> read ( id ) .)
    if              reduce using rule 30 (Read -> read ( id ) .)
    repeat          reduce using rule 30 (Read -> read ( id ) .)
    num             reduce using rule 30 (Read -> read ( id ) .)
    (               reduce using rule 30 (Read -> read ( id ) .)
    ;               reduce using rule 30 (Read -> read ( id ) .)
    )               reduce using rule 30 (Read -> read ( id ) .)


state 171

    (49) If -> if ( Cond ) . { Insts }
    (50) If -> if ( Cond ) . Inst
    (52) If -> if ( Cond ) . { Insts } else { Insts }
    (15) Inst -> . Attr
    (16) Inst -> . Return
    (17) Inst -> . Exp
    (18) Inst -> . Print
    (19) Inst -> . Println
    (20) Inst -> . Prints
    (21) Inst -> . Repeat
    (22) Inst -> . For
    (23) Inst -> . While
    (24) Inst -> . Read
    (25) Inst -> . If
    (42) Attr -> . id = Exp
    (43) Attr -> . id [ Exp ] = Exp
    (44) Attr -> . id [ Exp ] [ Exp ] = Exp
    (45) Attr -> . gid = Exp
    (46) Attr -> . gid [ Exp ] = Exp
    (47) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (48) Return -> . return ( Exp )
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (31) Print -> . print ( Exp )
    (32) Println -> . println ( Exp )
    (33) Prints -> . prints ( string )
    (26) Repeat -> . RepeatS ( num ) { Insts }
    (28) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (29) While -> . while ( Cond ) { Insts }
    (30) Read -> . read ( id )
    (49) If -> . if ( Cond ) { Insts }
    (50) If -> . if ( Cond ) Inst
    (52) If -> . if ( Cond ) { Insts } else { Insts }
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (27) RepeatS -> . repeat
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    {               shift and go to state 185
    id              shift and go to state 36
    gid             shift and go to state 37
    return          shift and go to state 38
    print           shift and go to state 41
    println         shift and go to state 42
    prints          shift and go to state 43
    for             shift and go to state 46
    while           shift and go to state 47
    read            shift and go to state 48
    if              shift and go to state 49
    repeat          shift and go to state 51
    num             shift and go to state 45
    (               shift and go to state 39

    Inst                           shift and go to state 186
    Attr                           shift and go to state 25
    Return                         shift and go to state 26
    Exp                            shift and go to state 27
    Print                          shift and go to state 28
    Println                        shift and go to state 29
    Prints                         shift and go to state 30
    Repeat                         shift and go to state 31
    For                            shift and go to state 32
    While                          shift and go to state 33
    Read                           shift and go to state 34
    If                             shift and go to state 35
    Term                           shift and go to state 40
    RepeatS                        shift and go to state 44
    Factor                         shift and go to state 50

state 172

    (34) Dcl -> int id [ num ] .
    (35) Dcl -> int id [ num ] . [ num ]

    int             reduce using rule 34 (Dcl -> int id [ num ] .)
    }               reduce using rule 34 (Dcl -> int id [ num ] .)
    id              reduce using rule 34 (Dcl -> int id [ num ] .)
    gid             reduce using rule 34 (Dcl -> int id [ num ] .)
    return          reduce using rule 34 (Dcl -> int id [ num ] .)
    print           reduce using rule 34 (Dcl -> int id [ num ] .)
    println         reduce using rule 34 (Dcl -> int id [ num ] .)
    prints          reduce using rule 34 (Dcl -> int id [ num ] .)
    for             reduce using rule 34 (Dcl -> int id [ num ] .)
    while           reduce using rule 34 (Dcl -> int id [ num ] .)
    read            reduce using rule 34 (Dcl -> int id [ num ] .)
    if              reduce using rule 34 (Dcl -> int id [ num ] .)
    repeat          reduce using rule 34 (Dcl -> int id [ num ] .)
    num             reduce using rule 34 (Dcl -> int id [ num ] .)
    (               reduce using rule 34 (Dcl -> int id [ num ] .)
    [               shift and go to state 187


state 173

    (39) DclGlobal -> int id [ num ] [ . num ]

    num             shift and go to state 188


state 174

    (44) Attr -> id [ Exp ] [ . Exp ] = Exp
    (81) Factor -> id [ Exp ] [ . Exp ]
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 189
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 175

    (43) Attr -> id [ Exp ] = . Exp
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 190
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 176

    (47) Attr -> gid [ Exp ] [ . Exp ] = Exp
    (83) Factor -> gid [ Exp ] [ . Exp ]
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 191
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 177

    (46) Attr -> gid [ Exp ] = . Exp
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 192
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 178

    (90) Cond -> ( Cond and Cond . )
    (88) Cond -> Cond and Cond .
    (88) Cond -> Cond . and Cond
    (89) Cond -> Cond . or Cond

  ! shift/reduce conflict for ) resolved as shift
  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
    )               shift and go to state 193
    and             shift and go to state 122
    or              shift and go to state 123

  ! and             [ reduce using rule 88 (Cond -> Cond and Cond .) ]
  ! or              [ reduce using rule 88 (Cond -> Cond and Cond .) ]
  ! )               [ reduce using rule 88 (Cond -> Cond and Cond .) ]


state 179

    (91) Cond -> ( Cond or Cond . )
    (89) Cond -> Cond or Cond .
    (88) Cond -> Cond . and Cond
    (89) Cond -> Cond . or Cond

  ! shift/reduce conflict for ) resolved as shift
  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
    )               shift and go to state 194
    and             shift and go to state 122
    or              shift and go to state 123

  ! and             [ reduce using rule 89 (Cond -> Cond or Cond .) ]
  ! or              [ reduce using rule 89 (Cond -> Cond or Cond .) ]
  ! )               [ reduce using rule 89 (Cond -> Cond or Cond .) ]


state 180

    (80) Factor -> id [ Exp ] .
    (81) Factor -> id [ Exp ] . [ Exp ]

    *               reduce using rule 80 (Factor -> id [ Exp ] .)
    /               reduce using rule 80 (Factor -> id [ Exp ] .)
    %               reduce using rule 80 (Factor -> id [ Exp ] .)
    )               reduce using rule 80 (Factor -> id [ Exp ] .)
    sup             reduce using rule 80 (Factor -> id [ Exp ] .)
    inf             reduce using rule 80 (Factor -> id [ Exp ] .)
    supeq           reduce using rule 80 (Factor -> id [ Exp ] .)
    infeq           reduce using rule 80 (Factor -> id [ Exp ] .)
    eq              reduce using rule 80 (Factor -> id [ Exp ] .)
    diff            reduce using rule 80 (Factor -> id [ Exp ] .)
    +               reduce using rule 80 (Factor -> id [ Exp ] .)
    -               reduce using rule 80 (Factor -> id [ Exp ] .)
    }               reduce using rule 80 (Factor -> id [ Exp ] .)
    id              reduce using rule 80 (Factor -> id [ Exp ] .)
    gid             reduce using rule 80 (Factor -> id [ Exp ] .)
    return          reduce using rule 80 (Factor -> id [ Exp ] .)
    print           reduce using rule 80 (Factor -> id [ Exp ] .)
    println         reduce using rule 80 (Factor -> id [ Exp ] .)
    prints          reduce using rule 80 (Factor -> id [ Exp ] .)
    for             reduce using rule 80 (Factor -> id [ Exp ] .)
    while           reduce using rule 80 (Factor -> id [ Exp ] .)
    read            reduce using rule 80 (Factor -> id [ Exp ] .)
    if              reduce using rule 80 (Factor -> id [ Exp ] .)
    repeat          reduce using rule 80 (Factor -> id [ Exp ] .)
    num             reduce using rule 80 (Factor -> id [ Exp ] .)
    (               reduce using rule 80 (Factor -> id [ Exp ] .)
    ;               reduce using rule 80 (Factor -> id [ Exp ] .)
    ]               reduce using rule 80 (Factor -> id [ Exp ] .)
    and             reduce using rule 80 (Factor -> id [ Exp ] .)
    or              reduce using rule 80 (Factor -> id [ Exp ] .)
    [               shift and go to state 195


state 181

    (82) Factor -> gid [ Exp ] .
    (83) Factor -> gid [ Exp ] . [ Exp ]

    *               reduce using rule 82 (Factor -> gid [ Exp ] .)
    /               reduce using rule 82 (Factor -> gid [ Exp ] .)
    %               reduce using rule 82 (Factor -> gid [ Exp ] .)
    )               reduce using rule 82 (Factor -> gid [ Exp ] .)
    sup             reduce using rule 82 (Factor -> gid [ Exp ] .)
    inf             reduce using rule 82 (Factor -> gid [ Exp ] .)
    supeq           reduce using rule 82 (Factor -> gid [ Exp ] .)
    infeq           reduce using rule 82 (Factor -> gid [ Exp ] .)
    eq              reduce using rule 82 (Factor -> gid [ Exp ] .)
    diff            reduce using rule 82 (Factor -> gid [ Exp ] .)
    +               reduce using rule 82 (Factor -> gid [ Exp ] .)
    -               reduce using rule 82 (Factor -> gid [ Exp ] .)
    }               reduce using rule 82 (Factor -> gid [ Exp ] .)
    id              reduce using rule 82 (Factor -> gid [ Exp ] .)
    gid             reduce using rule 82 (Factor -> gid [ Exp ] .)
    return          reduce using rule 82 (Factor -> gid [ Exp ] .)
    print           reduce using rule 82 (Factor -> gid [ Exp ] .)
    println         reduce using rule 82 (Factor -> gid [ Exp ] .)
    prints          reduce using rule 82 (Factor -> gid [ Exp ] .)
    for             reduce using rule 82 (Factor -> gid [ Exp ] .)
    while           reduce using rule 82 (Factor -> gid [ Exp ] .)
    read            reduce using rule 82 (Factor -> gid [ Exp ] .)
    if              reduce using rule 82 (Factor -> gid [ Exp ] .)
    repeat          reduce using rule 82 (Factor -> gid [ Exp ] .)
    num             reduce using rule 82 (Factor -> gid [ Exp ] .)
    (               reduce using rule 82 (Factor -> gid [ Exp ] .)
    ;               reduce using rule 82 (Factor -> gid [ Exp ] .)
    ]               reduce using rule 82 (Factor -> gid [ Exp ] .)
    and             reduce using rule 82 (Factor -> gid [ Exp ] .)
    or              reduce using rule 82 (Factor -> gid [ Exp ] .)
    [               shift and go to state 196


state 182

    (26) Repeat -> RepeatS ( num ) { . Insts }
    (13) Insts -> . Insts Inst
    (14) Insts -> .

    }               reduce using rule 14 (Insts -> .)
    id              reduce using rule 14 (Insts -> .)
    gid             reduce using rule 14 (Insts -> .)
    return          reduce using rule 14 (Insts -> .)
    print           reduce using rule 14 (Insts -> .)
    println         reduce using rule 14 (Insts -> .)
    prints          reduce using rule 14 (Insts -> .)
    for             reduce using rule 14 (Insts -> .)
    while           reduce using rule 14 (Insts -> .)
    read            reduce using rule 14 (Insts -> .)
    if              reduce using rule 14 (Insts -> .)
    repeat          reduce using rule 14 (Insts -> .)
    num             reduce using rule 14 (Insts -> .)
    (               reduce using rule 14 (Insts -> .)

    Insts                          shift and go to state 197

state 183

    (28) For -> for ( Insts ; Cond . ; Insts ) { Insts }
    (88) Cond -> Cond . and Cond
    (89) Cond -> Cond . or Cond

    ;               shift and go to state 198
    and             shift and go to state 122
    or              shift and go to state 123


state 184

    (29) While -> while ( Cond ) { . Insts }
    (13) Insts -> . Insts Inst
    (14) Insts -> .

    }               reduce using rule 14 (Insts -> .)
    id              reduce using rule 14 (Insts -> .)
    gid             reduce using rule 14 (Insts -> .)
    return          reduce using rule 14 (Insts -> .)
    print           reduce using rule 14 (Insts -> .)
    println         reduce using rule 14 (Insts -> .)
    prints          reduce using rule 14 (Insts -> .)
    for             reduce using rule 14 (Insts -> .)
    while           reduce using rule 14 (Insts -> .)
    read            reduce using rule 14 (Insts -> .)
    if              reduce using rule 14 (Insts -> .)
    repeat          reduce using rule 14 (Insts -> .)
    num             reduce using rule 14 (Insts -> .)
    (               reduce using rule 14 (Insts -> .)

    Insts                          shift and go to state 199

state 185

    (49) If -> if ( Cond ) { . Insts }
    (52) If -> if ( Cond ) { . Insts } else { Insts }
    (13) Insts -> . Insts Inst
    (14) Insts -> .

    }               reduce using rule 14 (Insts -> .)
    id              reduce using rule 14 (Insts -> .)
    gid             reduce using rule 14 (Insts -> .)
    return          reduce using rule 14 (Insts -> .)
    print           reduce using rule 14 (Insts -> .)
    println         reduce using rule 14 (Insts -> .)
    prints          reduce using rule 14 (Insts -> .)
    for             reduce using rule 14 (Insts -> .)
    while           reduce using rule 14 (Insts -> .)
    read            reduce using rule 14 (Insts -> .)
    if              reduce using rule 14 (Insts -> .)
    repeat          reduce using rule 14 (Insts -> .)
    num             reduce using rule 14 (Insts -> .)
    (               reduce using rule 14 (Insts -> .)

    Insts                          shift and go to state 200

state 186

    (50) If -> if ( Cond ) Inst .

    }               reduce using rule 50 (If -> if ( Cond ) Inst .)
    id              reduce using rule 50 (If -> if ( Cond ) Inst .)
    gid             reduce using rule 50 (If -> if ( Cond ) Inst .)
    return          reduce using rule 50 (If -> if ( Cond ) Inst .)
    print           reduce using rule 50 (If -> if ( Cond ) Inst .)
    println         reduce using rule 50 (If -> if ( Cond ) Inst .)
    prints          reduce using rule 50 (If -> if ( Cond ) Inst .)
    for             reduce using rule 50 (If -> if ( Cond ) Inst .)
    while           reduce using rule 50 (If -> if ( Cond ) Inst .)
    read            reduce using rule 50 (If -> if ( Cond ) Inst .)
    if              reduce using rule 50 (If -> if ( Cond ) Inst .)
    repeat          reduce using rule 50 (If -> if ( Cond ) Inst .)
    num             reduce using rule 50 (If -> if ( Cond ) Inst .)
    (               reduce using rule 50 (If -> if ( Cond ) Inst .)
    ;               reduce using rule 50 (If -> if ( Cond ) Inst .)
    )               reduce using rule 50 (If -> if ( Cond ) Inst .)


state 187

    (35) Dcl -> int id [ num ] [ . num ]

    num             shift and go to state 201


state 188

    (39) DclGlobal -> int id [ num ] [ num . ]

    ]               shift and go to state 202


state 189

    (44) Attr -> id [ Exp ] [ Exp . ] = Exp
    (81) Factor -> id [ Exp ] [ Exp . ]
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    ]               shift and go to state 203
    +               shift and go to state 56
    -               shift and go to state 57


state 190

    (43) Attr -> id [ Exp ] = Exp .
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    }               reduce using rule 43 (Attr -> id [ Exp ] = Exp .)
    id              reduce using rule 43 (Attr -> id [ Exp ] = Exp .)
    gid             reduce using rule 43 (Attr -> id [ Exp ] = Exp .)
    return          reduce using rule 43 (Attr -> id [ Exp ] = Exp .)
    print           reduce using rule 43 (Attr -> id [ Exp ] = Exp .)
    println         reduce using rule 43 (Attr -> id [ Exp ] = Exp .)
    prints          reduce using rule 43 (Attr -> id [ Exp ] = Exp .)
    for             reduce using rule 43 (Attr -> id [ Exp ] = Exp .)
    while           reduce using rule 43 (Attr -> id [ Exp ] = Exp .)
    read            reduce using rule 43 (Attr -> id [ Exp ] = Exp .)
    if              reduce using rule 43 (Attr -> id [ Exp ] = Exp .)
    repeat          reduce using rule 43 (Attr -> id [ Exp ] = Exp .)
    num             reduce using rule 43 (Attr -> id [ Exp ] = Exp .)
    (               reduce using rule 43 (Attr -> id [ Exp ] = Exp .)
    ;               reduce using rule 43 (Attr -> id [ Exp ] = Exp .)
    )               reduce using rule 43 (Attr -> id [ Exp ] = Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 191

    (47) Attr -> gid [ Exp ] [ Exp . ] = Exp
    (83) Factor -> gid [ Exp ] [ Exp . ]
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    ]               shift and go to state 204
    +               shift and go to state 56
    -               shift and go to state 57


state 192

    (46) Attr -> gid [ Exp ] = Exp .
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    }               reduce using rule 46 (Attr -> gid [ Exp ] = Exp .)
    id              reduce using rule 46 (Attr -> gid [ Exp ] = Exp .)
    gid             reduce using rule 46 (Attr -> gid [ Exp ] = Exp .)
    return          reduce using rule 46 (Attr -> gid [ Exp ] = Exp .)
    print           reduce using rule 46 (Attr -> gid [ Exp ] = Exp .)
    println         reduce using rule 46 (Attr -> gid [ Exp ] = Exp .)
    prints          reduce using rule 46 (Attr -> gid [ Exp ] = Exp .)
    for             reduce using rule 46 (Attr -> gid [ Exp ] = Exp .)
    while           reduce using rule 46 (Attr -> gid [ Exp ] = Exp .)
    read            reduce using rule 46 (Attr -> gid [ Exp ] = Exp .)
    if              reduce using rule 46 (Attr -> gid [ Exp ] = Exp .)
    repeat          reduce using rule 46 (Attr -> gid [ Exp ] = Exp .)
    num             reduce using rule 46 (Attr -> gid [ Exp ] = Exp .)
    (               reduce using rule 46 (Attr -> gid [ Exp ] = Exp .)
    ;               reduce using rule 46 (Attr -> gid [ Exp ] = Exp .)
    )               reduce using rule 46 (Attr -> gid [ Exp ] = Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 193

    (90) Cond -> ( Cond and Cond ) .

    )               reduce using rule 90 (Cond -> ( Cond and Cond ) .)
    and             reduce using rule 90 (Cond -> ( Cond and Cond ) .)
    or              reduce using rule 90 (Cond -> ( Cond and Cond ) .)
    ;               reduce using rule 90 (Cond -> ( Cond and Cond ) .)


state 194

    (91) Cond -> ( Cond or Cond ) .

    )               reduce using rule 91 (Cond -> ( Cond or Cond ) .)
    and             reduce using rule 91 (Cond -> ( Cond or Cond ) .)
    or              reduce using rule 91 (Cond -> ( Cond or Cond ) .)
    ;               reduce using rule 91 (Cond -> ( Cond or Cond ) .)


state 195

    (81) Factor -> id [ Exp ] [ . Exp ]
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 205
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 196

    (83) Factor -> gid [ Exp ] [ . Exp ]
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 206
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 197

    (26) Repeat -> RepeatS ( num ) { Insts . }
    (13) Insts -> Insts . Inst
    (15) Inst -> . Attr
    (16) Inst -> . Return
    (17) Inst -> . Exp
    (18) Inst -> . Print
    (19) Inst -> . Println
    (20) Inst -> . Prints
    (21) Inst -> . Repeat
    (22) Inst -> . For
    (23) Inst -> . While
    (24) Inst -> . Read
    (25) Inst -> . If
    (42) Attr -> . id = Exp
    (43) Attr -> . id [ Exp ] = Exp
    (44) Attr -> . id [ Exp ] [ Exp ] = Exp
    (45) Attr -> . gid = Exp
    (46) Attr -> . gid [ Exp ] = Exp
    (47) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (48) Return -> . return ( Exp )
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (31) Print -> . print ( Exp )
    (32) Println -> . println ( Exp )
    (33) Prints -> . prints ( string )
    (26) Repeat -> . RepeatS ( num ) { Insts }
    (28) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (29) While -> . while ( Cond ) { Insts }
    (30) Read -> . read ( id )
    (49) If -> . if ( Cond ) { Insts }
    (50) If -> . if ( Cond ) Inst
    (52) If -> . if ( Cond ) { Insts } else { Insts }
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (27) RepeatS -> . repeat
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    }               shift and go to state 207
    id              shift and go to state 36
    gid             shift and go to state 37
    return          shift and go to state 38
    print           shift and go to state 41
    println         shift and go to state 42
    prints          shift and go to state 43
    for             shift and go to state 46
    while           shift and go to state 47
    read            shift and go to state 48
    if              shift and go to state 49
    repeat          shift and go to state 51
    num             shift and go to state 45
    (               shift and go to state 39

    RepeatS                        shift and go to state 44
    Inst                           shift and go to state 24
    Attr                           shift and go to state 25
    Return                         shift and go to state 26
    Exp                            shift and go to state 27
    Print                          shift and go to state 28
    Println                        shift and go to state 29
    Prints                         shift and go to state 30
    Repeat                         shift and go to state 31
    For                            shift and go to state 32
    While                          shift and go to state 33
    Read                           shift and go to state 34
    If                             shift and go to state 35
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 198

    (28) For -> for ( Insts ; Cond ; . Insts ) { Insts }
    (13) Insts -> . Insts Inst
    (14) Insts -> .

    )               reduce using rule 14 (Insts -> .)
    id              reduce using rule 14 (Insts -> .)
    gid             reduce using rule 14 (Insts -> .)
    return          reduce using rule 14 (Insts -> .)
    print           reduce using rule 14 (Insts -> .)
    println         reduce using rule 14 (Insts -> .)
    prints          reduce using rule 14 (Insts -> .)
    for             reduce using rule 14 (Insts -> .)
    while           reduce using rule 14 (Insts -> .)
    read            reduce using rule 14 (Insts -> .)
    if              reduce using rule 14 (Insts -> .)
    repeat          reduce using rule 14 (Insts -> .)
    num             reduce using rule 14 (Insts -> .)
    (               reduce using rule 14 (Insts -> .)

    Insts                          shift and go to state 208

state 199

    (29) While -> while ( Cond ) { Insts . }
    (13) Insts -> Insts . Inst
    (15) Inst -> . Attr
    (16) Inst -> . Return
    (17) Inst -> . Exp
    (18) Inst -> . Print
    (19) Inst -> . Println
    (20) Inst -> . Prints
    (21) Inst -> . Repeat
    (22) Inst -> . For
    (23) Inst -> . While
    (24) Inst -> . Read
    (25) Inst -> . If
    (42) Attr -> . id = Exp
    (43) Attr -> . id [ Exp ] = Exp
    (44) Attr -> . id [ Exp ] [ Exp ] = Exp
    (45) Attr -> . gid = Exp
    (46) Attr -> . gid [ Exp ] = Exp
    (47) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (48) Return -> . return ( Exp )
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (31) Print -> . print ( Exp )
    (32) Println -> . println ( Exp )
    (33) Prints -> . prints ( string )
    (26) Repeat -> . RepeatS ( num ) { Insts }
    (28) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (29) While -> . while ( Cond ) { Insts }
    (30) Read -> . read ( id )
    (49) If -> . if ( Cond ) { Insts }
    (50) If -> . if ( Cond ) Inst
    (52) If -> . if ( Cond ) { Insts } else { Insts }
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (27) RepeatS -> . repeat
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    }               shift and go to state 209
    id              shift and go to state 36
    gid             shift and go to state 37
    return          shift and go to state 38
    print           shift and go to state 41
    println         shift and go to state 42
    prints          shift and go to state 43
    for             shift and go to state 46
    while           shift and go to state 47
    read            shift and go to state 48
    if              shift and go to state 49
    repeat          shift and go to state 51
    num             shift and go to state 45
    (               shift and go to state 39

    Inst                           shift and go to state 24
    Attr                           shift and go to state 25
    Return                         shift and go to state 26
    Exp                            shift and go to state 27
    Print                          shift and go to state 28
    Println                        shift and go to state 29
    Prints                         shift and go to state 30
    Repeat                         shift and go to state 31
    For                            shift and go to state 32
    While                          shift and go to state 33
    Read                           shift and go to state 34
    If                             shift and go to state 35
    Term                           shift and go to state 40
    RepeatS                        shift and go to state 44
    Factor                         shift and go to state 50

state 200

    (49) If -> if ( Cond ) { Insts . }
    (52) If -> if ( Cond ) { Insts . } else { Insts }
    (13) Insts -> Insts . Inst
    (15) Inst -> . Attr
    (16) Inst -> . Return
    (17) Inst -> . Exp
    (18) Inst -> . Print
    (19) Inst -> . Println
    (20) Inst -> . Prints
    (21) Inst -> . Repeat
    (22) Inst -> . For
    (23) Inst -> . While
    (24) Inst -> . Read
    (25) Inst -> . If
    (42) Attr -> . id = Exp
    (43) Attr -> . id [ Exp ] = Exp
    (44) Attr -> . id [ Exp ] [ Exp ] = Exp
    (45) Attr -> . gid = Exp
    (46) Attr -> . gid [ Exp ] = Exp
    (47) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (48) Return -> . return ( Exp )
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (31) Print -> . print ( Exp )
    (32) Println -> . println ( Exp )
    (33) Prints -> . prints ( string )
    (26) Repeat -> . RepeatS ( num ) { Insts }
    (28) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (29) While -> . while ( Cond ) { Insts }
    (30) Read -> . read ( id )
    (49) If -> . if ( Cond ) { Insts }
    (50) If -> . if ( Cond ) Inst
    (52) If -> . if ( Cond ) { Insts } else { Insts }
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (27) RepeatS -> . repeat
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    }               shift and go to state 210
    id              shift and go to state 36
    gid             shift and go to state 37
    return          shift and go to state 38
    print           shift and go to state 41
    println         shift and go to state 42
    prints          shift and go to state 43
    for             shift and go to state 46
    while           shift and go to state 47
    read            shift and go to state 48
    if              shift and go to state 49
    repeat          shift and go to state 51
    num             shift and go to state 45
    (               shift and go to state 39

    Inst                           shift and go to state 24
    Attr                           shift and go to state 25
    Return                         shift and go to state 26
    Exp                            shift and go to state 27
    Print                          shift and go to state 28
    Println                        shift and go to state 29
    Prints                         shift and go to state 30
    Repeat                         shift and go to state 31
    For                            shift and go to state 32
    While                          shift and go to state 33
    Read                           shift and go to state 34
    If                             shift and go to state 35
    Term                           shift and go to state 40
    RepeatS                        shift and go to state 44
    Factor                         shift and go to state 50

state 201

    (35) Dcl -> int id [ num ] [ num . ]

    ]               shift and go to state 211


state 202

    (39) DclGlobal -> int id [ num ] [ num ] .

    }               reduce using rule 39 (DclGlobal -> int id [ num ] [ num ] .)
    int             reduce using rule 39 (DclGlobal -> int id [ num ] [ num ] .)


state 203

    (44) Attr -> id [ Exp ] [ Exp ] . = Exp
    (81) Factor -> id [ Exp ] [ Exp ] .

    =               shift and go to state 212
    *               reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    /               reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    %               reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    +               reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    -               reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    }               reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    id              reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    gid             reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    return          reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    print           reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    println         reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    prints          reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    for             reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    while           reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    read            reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    if              reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    repeat          reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    num             reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    (               reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    ;               reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    )               reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)


state 204

    (47) Attr -> gid [ Exp ] [ Exp ] . = Exp
    (83) Factor -> gid [ Exp ] [ Exp ] .

    =               shift and go to state 213
    *               reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    /               reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    %               reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    +               reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    -               reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    }               reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    id              reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    gid             reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    return          reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    print           reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    println         reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    prints          reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    for             reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    while           reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    read            reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    if              reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    repeat          reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    num             reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    (               reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    ;               reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    )               reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)


state 205

    (81) Factor -> id [ Exp ] [ Exp . ]
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    ]               shift and go to state 214
    +               shift and go to state 56
    -               shift and go to state 57


state 206

    (83) Factor -> gid [ Exp ] [ Exp . ]
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    ]               shift and go to state 215
    +               shift and go to state 56
    -               shift and go to state 57


state 207

    (26) Repeat -> RepeatS ( num ) { Insts } .

    }               reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    id              reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    gid             reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    return          reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    print           reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    println         reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    prints          reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    for             reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    while           reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    read            reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    if              reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    repeat          reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    num             reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    (               reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    ;               reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    )               reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)


state 208

    (28) For -> for ( Insts ; Cond ; Insts . ) { Insts }
    (13) Insts -> Insts . Inst
    (15) Inst -> . Attr
    (16) Inst -> . Return
    (17) Inst -> . Exp
    (18) Inst -> . Print
    (19) Inst -> . Println
    (20) Inst -> . Prints
    (21) Inst -> . Repeat
    (22) Inst -> . For
    (23) Inst -> . While
    (24) Inst -> . Read
    (25) Inst -> . If
    (42) Attr -> . id = Exp
    (43) Attr -> . id [ Exp ] = Exp
    (44) Attr -> . id [ Exp ] [ Exp ] = Exp
    (45) Attr -> . gid = Exp
    (46) Attr -> . gid [ Exp ] = Exp
    (47) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (48) Return -> . return ( Exp )
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (31) Print -> . print ( Exp )
    (32) Println -> . println ( Exp )
    (33) Prints -> . prints ( string )
    (26) Repeat -> . RepeatS ( num ) { Insts }
    (28) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (29) While -> . while ( Cond ) { Insts }
    (30) Read -> . read ( id )
    (49) If -> . if ( Cond ) { Insts }
    (50) If -> . if ( Cond ) Inst
    (52) If -> . if ( Cond ) { Insts } else { Insts }
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (27) RepeatS -> . repeat
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    )               shift and go to state 216
    id              shift and go to state 36
    gid             shift and go to state 37
    return          shift and go to state 38
    print           shift and go to state 41
    println         shift and go to state 42
    prints          shift and go to state 43
    for             shift and go to state 46
    while           shift and go to state 47
    read            shift and go to state 48
    if              shift and go to state 49
    repeat          shift and go to state 51
    num             shift and go to state 45
    (               shift and go to state 39

    Inst                           shift and go to state 24
    Attr                           shift and go to state 25
    Return                         shift and go to state 26
    Exp                            shift and go to state 27
    Print                          shift and go to state 28
    Println                        shift and go to state 29
    Prints                         shift and go to state 30
    Repeat                         shift and go to state 31
    For                            shift and go to state 32
    While                          shift and go to state 33
    Read                           shift and go to state 34
    If                             shift and go to state 35
    Term                           shift and go to state 40
    RepeatS                        shift and go to state 44
    Factor                         shift and go to state 50

state 209

    (29) While -> while ( Cond ) { Insts } .

    }               reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    id              reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    gid             reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    return          reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    print           reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    println         reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    prints          reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    for             reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    while           reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    read            reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    if              reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    repeat          reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    num             reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    (               reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    ;               reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    )               reduce using rule 29 (While -> while ( Cond ) { Insts } .)


state 210

    (49) If -> if ( Cond ) { Insts } .
    (52) If -> if ( Cond ) { Insts } . else { Insts }

    }               reduce using rule 49 (If -> if ( Cond ) { Insts } .)
    id              reduce using rule 49 (If -> if ( Cond ) { Insts } .)
    gid             reduce using rule 49 (If -> if ( Cond ) { Insts } .)
    return          reduce using rule 49 (If -> if ( Cond ) { Insts } .)
    print           reduce using rule 49 (If -> if ( Cond ) { Insts } .)
    println         reduce using rule 49 (If -> if ( Cond ) { Insts } .)
    prints          reduce using rule 49 (If -> if ( Cond ) { Insts } .)
    for             reduce using rule 49 (If -> if ( Cond ) { Insts } .)
    while           reduce using rule 49 (If -> if ( Cond ) { Insts } .)
    read            reduce using rule 49 (If -> if ( Cond ) { Insts } .)
    if              reduce using rule 49 (If -> if ( Cond ) { Insts } .)
    repeat          reduce using rule 49 (If -> if ( Cond ) { Insts } .)
    num             reduce using rule 49 (If -> if ( Cond ) { Insts } .)
    (               reduce using rule 49 (If -> if ( Cond ) { Insts } .)
    ;               reduce using rule 49 (If -> if ( Cond ) { Insts } .)
    )               reduce using rule 49 (If -> if ( Cond ) { Insts } .)
    else            shift and go to state 217


state 211

    (35) Dcl -> int id [ num ] [ num ] .

    int             reduce using rule 35 (Dcl -> int id [ num ] [ num ] .)
    }               reduce using rule 35 (Dcl -> int id [ num ] [ num ] .)
    id              reduce using rule 35 (Dcl -> int id [ num ] [ num ] .)
    gid             reduce using rule 35 (Dcl -> int id [ num ] [ num ] .)
    return          reduce using rule 35 (Dcl -> int id [ num ] [ num ] .)
    print           reduce using rule 35 (Dcl -> int id [ num ] [ num ] .)
    println         reduce using rule 35 (Dcl -> int id [ num ] [ num ] .)
    prints          reduce using rule 35 (Dcl -> int id [ num ] [ num ] .)
    for             reduce using rule 35 (Dcl -> int id [ num ] [ num ] .)
    while           reduce using rule 35 (Dcl -> int id [ num ] [ num ] .)
    read            reduce using rule 35 (Dcl -> int id [ num ] [ num ] .)
    if              reduce using rule 35 (Dcl -> int id [ num ] [ num ] .)
    repeat          reduce using rule 35 (Dcl -> int id [ num ] [ num ] .)
    num             reduce using rule 35 (Dcl -> int id [ num ] [ num ] .)
    (               reduce using rule 35 (Dcl -> int id [ num ] [ num ] .)


state 212

    (44) Attr -> id [ Exp ] [ Exp ] = . Exp
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 218
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 213

    (47) Attr -> gid [ Exp ] [ Exp ] = . Exp
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 219
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 214

    (81) Factor -> id [ Exp ] [ Exp ] .

    *               reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    /               reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    %               reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    )               reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    sup             reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    inf             reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    supeq           reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    infeq           reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    eq              reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    diff            reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    +               reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    -               reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    }               reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    id              reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    gid             reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    return          reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    print           reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    println         reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    prints          reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    for             reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    while           reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    read            reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    if              reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    repeat          reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    num             reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    (               reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    ;               reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    ]               reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    and             reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)
    or              reduce using rule 81 (Factor -> id [ Exp ] [ Exp ] .)


state 215

    (83) Factor -> gid [ Exp ] [ Exp ] .

    *               reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    /               reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    %               reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    )               reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    sup             reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    inf             reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    supeq           reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    infeq           reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    eq              reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    diff            reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    +               reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    -               reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    }               reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    id              reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    gid             reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    return          reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    print           reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    println         reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    prints          reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    for             reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    while           reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    read            reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    if              reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    repeat          reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    num             reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    (               reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    ;               reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    ]               reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    and             reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)
    or              reduce using rule 83 (Factor -> gid [ Exp ] [ Exp ] .)


state 216

    (28) For -> for ( Insts ; Cond ; Insts ) . { Insts }

    {               shift and go to state 220


state 217

    (52) If -> if ( Cond ) { Insts } else . { Insts }

    {               shift and go to state 221


state 218

    (44) Attr -> id [ Exp ] [ Exp ] = Exp .
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    }               reduce using rule 44 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    id              reduce using rule 44 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    gid             reduce using rule 44 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    return          reduce using rule 44 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    print           reduce using rule 44 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    println         reduce using rule 44 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    prints          reduce using rule 44 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    for             reduce using rule 44 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    while           reduce using rule 44 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    read            reduce using rule 44 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    if              reduce using rule 44 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    repeat          reduce using rule 44 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    num             reduce using rule 44 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    (               reduce using rule 44 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    ;               reduce using rule 44 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    )               reduce using rule 44 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 219

    (47) Attr -> gid [ Exp ] [ Exp ] = Exp .
    (54) Exp -> Exp . + Term
    (55) Exp -> Exp . - Term

    }               reduce using rule 47 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    id              reduce using rule 47 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    gid             reduce using rule 47 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    return          reduce using rule 47 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    print           reduce using rule 47 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    println         reduce using rule 47 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    prints          reduce using rule 47 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    for             reduce using rule 47 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    while           reduce using rule 47 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    read            reduce using rule 47 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    if              reduce using rule 47 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    repeat          reduce using rule 47 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    num             reduce using rule 47 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    (               reduce using rule 47 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    ;               reduce using rule 47 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    )               reduce using rule 47 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 220

    (28) For -> for ( Insts ; Cond ; Insts ) { . Insts }
    (13) Insts -> . Insts Inst
    (14) Insts -> .

    }               reduce using rule 14 (Insts -> .)
    id              reduce using rule 14 (Insts -> .)
    gid             reduce using rule 14 (Insts -> .)
    return          reduce using rule 14 (Insts -> .)
    print           reduce using rule 14 (Insts -> .)
    println         reduce using rule 14 (Insts -> .)
    prints          reduce using rule 14 (Insts -> .)
    for             reduce using rule 14 (Insts -> .)
    while           reduce using rule 14 (Insts -> .)
    read            reduce using rule 14 (Insts -> .)
    if              reduce using rule 14 (Insts -> .)
    repeat          reduce using rule 14 (Insts -> .)
    num             reduce using rule 14 (Insts -> .)
    (               reduce using rule 14 (Insts -> .)

    Insts                          shift and go to state 222

state 221

    (52) If -> if ( Cond ) { Insts } else { . Insts }
    (13) Insts -> . Insts Inst
    (14) Insts -> .

    }               reduce using rule 14 (Insts -> .)
    id              reduce using rule 14 (Insts -> .)
    gid             reduce using rule 14 (Insts -> .)
    return          reduce using rule 14 (Insts -> .)
    print           reduce using rule 14 (Insts -> .)
    println         reduce using rule 14 (Insts -> .)
    prints          reduce using rule 14 (Insts -> .)
    for             reduce using rule 14 (Insts -> .)
    while           reduce using rule 14 (Insts -> .)
    read            reduce using rule 14 (Insts -> .)
    if              reduce using rule 14 (Insts -> .)
    repeat          reduce using rule 14 (Insts -> .)
    num             reduce using rule 14 (Insts -> .)
    (               reduce using rule 14 (Insts -> .)

    Insts                          shift and go to state 223

state 222

    (28) For -> for ( Insts ; Cond ; Insts ) { Insts . }
    (13) Insts -> Insts . Inst
    (15) Inst -> . Attr
    (16) Inst -> . Return
    (17) Inst -> . Exp
    (18) Inst -> . Print
    (19) Inst -> . Println
    (20) Inst -> . Prints
    (21) Inst -> . Repeat
    (22) Inst -> . For
    (23) Inst -> . While
    (24) Inst -> . Read
    (25) Inst -> . If
    (42) Attr -> . id = Exp
    (43) Attr -> . id [ Exp ] = Exp
    (44) Attr -> . id [ Exp ] [ Exp ] = Exp
    (45) Attr -> . gid = Exp
    (46) Attr -> . gid [ Exp ] = Exp
    (47) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (48) Return -> . return ( Exp )
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (31) Print -> . print ( Exp )
    (32) Println -> . println ( Exp )
    (33) Prints -> . prints ( string )
    (26) Repeat -> . RepeatS ( num ) { Insts }
    (28) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (29) While -> . while ( Cond ) { Insts }
    (30) Read -> . read ( id )
    (49) If -> . if ( Cond ) { Insts }
    (50) If -> . if ( Cond ) Inst
    (52) If -> . if ( Cond ) { Insts } else { Insts }
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (27) RepeatS -> . repeat
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    }               shift and go to state 224
    id              shift and go to state 36
    gid             shift and go to state 37
    return          shift and go to state 38
    print           shift and go to state 41
    println         shift and go to state 42
    prints          shift and go to state 43
    for             shift and go to state 46
    while           shift and go to state 47
    read            shift and go to state 48
    if              shift and go to state 49
    repeat          shift and go to state 51
    num             shift and go to state 45
    (               shift and go to state 39

    Inst                           shift and go to state 24
    Attr                           shift and go to state 25
    Return                         shift and go to state 26
    Exp                            shift and go to state 27
    Print                          shift and go to state 28
    Println                        shift and go to state 29
    Prints                         shift and go to state 30
    Repeat                         shift and go to state 31
    For                            shift and go to state 32
    While                          shift and go to state 33
    Read                           shift and go to state 34
    If                             shift and go to state 35
    Term                           shift and go to state 40
    RepeatS                        shift and go to state 44
    Factor                         shift and go to state 50

state 223

    (52) If -> if ( Cond ) { Insts } else { Insts . }
    (13) Insts -> Insts . Inst
    (15) Inst -> . Attr
    (16) Inst -> . Return
    (17) Inst -> . Exp
    (18) Inst -> . Print
    (19) Inst -> . Println
    (20) Inst -> . Prints
    (21) Inst -> . Repeat
    (22) Inst -> . For
    (23) Inst -> . While
    (24) Inst -> . Read
    (25) Inst -> . If
    (42) Attr -> . id = Exp
    (43) Attr -> . id [ Exp ] = Exp
    (44) Attr -> . id [ Exp ] [ Exp ] = Exp
    (45) Attr -> . gid = Exp
    (46) Attr -> . gid [ Exp ] = Exp
    (47) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (48) Return -> . return ( Exp )
    (54) Exp -> . Exp + Term
    (55) Exp -> . Exp - Term
    (56) Exp -> . id addeq Term
    (57) Exp -> . id subeq Term
    (58) Exp -> . id addeql Term
    (59) Exp -> . id subeql Term
    (60) Exp -> . Term
    (31) Print -> . print ( Exp )
    (32) Println -> . println ( Exp )
    (33) Prints -> . prints ( string )
    (26) Repeat -> . RepeatS ( num ) { Insts }
    (28) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (29) While -> . while ( Cond ) { Insts }
    (30) Read -> . read ( id )
    (49) If -> . if ( Cond ) { Insts }
    (50) If -> . if ( Cond ) Inst
    (52) If -> . if ( Cond ) { Insts } else { Insts }
    (61) Term -> . Term * Factor
    (62) Term -> . Term / Factor
    (63) Term -> . Term % Factor
    (64) Term -> . id muleq Factor
    (65) Term -> . id diveq Factor
    (66) Term -> . id modeq Factor
    (67) Term -> . id muleql Factor
    (68) Term -> . id diveql Factor
    (69) Term -> . id modeql Factor
    (70) Term -> . Factor
    (27) RepeatS -> . repeat
    (71) Factor -> . id plus
    (72) Factor -> . id plusl
    (73) Factor -> . id minus
    (74) Factor -> . id minusl
    (75) Factor -> . id
    (76) Factor -> . gid
    (77) Factor -> . num
    (78) Factor -> . id ( )
    (79) Factor -> . ( Cond )
    (80) Factor -> . id [ Exp ]
    (81) Factor -> . id [ Exp ] [ Exp ]
    (82) Factor -> . gid [ Exp ]
    (83) Factor -> . gid [ Exp ] [ Exp ]
    (84) Factor -> . ( Exp )

    }               shift and go to state 225
    id              shift and go to state 36
    gid             shift and go to state 37
    return          shift and go to state 38
    print           shift and go to state 41
    println         shift and go to state 42
    prints          shift and go to state 43
    for             shift and go to state 46
    while           shift and go to state 47
    read            shift and go to state 48
    if              shift and go to state 49
    repeat          shift and go to state 51
    num             shift and go to state 45
    (               shift and go to state 39

    Inst                           shift and go to state 24
    Attr                           shift and go to state 25
    Return                         shift and go to state 26
    Exp                            shift and go to state 27
    Print                          shift and go to state 28
    Println                        shift and go to state 29
    Prints                         shift and go to state 30
    Repeat                         shift and go to state 31
    For                            shift and go to state 32
    While                          shift and go to state 33
    Read                           shift and go to state 34
    If                             shift and go to state 35
    Term                           shift and go to state 40
    RepeatS                        shift and go to state 44
    Factor                         shift and go to state 50

state 224

    (28) For -> for ( Insts ; Cond ; Insts ) { Insts } .

    }               reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    id              reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    gid             reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    return          reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    print           reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    println         reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    prints          reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    for             reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    while           reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    read            reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    if              reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    repeat          reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    num             reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    (               reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    ;               reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    )               reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)


state 225

    (52) If -> if ( Cond ) { Insts } else { Insts } .

    }               reduce using rule 52 (If -> if ( Cond ) { Insts } else { Insts } .)
    id              reduce using rule 52 (If -> if ( Cond ) { Insts } else { Insts } .)
    gid             reduce using rule 52 (If -> if ( Cond ) { Insts } else { Insts } .)
    return          reduce using rule 52 (If -> if ( Cond ) { Insts } else { Insts } .)
    print           reduce using rule 52 (If -> if ( Cond ) { Insts } else { Insts } .)
    println         reduce using rule 52 (If -> if ( Cond ) { Insts } else { Insts } .)
    prints          reduce using rule 52 (If -> if ( Cond ) { Insts } else { Insts } .)
    for             reduce using rule 52 (If -> if ( Cond ) { Insts } else { Insts } .)
    while           reduce using rule 52 (If -> if ( Cond ) { Insts } else { Insts } .)
    read            reduce using rule 52 (If -> if ( Cond ) { Insts } else { Insts } .)
    if              reduce using rule 52 (If -> if ( Cond ) { Insts } else { Insts } .)
    repeat          reduce using rule 52 (If -> if ( Cond ) { Insts } else { Insts } .)
    num             reduce using rule 52 (If -> if ( Cond ) { Insts } else { Insts } .)
    (               reduce using rule 52 (If -> if ( Cond ) { Insts } else { Insts } .)
    ;               reduce using rule 52 (If -> if ( Cond ) { Insts } else { Insts } .)
    )               reduce using rule 52 (If -> if ( Cond ) { Insts } else { Insts } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ( in state 36 resolved as shift
WARNING: shift/reduce conflict for ( in state 82 resolved as shift
WARNING: shift/reduce conflict for ( in state 101 resolved as shift
WARNING: shift/reduce conflict for ( in state 109 resolved as shift
WARNING: shift/reduce conflict for and in state 154 resolved as shift
WARNING: shift/reduce conflict for or in state 154 resolved as shift
WARNING: shift/reduce conflict for and in state 155 resolved as shift
WARNING: shift/reduce conflict for or in state 155 resolved as shift
WARNING: shift/reduce conflict for ) in state 178 resolved as shift
WARNING: shift/reduce conflict for and in state 178 resolved as shift
WARNING: shift/reduce conflict for or in state 178 resolved as shift
WARNING: shift/reduce conflict for ) in state 179 resolved as shift
WARNING: shift/reduce conflict for and in state 179 resolved as shift
WARNING: shift/reduce conflict for or in state 179 resolved as shift
