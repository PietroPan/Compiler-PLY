Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    vars

Grammar

Rule 0     S' -> Prog
Rule 1     Prog -> GlobalBlc MainBlc DefBlcs
Rule 2     DefBlcs -> DefBlcs DefBlc
Rule 3     DefBlcs -> <empty>
Rule 4     DefBlc -> id { VarBlc Insts }
Rule 5     VarBlc -> BlcInt
Rule 6     GlobalBlc -> global { DclGs }
Rule 7     GlobalBlc -> <empty>
Rule 8     DclGs -> DclGs DclGlobal
Rule 9     DclGs -> <empty>
Rule 10    Dcls -> Dcls Dcl
Rule 11    Dcls -> <empty>
Rule 12    MainBlc -> main { VarBlc Insts }
Rule 13    Insts -> Insts Inst
Rule 14    Insts -> <empty>
Rule 15    Inst -> Attr
Rule 16    Inst -> Return
Rule 17    Inst -> Exp
Rule 18    Inst -> Print
Rule 19    Inst -> Println
Rule 20    Inst -> Prints
Rule 21    Inst -> Repeat
Rule 22    Inst -> For
Rule 23    Inst -> While
Rule 24    Inst -> Read
Rule 25    Inst -> If
Rule 26    Repeat -> RepeatS ( num ) { Insts }
Rule 27    RepeatS -> repeat
Rule 28    For -> for ( Insts ; Cond ; Insts ) { Insts }
Rule 29    While -> while ( Cond ) { Insts }
Rule 30    Read -> read ( id )
Rule 31    Print -> print ( Exp )
Rule 32    Println -> println ( Exp )
Rule 33    Prints -> prints ( string )
Rule 34    BlcInt -> int { Dcls }
Rule 35    Dcl -> id [ num ]
Rule 36    Dcl -> id [ num ] [ num ]
Rule 37    Dcl -> id
Rule 38    Dcl -> id = num
Rule 39    DclGlobal -> int id [ num ]
Rule 40    DclGlobal -> int id [ num ] [ num ]
Rule 41    DclGlobal -> int id
Rule 42    DclGlobal -> int id = num
Rule 43    Attr -> id = Exp
Rule 44    Attr -> id [ Exp ] = Exp
Rule 45    Attr -> id [ Exp ] [ Exp ] = Exp
Rule 46    Attr -> gid = Exp
Rule 47    Attr -> gid [ Exp ] = Exp
Rule 48    Attr -> gid [ Exp ] [ Exp ] = Exp
Rule 49    Return -> return ( Exp )
Rule 50    If -> if ( Cond ) { Insts }
Rule 51    If -> if ( Cond ) Inst
Rule 52    IfStart -> if ( Cond )
Rule 53    If -> if ( Cond ) { Insts } else { Insts }
Rule 54    ElseStart -> else
Rule 55    Exp -> Exp + Term
Rule 56    Exp -> Exp - Term
Rule 57    Exp -> id addeq Term
Rule 58    Exp -> id subeq Term
Rule 59    Exp -> id addeql Term
Rule 60    Exp -> id subeql Term
Rule 61    Exp -> Term
Rule 62    Term -> Term * Factor
Rule 63    Term -> Term / Factor
Rule 64    Term -> Term % Factor
Rule 65    Term -> id muleq Factor
Rule 66    Term -> id diveq Factor
Rule 67    Term -> id modeq Factor
Rule 68    Term -> id muleql Factor
Rule 69    Term -> id diveql Factor
Rule 70    Term -> id modeql Factor
Rule 71    Term -> Factor
Rule 72    Factor -> id plus
Rule 73    Factor -> id plusl
Rule 74    Factor -> id minus
Rule 75    Factor -> id minusl
Rule 76    Factor -> id
Rule 77    Factor -> gid
Rule 78    Factor -> num
Rule 79    Factor -> id ( )
Rule 80    Factor -> ( Cond )
Rule 81    Factor -> id [ Exp ]
Rule 82    Factor -> id [ Exp ] [ Exp ]
Rule 83    Factor -> gid [ Exp ]
Rule 84    Factor -> gid [ Exp ] [ Exp ]
Rule 85    Factor -> ( Exp )
Rule 86    Id -> id
Rule 87    Id -> id [ Exp ]
Rule 88    Id -> id [ Exp ] [ Exp ]
Rule 89    Cond -> Cond and Cond
Rule 90    Cond -> Cond or Cond
Rule 91    Cond -> ( Cond and Cond )
Rule 92    Cond -> ( Cond or Cond )
Rule 93    Cond -> Exp sup Exp
Rule 94    Cond -> Exp inf Exp
Rule 95    Cond -> Exp supeq Exp
Rule 96    Cond -> Exp infeq Exp
Rule 97    Cond -> not Exp
Rule 98    Cond -> Exp eq Exp
Rule 99    Cond -> Exp diff Exp

Terminals, with rules where they appear

%                    : 64
(                    : 26 28 29 30 31 32 33 49 50 51 52 53 79 80 85 91 92
)                    : 26 28 29 30 31 32 33 49 50 51 52 53 79 80 85 91 92
*                    : 62
+                    : 55
-                    : 56
/                    : 63
;                    : 28 28
=                    : 38 42 43 44 45 46 47 48
[                    : 35 36 36 39 40 40 44 45 45 47 48 48 81 82 82 83 84 84 87 88 88
]                    : 35 36 36 39 40 40 44 45 45 47 48 48 81 82 82 83 84 84 87 88 88
addeq                : 57
addeql               : 59
and                  : 89 91
diff                 : 99
diveq                : 66
diveql               : 69
else                 : 53 54
eq                   : 98
error                : 
for                  : 28
gid                  : 46 47 48 77 83 84
global               : 6
id                   : 4 30 35 36 37 38 39 40 41 42 43 44 45 57 58 59 60 65 66 67 68 69 70 72 73 74 75 76 79 81 82 86 87 88
if                   : 50 51 52 53
inf                  : 94
infeq                : 96
int                  : 34 39 40 41 42
main                 : 12
minus                : 74
minusl               : 75
modeq                : 67
modeql               : 70
muleq                : 65
muleql               : 68
not                  : 97
num                  : 26 35 36 36 38 39 40 40 42 78
or                   : 90 92
plus                 : 72
plusl                : 73
print                : 31
println              : 32
prints               : 33
read                 : 30
repeat               : 27
return               : 49
string               : 33
subeq                : 58
subeql               : 60
sup                  : 93
supeq                : 95
vars                 : 
while                : 29
{                    : 4 6 12 26 28 29 34 50 53 53
}                    : 4 6 12 26 28 29 34 50 53 53

Nonterminals, with rules where they appear

Attr                 : 15
BlcInt               : 5
Cond                 : 28 29 50 51 52 53 80 89 89 90 90 91 91 92 92
Dcl                  : 10
DclGlobal            : 8
DclGs                : 6 8
Dcls                 : 10 34
DefBlc               : 2
DefBlcs              : 1 2
ElseStart            : 
Exp                  : 17 31 32 43 44 44 45 45 45 46 47 47 48 48 48 49 55 56 81 82 82 83 84 84 85 87 88 88 93 93 94 94 95 95 96 96 97 98 98 99 99
Factor               : 62 63 64 65 66 67 68 69 70 71
For                  : 22
GlobalBlc            : 1
Id                   : 
If                   : 25
IfStart              : 
Inst                 : 13 51
Insts                : 4 12 13 26 28 28 28 29 50 53 53
MainBlc              : 1
Print                : 18
Println              : 19
Prints               : 20
Prog                 : 0
Read                 : 24
Repeat               : 21
RepeatS              : 26
Return               : 16
Term                 : 55 56 57 58 59 60 61 62 63 64
VarBlc               : 4 12
While                : 23

Parsing method: LALR

state 0

    (0) S' -> . Prog
    (1) Prog -> . GlobalBlc MainBlc DefBlcs
    (6) GlobalBlc -> . global { DclGs }
    (7) GlobalBlc -> .

    global          shift and go to state 3
    main            reduce using rule 7 (GlobalBlc -> .)

    Prog                           shift and go to state 1
    GlobalBlc                      shift and go to state 2

state 1

    (0) S' -> Prog .



state 2

    (1) Prog -> GlobalBlc . MainBlc DefBlcs
    (12) MainBlc -> . main { VarBlc Insts }

    main            shift and go to state 5

    MainBlc                        shift and go to state 4

state 3

    (6) GlobalBlc -> global . { DclGs }

    {               shift and go to state 6


state 4

    (1) Prog -> GlobalBlc MainBlc . DefBlcs
    (2) DefBlcs -> . DefBlcs DefBlc
    (3) DefBlcs -> .

    id              reduce using rule 3 (DefBlcs -> .)
    $end            reduce using rule 3 (DefBlcs -> .)

    DefBlcs                        shift and go to state 7

state 5

    (12) MainBlc -> main . { VarBlc Insts }

    {               shift and go to state 8


state 6

    (6) GlobalBlc -> global { . DclGs }
    (8) DclGs -> . DclGs DclGlobal
    (9) DclGs -> .

    }               reduce using rule 9 (DclGs -> .)
    int             reduce using rule 9 (DclGs -> .)

    DclGs                          shift and go to state 9

state 7

    (1) Prog -> GlobalBlc MainBlc DefBlcs .
    (2) DefBlcs -> DefBlcs . DefBlc
    (4) DefBlc -> . id { VarBlc Insts }

    $end            reduce using rule 1 (Prog -> GlobalBlc MainBlc DefBlcs .)
    id              shift and go to state 11

    DefBlc                         shift and go to state 10

state 8

    (12) MainBlc -> main { . VarBlc Insts }
    (5) VarBlc -> . BlcInt
    (34) BlcInt -> . int { Dcls }

    int             shift and go to state 14

    VarBlc                         shift and go to state 12
    BlcInt                         shift and go to state 13

state 9

    (6) GlobalBlc -> global { DclGs . }
    (8) DclGs -> DclGs . DclGlobal
    (39) DclGlobal -> . int id [ num ]
    (40) DclGlobal -> . int id [ num ] [ num ]
    (41) DclGlobal -> . int id
    (42) DclGlobal -> . int id = num

    }               shift and go to state 15
    int             shift and go to state 17

    DclGlobal                      shift and go to state 16

state 10

    (2) DefBlcs -> DefBlcs DefBlc .

    id              reduce using rule 2 (DefBlcs -> DefBlcs DefBlc .)
    $end            reduce using rule 2 (DefBlcs -> DefBlcs DefBlc .)


state 11

    (4) DefBlc -> id . { VarBlc Insts }

    {               shift and go to state 18


state 12

    (12) MainBlc -> main { VarBlc . Insts }
    (13) Insts -> . Insts Inst
    (14) Insts -> .

    }               reduce using rule 14 (Insts -> .)
    id              reduce using rule 14 (Insts -> .)
    gid             reduce using rule 14 (Insts -> .)
    return          reduce using rule 14 (Insts -> .)
    print           reduce using rule 14 (Insts -> .)
    println         reduce using rule 14 (Insts -> .)
    prints          reduce using rule 14 (Insts -> .)
    for             reduce using rule 14 (Insts -> .)
    while           reduce using rule 14 (Insts -> .)
    read            reduce using rule 14 (Insts -> .)
    if              reduce using rule 14 (Insts -> .)
    repeat          reduce using rule 14 (Insts -> .)
    num             reduce using rule 14 (Insts -> .)
    (               reduce using rule 14 (Insts -> .)

    Insts                          shift and go to state 19

state 13

    (5) VarBlc -> BlcInt .

    }               reduce using rule 5 (VarBlc -> BlcInt .)
    id              reduce using rule 5 (VarBlc -> BlcInt .)
    gid             reduce using rule 5 (VarBlc -> BlcInt .)
    return          reduce using rule 5 (VarBlc -> BlcInt .)
    print           reduce using rule 5 (VarBlc -> BlcInt .)
    println         reduce using rule 5 (VarBlc -> BlcInt .)
    prints          reduce using rule 5 (VarBlc -> BlcInt .)
    for             reduce using rule 5 (VarBlc -> BlcInt .)
    while           reduce using rule 5 (VarBlc -> BlcInt .)
    read            reduce using rule 5 (VarBlc -> BlcInt .)
    if              reduce using rule 5 (VarBlc -> BlcInt .)
    repeat          reduce using rule 5 (VarBlc -> BlcInt .)
    num             reduce using rule 5 (VarBlc -> BlcInt .)
    (               reduce using rule 5 (VarBlc -> BlcInt .)


state 14

    (34) BlcInt -> int . { Dcls }

    {               shift and go to state 20


state 15

    (6) GlobalBlc -> global { DclGs } .

    main            reduce using rule 6 (GlobalBlc -> global { DclGs } .)


state 16

    (8) DclGs -> DclGs DclGlobal .

    }               reduce using rule 8 (DclGs -> DclGs DclGlobal .)
    int             reduce using rule 8 (DclGs -> DclGs DclGlobal .)


state 17

    (39) DclGlobal -> int . id [ num ]
    (40) DclGlobal -> int . id [ num ] [ num ]
    (41) DclGlobal -> int . id
    (42) DclGlobal -> int . id = num

    id              shift and go to state 21


state 18

    (4) DefBlc -> id { . VarBlc Insts }
    (5) VarBlc -> . BlcInt
    (34) BlcInt -> . int { Dcls }

    int             shift and go to state 14

    VarBlc                         shift and go to state 22
    BlcInt                         shift and go to state 13

state 19

    (12) MainBlc -> main { VarBlc Insts . }
    (13) Insts -> Insts . Inst
    (15) Inst -> . Attr
    (16) Inst -> . Return
    (17) Inst -> . Exp
    (18) Inst -> . Print
    (19) Inst -> . Println
    (20) Inst -> . Prints
    (21) Inst -> . Repeat
    (22) Inst -> . For
    (23) Inst -> . While
    (24) Inst -> . Read
    (25) Inst -> . If
    (43) Attr -> . id = Exp
    (44) Attr -> . id [ Exp ] = Exp
    (45) Attr -> . id [ Exp ] [ Exp ] = Exp
    (46) Attr -> . gid = Exp
    (47) Attr -> . gid [ Exp ] = Exp
    (48) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (49) Return -> . return ( Exp )
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (31) Print -> . print ( Exp )
    (32) Println -> . println ( Exp )
    (33) Prints -> . prints ( string )
    (26) Repeat -> . RepeatS ( num ) { Insts }
    (28) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (29) While -> . while ( Cond ) { Insts }
    (30) Read -> . read ( id )
    (50) If -> . if ( Cond ) { Insts }
    (51) If -> . if ( Cond ) Inst
    (53) If -> . if ( Cond ) { Insts } else { Insts }
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (27) RepeatS -> . repeat
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    }               shift and go to state 23
    id              shift and go to state 36
    gid             shift and go to state 37
    return          shift and go to state 38
    print           shift and go to state 41
    println         shift and go to state 42
    prints          shift and go to state 43
    for             shift and go to state 46
    while           shift and go to state 47
    read            shift and go to state 48
    if              shift and go to state 49
    repeat          shift and go to state 51
    num             shift and go to state 45
    (               shift and go to state 39

    Inst                           shift and go to state 24
    Attr                           shift and go to state 25
    Return                         shift and go to state 26
    Exp                            shift and go to state 27
    Print                          shift and go to state 28
    Println                        shift and go to state 29
    Prints                         shift and go to state 30
    Repeat                         shift and go to state 31
    For                            shift and go to state 32
    While                          shift and go to state 33
    Read                           shift and go to state 34
    If                             shift and go to state 35
    Term                           shift and go to state 40
    RepeatS                        shift and go to state 44
    Factor                         shift and go to state 50

state 20

    (34) BlcInt -> int { . Dcls }
    (10) Dcls -> . Dcls Dcl
    (11) Dcls -> .

    }               reduce using rule 11 (Dcls -> .)
    id              reduce using rule 11 (Dcls -> .)

    Dcls                           shift and go to state 52

state 21

    (39) DclGlobal -> int id . [ num ]
    (40) DclGlobal -> int id . [ num ] [ num ]
    (41) DclGlobal -> int id .
    (42) DclGlobal -> int id . = num

    [               shift and go to state 53
    }               reduce using rule 41 (DclGlobal -> int id .)
    int             reduce using rule 41 (DclGlobal -> int id .)
    =               shift and go to state 54


state 22

    (4) DefBlc -> id { VarBlc . Insts }
    (13) Insts -> . Insts Inst
    (14) Insts -> .

    }               reduce using rule 14 (Insts -> .)
    id              reduce using rule 14 (Insts -> .)
    gid             reduce using rule 14 (Insts -> .)
    return          reduce using rule 14 (Insts -> .)
    print           reduce using rule 14 (Insts -> .)
    println         reduce using rule 14 (Insts -> .)
    prints          reduce using rule 14 (Insts -> .)
    for             reduce using rule 14 (Insts -> .)
    while           reduce using rule 14 (Insts -> .)
    read            reduce using rule 14 (Insts -> .)
    if              reduce using rule 14 (Insts -> .)
    repeat          reduce using rule 14 (Insts -> .)
    num             reduce using rule 14 (Insts -> .)
    (               reduce using rule 14 (Insts -> .)

    Insts                          shift and go to state 55

state 23

    (12) MainBlc -> main { VarBlc Insts } .

    id              reduce using rule 12 (MainBlc -> main { VarBlc Insts } .)
    $end            reduce using rule 12 (MainBlc -> main { VarBlc Insts } .)


state 24

    (13) Insts -> Insts Inst .

    }               reduce using rule 13 (Insts -> Insts Inst .)
    id              reduce using rule 13 (Insts -> Insts Inst .)
    gid             reduce using rule 13 (Insts -> Insts Inst .)
    return          reduce using rule 13 (Insts -> Insts Inst .)
    print           reduce using rule 13 (Insts -> Insts Inst .)
    println         reduce using rule 13 (Insts -> Insts Inst .)
    prints          reduce using rule 13 (Insts -> Insts Inst .)
    for             reduce using rule 13 (Insts -> Insts Inst .)
    while           reduce using rule 13 (Insts -> Insts Inst .)
    read            reduce using rule 13 (Insts -> Insts Inst .)
    if              reduce using rule 13 (Insts -> Insts Inst .)
    repeat          reduce using rule 13 (Insts -> Insts Inst .)
    num             reduce using rule 13 (Insts -> Insts Inst .)
    (               reduce using rule 13 (Insts -> Insts Inst .)
    ;               reduce using rule 13 (Insts -> Insts Inst .)
    )               reduce using rule 13 (Insts -> Insts Inst .)


state 25

    (15) Inst -> Attr .

    }               reduce using rule 15 (Inst -> Attr .)
    id              reduce using rule 15 (Inst -> Attr .)
    gid             reduce using rule 15 (Inst -> Attr .)
    return          reduce using rule 15 (Inst -> Attr .)
    print           reduce using rule 15 (Inst -> Attr .)
    println         reduce using rule 15 (Inst -> Attr .)
    prints          reduce using rule 15 (Inst -> Attr .)
    for             reduce using rule 15 (Inst -> Attr .)
    while           reduce using rule 15 (Inst -> Attr .)
    read            reduce using rule 15 (Inst -> Attr .)
    if              reduce using rule 15 (Inst -> Attr .)
    repeat          reduce using rule 15 (Inst -> Attr .)
    num             reduce using rule 15 (Inst -> Attr .)
    (               reduce using rule 15 (Inst -> Attr .)
    ;               reduce using rule 15 (Inst -> Attr .)
    )               reduce using rule 15 (Inst -> Attr .)


state 26

    (16) Inst -> Return .

    }               reduce using rule 16 (Inst -> Return .)
    id              reduce using rule 16 (Inst -> Return .)
    gid             reduce using rule 16 (Inst -> Return .)
    return          reduce using rule 16 (Inst -> Return .)
    print           reduce using rule 16 (Inst -> Return .)
    println         reduce using rule 16 (Inst -> Return .)
    prints          reduce using rule 16 (Inst -> Return .)
    for             reduce using rule 16 (Inst -> Return .)
    while           reduce using rule 16 (Inst -> Return .)
    read            reduce using rule 16 (Inst -> Return .)
    if              reduce using rule 16 (Inst -> Return .)
    repeat          reduce using rule 16 (Inst -> Return .)
    num             reduce using rule 16 (Inst -> Return .)
    (               reduce using rule 16 (Inst -> Return .)
    ;               reduce using rule 16 (Inst -> Return .)
    )               reduce using rule 16 (Inst -> Return .)


state 27

    (17) Inst -> Exp .
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    }               reduce using rule 17 (Inst -> Exp .)
    id              reduce using rule 17 (Inst -> Exp .)
    gid             reduce using rule 17 (Inst -> Exp .)
    return          reduce using rule 17 (Inst -> Exp .)
    print           reduce using rule 17 (Inst -> Exp .)
    println         reduce using rule 17 (Inst -> Exp .)
    prints          reduce using rule 17 (Inst -> Exp .)
    for             reduce using rule 17 (Inst -> Exp .)
    while           reduce using rule 17 (Inst -> Exp .)
    read            reduce using rule 17 (Inst -> Exp .)
    if              reduce using rule 17 (Inst -> Exp .)
    repeat          reduce using rule 17 (Inst -> Exp .)
    num             reduce using rule 17 (Inst -> Exp .)
    (               reduce using rule 17 (Inst -> Exp .)
    ;               reduce using rule 17 (Inst -> Exp .)
    )               reduce using rule 17 (Inst -> Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 28

    (18) Inst -> Print .

    }               reduce using rule 18 (Inst -> Print .)
    id              reduce using rule 18 (Inst -> Print .)
    gid             reduce using rule 18 (Inst -> Print .)
    return          reduce using rule 18 (Inst -> Print .)
    print           reduce using rule 18 (Inst -> Print .)
    println         reduce using rule 18 (Inst -> Print .)
    prints          reduce using rule 18 (Inst -> Print .)
    for             reduce using rule 18 (Inst -> Print .)
    while           reduce using rule 18 (Inst -> Print .)
    read            reduce using rule 18 (Inst -> Print .)
    if              reduce using rule 18 (Inst -> Print .)
    repeat          reduce using rule 18 (Inst -> Print .)
    num             reduce using rule 18 (Inst -> Print .)
    (               reduce using rule 18 (Inst -> Print .)
    ;               reduce using rule 18 (Inst -> Print .)
    )               reduce using rule 18 (Inst -> Print .)


state 29

    (19) Inst -> Println .

    }               reduce using rule 19 (Inst -> Println .)
    id              reduce using rule 19 (Inst -> Println .)
    gid             reduce using rule 19 (Inst -> Println .)
    return          reduce using rule 19 (Inst -> Println .)
    print           reduce using rule 19 (Inst -> Println .)
    println         reduce using rule 19 (Inst -> Println .)
    prints          reduce using rule 19 (Inst -> Println .)
    for             reduce using rule 19 (Inst -> Println .)
    while           reduce using rule 19 (Inst -> Println .)
    read            reduce using rule 19 (Inst -> Println .)
    if              reduce using rule 19 (Inst -> Println .)
    repeat          reduce using rule 19 (Inst -> Println .)
    num             reduce using rule 19 (Inst -> Println .)
    (               reduce using rule 19 (Inst -> Println .)
    ;               reduce using rule 19 (Inst -> Println .)
    )               reduce using rule 19 (Inst -> Println .)


state 30

    (20) Inst -> Prints .

    }               reduce using rule 20 (Inst -> Prints .)
    id              reduce using rule 20 (Inst -> Prints .)
    gid             reduce using rule 20 (Inst -> Prints .)
    return          reduce using rule 20 (Inst -> Prints .)
    print           reduce using rule 20 (Inst -> Prints .)
    println         reduce using rule 20 (Inst -> Prints .)
    prints          reduce using rule 20 (Inst -> Prints .)
    for             reduce using rule 20 (Inst -> Prints .)
    while           reduce using rule 20 (Inst -> Prints .)
    read            reduce using rule 20 (Inst -> Prints .)
    if              reduce using rule 20 (Inst -> Prints .)
    repeat          reduce using rule 20 (Inst -> Prints .)
    num             reduce using rule 20 (Inst -> Prints .)
    (               reduce using rule 20 (Inst -> Prints .)
    ;               reduce using rule 20 (Inst -> Prints .)
    )               reduce using rule 20 (Inst -> Prints .)


state 31

    (21) Inst -> Repeat .

    }               reduce using rule 21 (Inst -> Repeat .)
    id              reduce using rule 21 (Inst -> Repeat .)
    gid             reduce using rule 21 (Inst -> Repeat .)
    return          reduce using rule 21 (Inst -> Repeat .)
    print           reduce using rule 21 (Inst -> Repeat .)
    println         reduce using rule 21 (Inst -> Repeat .)
    prints          reduce using rule 21 (Inst -> Repeat .)
    for             reduce using rule 21 (Inst -> Repeat .)
    while           reduce using rule 21 (Inst -> Repeat .)
    read            reduce using rule 21 (Inst -> Repeat .)
    if              reduce using rule 21 (Inst -> Repeat .)
    repeat          reduce using rule 21 (Inst -> Repeat .)
    num             reduce using rule 21 (Inst -> Repeat .)
    (               reduce using rule 21 (Inst -> Repeat .)
    ;               reduce using rule 21 (Inst -> Repeat .)
    )               reduce using rule 21 (Inst -> Repeat .)


state 32

    (22) Inst -> For .

    }               reduce using rule 22 (Inst -> For .)
    id              reduce using rule 22 (Inst -> For .)
    gid             reduce using rule 22 (Inst -> For .)
    return          reduce using rule 22 (Inst -> For .)
    print           reduce using rule 22 (Inst -> For .)
    println         reduce using rule 22 (Inst -> For .)
    prints          reduce using rule 22 (Inst -> For .)
    for             reduce using rule 22 (Inst -> For .)
    while           reduce using rule 22 (Inst -> For .)
    read            reduce using rule 22 (Inst -> For .)
    if              reduce using rule 22 (Inst -> For .)
    repeat          reduce using rule 22 (Inst -> For .)
    num             reduce using rule 22 (Inst -> For .)
    (               reduce using rule 22 (Inst -> For .)
    ;               reduce using rule 22 (Inst -> For .)
    )               reduce using rule 22 (Inst -> For .)


state 33

    (23) Inst -> While .

    }               reduce using rule 23 (Inst -> While .)
    id              reduce using rule 23 (Inst -> While .)
    gid             reduce using rule 23 (Inst -> While .)
    return          reduce using rule 23 (Inst -> While .)
    print           reduce using rule 23 (Inst -> While .)
    println         reduce using rule 23 (Inst -> While .)
    prints          reduce using rule 23 (Inst -> While .)
    for             reduce using rule 23 (Inst -> While .)
    while           reduce using rule 23 (Inst -> While .)
    read            reduce using rule 23 (Inst -> While .)
    if              reduce using rule 23 (Inst -> While .)
    repeat          reduce using rule 23 (Inst -> While .)
    num             reduce using rule 23 (Inst -> While .)
    (               reduce using rule 23 (Inst -> While .)
    ;               reduce using rule 23 (Inst -> While .)
    )               reduce using rule 23 (Inst -> While .)


state 34

    (24) Inst -> Read .

    }               reduce using rule 24 (Inst -> Read .)
    id              reduce using rule 24 (Inst -> Read .)
    gid             reduce using rule 24 (Inst -> Read .)
    return          reduce using rule 24 (Inst -> Read .)
    print           reduce using rule 24 (Inst -> Read .)
    println         reduce using rule 24 (Inst -> Read .)
    prints          reduce using rule 24 (Inst -> Read .)
    for             reduce using rule 24 (Inst -> Read .)
    while           reduce using rule 24 (Inst -> Read .)
    read            reduce using rule 24 (Inst -> Read .)
    if              reduce using rule 24 (Inst -> Read .)
    repeat          reduce using rule 24 (Inst -> Read .)
    num             reduce using rule 24 (Inst -> Read .)
    (               reduce using rule 24 (Inst -> Read .)
    ;               reduce using rule 24 (Inst -> Read .)
    )               reduce using rule 24 (Inst -> Read .)


state 35

    (25) Inst -> If .

    }               reduce using rule 25 (Inst -> If .)
    id              reduce using rule 25 (Inst -> If .)
    gid             reduce using rule 25 (Inst -> If .)
    return          reduce using rule 25 (Inst -> If .)
    print           reduce using rule 25 (Inst -> If .)
    println         reduce using rule 25 (Inst -> If .)
    prints          reduce using rule 25 (Inst -> If .)
    for             reduce using rule 25 (Inst -> If .)
    while           reduce using rule 25 (Inst -> If .)
    read            reduce using rule 25 (Inst -> If .)
    if              reduce using rule 25 (Inst -> If .)
    repeat          reduce using rule 25 (Inst -> If .)
    num             reduce using rule 25 (Inst -> If .)
    (               reduce using rule 25 (Inst -> If .)
    ;               reduce using rule 25 (Inst -> If .)
    )               reduce using rule 25 (Inst -> If .)


state 36

    (43) Attr -> id . = Exp
    (44) Attr -> id . [ Exp ] = Exp
    (45) Attr -> id . [ Exp ] [ Exp ] = Exp
    (57) Exp -> id . addeq Term
    (58) Exp -> id . subeq Term
    (59) Exp -> id . addeql Term
    (60) Exp -> id . subeql Term
    (65) Term -> id . muleq Factor
    (66) Term -> id . diveq Factor
    (67) Term -> id . modeq Factor
    (68) Term -> id . muleql Factor
    (69) Term -> id . diveql Factor
    (70) Term -> id . modeql Factor
    (72) Factor -> id . plus
    (73) Factor -> id . plusl
    (74) Factor -> id . minus
    (75) Factor -> id . minusl
    (76) Factor -> id .
    (79) Factor -> id . ( )
    (81) Factor -> id . [ Exp ]
    (82) Factor -> id . [ Exp ] [ Exp ]

  ! shift/reduce conflict for ( resolved as shift
    =               shift and go to state 58
    [               shift and go to state 59
    addeq           shift and go to state 60
    subeq           shift and go to state 61
    addeql          shift and go to state 62
    subeql          shift and go to state 63
    muleq           shift and go to state 64
    diveq           shift and go to state 65
    modeq           shift and go to state 66
    muleql          shift and go to state 67
    diveql          shift and go to state 68
    modeql          shift and go to state 69
    plus            shift and go to state 70
    plusl           shift and go to state 71
    minus           shift and go to state 72
    minusl          shift and go to state 73
    *               reduce using rule 76 (Factor -> id .)
    /               reduce using rule 76 (Factor -> id .)
    %               reduce using rule 76 (Factor -> id .)
    +               reduce using rule 76 (Factor -> id .)
    -               reduce using rule 76 (Factor -> id .)
    }               reduce using rule 76 (Factor -> id .)
    id              reduce using rule 76 (Factor -> id .)
    gid             reduce using rule 76 (Factor -> id .)
    return          reduce using rule 76 (Factor -> id .)
    print           reduce using rule 76 (Factor -> id .)
    println         reduce using rule 76 (Factor -> id .)
    prints          reduce using rule 76 (Factor -> id .)
    for             reduce using rule 76 (Factor -> id .)
    while           reduce using rule 76 (Factor -> id .)
    read            reduce using rule 76 (Factor -> id .)
    if              reduce using rule 76 (Factor -> id .)
    repeat          reduce using rule 76 (Factor -> id .)
    num             reduce using rule 76 (Factor -> id .)
    ;               reduce using rule 76 (Factor -> id .)
    )               reduce using rule 76 (Factor -> id .)
    (               shift and go to state 74

  ! (               [ reduce using rule 76 (Factor -> id .) ]


state 37

    (46) Attr -> gid . = Exp
    (47) Attr -> gid . [ Exp ] = Exp
    (48) Attr -> gid . [ Exp ] [ Exp ] = Exp
    (77) Factor -> gid .
    (83) Factor -> gid . [ Exp ]
    (84) Factor -> gid . [ Exp ] [ Exp ]

    =               shift and go to state 75
    [               shift and go to state 76
    *               reduce using rule 77 (Factor -> gid .)
    /               reduce using rule 77 (Factor -> gid .)
    %               reduce using rule 77 (Factor -> gid .)
    +               reduce using rule 77 (Factor -> gid .)
    -               reduce using rule 77 (Factor -> gid .)
    }               reduce using rule 77 (Factor -> gid .)
    id              reduce using rule 77 (Factor -> gid .)
    gid             reduce using rule 77 (Factor -> gid .)
    return          reduce using rule 77 (Factor -> gid .)
    print           reduce using rule 77 (Factor -> gid .)
    println         reduce using rule 77 (Factor -> gid .)
    prints          reduce using rule 77 (Factor -> gid .)
    for             reduce using rule 77 (Factor -> gid .)
    while           reduce using rule 77 (Factor -> gid .)
    read            reduce using rule 77 (Factor -> gid .)
    if              reduce using rule 77 (Factor -> gid .)
    repeat          reduce using rule 77 (Factor -> gid .)
    num             reduce using rule 77 (Factor -> gid .)
    (               reduce using rule 77 (Factor -> gid .)
    ;               reduce using rule 77 (Factor -> gid .)
    )               reduce using rule 77 (Factor -> gid .)


state 38

    (49) Return -> return . ( Exp )

    (               shift and go to state 77


state 39

    (80) Factor -> ( . Cond )
    (85) Factor -> ( . Exp )
    (89) Cond -> . Cond and Cond
    (90) Cond -> . Cond or Cond
    (91) Cond -> . ( Cond and Cond )
    (92) Cond -> . ( Cond or Cond )
    (93) Cond -> . Exp sup Exp
    (94) Cond -> . Exp inf Exp
    (95) Cond -> . Exp supeq Exp
    (96) Cond -> . Exp infeq Exp
    (97) Cond -> . not Exp
    (98) Cond -> . Exp eq Exp
    (99) Cond -> . Exp diff Exp
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    (               shift and go to state 78
    not             shift and go to state 81
    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45

    Cond                           shift and go to state 79
    Exp                            shift and go to state 80
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 40

    (61) Exp -> Term .
    (62) Term -> Term . * Factor
    (63) Term -> Term . / Factor
    (64) Term -> Term . % Factor

    +               reduce using rule 61 (Exp -> Term .)
    -               reduce using rule 61 (Exp -> Term .)
    }               reduce using rule 61 (Exp -> Term .)
    id              reduce using rule 61 (Exp -> Term .)
    gid             reduce using rule 61 (Exp -> Term .)
    return          reduce using rule 61 (Exp -> Term .)
    print           reduce using rule 61 (Exp -> Term .)
    println         reduce using rule 61 (Exp -> Term .)
    prints          reduce using rule 61 (Exp -> Term .)
    for             reduce using rule 61 (Exp -> Term .)
    while           reduce using rule 61 (Exp -> Term .)
    read            reduce using rule 61 (Exp -> Term .)
    if              reduce using rule 61 (Exp -> Term .)
    repeat          reduce using rule 61 (Exp -> Term .)
    num             reduce using rule 61 (Exp -> Term .)
    (               reduce using rule 61 (Exp -> Term .)
    )               reduce using rule 61 (Exp -> Term .)
    sup             reduce using rule 61 (Exp -> Term .)
    inf             reduce using rule 61 (Exp -> Term .)
    supeq           reduce using rule 61 (Exp -> Term .)
    infeq           reduce using rule 61 (Exp -> Term .)
    eq              reduce using rule 61 (Exp -> Term .)
    diff            reduce using rule 61 (Exp -> Term .)
    ;               reduce using rule 61 (Exp -> Term .)
    ]               reduce using rule 61 (Exp -> Term .)
    and             reduce using rule 61 (Exp -> Term .)
    or              reduce using rule 61 (Exp -> Term .)
    *               shift and go to state 84
    /               shift and go to state 85
    %               shift and go to state 86


state 41

    (31) Print -> print . ( Exp )

    (               shift and go to state 87


state 42

    (32) Println -> println . ( Exp )

    (               shift and go to state 88


state 43

    (33) Prints -> prints . ( string )

    (               shift and go to state 89


state 44

    (26) Repeat -> RepeatS . ( num ) { Insts }

    (               shift and go to state 90


state 45

    (78) Factor -> num .

    *               reduce using rule 78 (Factor -> num .)
    /               reduce using rule 78 (Factor -> num .)
    %               reduce using rule 78 (Factor -> num .)
    +               reduce using rule 78 (Factor -> num .)
    -               reduce using rule 78 (Factor -> num .)
    }               reduce using rule 78 (Factor -> num .)
    id              reduce using rule 78 (Factor -> num .)
    gid             reduce using rule 78 (Factor -> num .)
    return          reduce using rule 78 (Factor -> num .)
    print           reduce using rule 78 (Factor -> num .)
    println         reduce using rule 78 (Factor -> num .)
    prints          reduce using rule 78 (Factor -> num .)
    for             reduce using rule 78 (Factor -> num .)
    while           reduce using rule 78 (Factor -> num .)
    read            reduce using rule 78 (Factor -> num .)
    if              reduce using rule 78 (Factor -> num .)
    repeat          reduce using rule 78 (Factor -> num .)
    num             reduce using rule 78 (Factor -> num .)
    (               reduce using rule 78 (Factor -> num .)
    )               reduce using rule 78 (Factor -> num .)
    sup             reduce using rule 78 (Factor -> num .)
    inf             reduce using rule 78 (Factor -> num .)
    supeq           reduce using rule 78 (Factor -> num .)
    infeq           reduce using rule 78 (Factor -> num .)
    eq              reduce using rule 78 (Factor -> num .)
    diff            reduce using rule 78 (Factor -> num .)
    ;               reduce using rule 78 (Factor -> num .)
    ]               reduce using rule 78 (Factor -> num .)
    and             reduce using rule 78 (Factor -> num .)
    or              reduce using rule 78 (Factor -> num .)


state 46

    (28) For -> for . ( Insts ; Cond ; Insts ) { Insts }

    (               shift and go to state 91


state 47

    (29) While -> while . ( Cond ) { Insts }

    (               shift and go to state 92


state 48

    (30) Read -> read . ( id )

    (               shift and go to state 93


state 49

    (50) If -> if . ( Cond ) { Insts }
    (51) If -> if . ( Cond ) Inst
    (53) If -> if . ( Cond ) { Insts } else { Insts }

    (               shift and go to state 94


state 50

    (71) Term -> Factor .

    *               reduce using rule 71 (Term -> Factor .)
    /               reduce using rule 71 (Term -> Factor .)
    %               reduce using rule 71 (Term -> Factor .)
    +               reduce using rule 71 (Term -> Factor .)
    -               reduce using rule 71 (Term -> Factor .)
    }               reduce using rule 71 (Term -> Factor .)
    id              reduce using rule 71 (Term -> Factor .)
    gid             reduce using rule 71 (Term -> Factor .)
    return          reduce using rule 71 (Term -> Factor .)
    print           reduce using rule 71 (Term -> Factor .)
    println         reduce using rule 71 (Term -> Factor .)
    prints          reduce using rule 71 (Term -> Factor .)
    for             reduce using rule 71 (Term -> Factor .)
    while           reduce using rule 71 (Term -> Factor .)
    read            reduce using rule 71 (Term -> Factor .)
    if              reduce using rule 71 (Term -> Factor .)
    repeat          reduce using rule 71 (Term -> Factor .)
    num             reduce using rule 71 (Term -> Factor .)
    (               reduce using rule 71 (Term -> Factor .)
    )               reduce using rule 71 (Term -> Factor .)
    sup             reduce using rule 71 (Term -> Factor .)
    inf             reduce using rule 71 (Term -> Factor .)
    supeq           reduce using rule 71 (Term -> Factor .)
    infeq           reduce using rule 71 (Term -> Factor .)
    eq              reduce using rule 71 (Term -> Factor .)
    diff            reduce using rule 71 (Term -> Factor .)
    ;               reduce using rule 71 (Term -> Factor .)
    ]               reduce using rule 71 (Term -> Factor .)
    and             reduce using rule 71 (Term -> Factor .)
    or              reduce using rule 71 (Term -> Factor .)


state 51

    (27) RepeatS -> repeat .

    (               reduce using rule 27 (RepeatS -> repeat .)


state 52

    (34) BlcInt -> int { Dcls . }
    (10) Dcls -> Dcls . Dcl
    (35) Dcl -> . id [ num ]
    (36) Dcl -> . id [ num ] [ num ]
    (37) Dcl -> . id
    (38) Dcl -> . id = num

    }               shift and go to state 95
    id              shift and go to state 97

    Dcl                            shift and go to state 96

state 53

    (39) DclGlobal -> int id [ . num ]
    (40) DclGlobal -> int id [ . num ] [ num ]

    num             shift and go to state 98


state 54

    (42) DclGlobal -> int id = . num

    num             shift and go to state 99


state 55

    (4) DefBlc -> id { VarBlc Insts . }
    (13) Insts -> Insts . Inst
    (15) Inst -> . Attr
    (16) Inst -> . Return
    (17) Inst -> . Exp
    (18) Inst -> . Print
    (19) Inst -> . Println
    (20) Inst -> . Prints
    (21) Inst -> . Repeat
    (22) Inst -> . For
    (23) Inst -> . While
    (24) Inst -> . Read
    (25) Inst -> . If
    (43) Attr -> . id = Exp
    (44) Attr -> . id [ Exp ] = Exp
    (45) Attr -> . id [ Exp ] [ Exp ] = Exp
    (46) Attr -> . gid = Exp
    (47) Attr -> . gid [ Exp ] = Exp
    (48) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (49) Return -> . return ( Exp )
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (31) Print -> . print ( Exp )
    (32) Println -> . println ( Exp )
    (33) Prints -> . prints ( string )
    (26) Repeat -> . RepeatS ( num ) { Insts }
    (28) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (29) While -> . while ( Cond ) { Insts }
    (30) Read -> . read ( id )
    (50) If -> . if ( Cond ) { Insts }
    (51) If -> . if ( Cond ) Inst
    (53) If -> . if ( Cond ) { Insts } else { Insts }
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (27) RepeatS -> . repeat
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    }               shift and go to state 100
    id              shift and go to state 36
    gid             shift and go to state 37
    return          shift and go to state 38
    print           shift and go to state 41
    println         shift and go to state 42
    prints          shift and go to state 43
    for             shift and go to state 46
    while           shift and go to state 47
    read            shift and go to state 48
    if              shift and go to state 49
    repeat          shift and go to state 51
    num             shift and go to state 45
    (               shift and go to state 39

    Inst                           shift and go to state 24
    Attr                           shift and go to state 25
    Return                         shift and go to state 26
    Exp                            shift and go to state 27
    Print                          shift and go to state 28
    Println                        shift and go to state 29
    Prints                         shift and go to state 30
    Repeat                         shift and go to state 31
    For                            shift and go to state 32
    While                          shift and go to state 33
    Read                           shift and go to state 34
    If                             shift and go to state 35
    Term                           shift and go to state 40
    RepeatS                        shift and go to state 44
    Factor                         shift and go to state 50

state 56

    (55) Exp -> Exp + . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 102
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Term                           shift and go to state 101
    Factor                         shift and go to state 50

state 57

    (56) Exp -> Exp - . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 102
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Term                           shift and go to state 103
    Factor                         shift and go to state 50

state 58

    (43) Attr -> id = . Exp
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 104
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 59

    (44) Attr -> id [ . Exp ] = Exp
    (45) Attr -> id [ . Exp ] [ Exp ] = Exp
    (81) Factor -> id [ . Exp ]
    (82) Factor -> id [ . Exp ] [ Exp ]
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 105
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 60

    (57) Exp -> id addeq . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 102
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Term                           shift and go to state 106
    Factor                         shift and go to state 50

state 61

    (58) Exp -> id subeq . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 102
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Term                           shift and go to state 107
    Factor                         shift and go to state 50

state 62

    (59) Exp -> id addeql . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 102
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Term                           shift and go to state 108
    Factor                         shift and go to state 50

state 63

    (60) Exp -> id subeql . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 102
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Term                           shift and go to state 109
    Factor                         shift and go to state 50

state 64

    (65) Term -> id muleq . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 110
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Factor                         shift and go to state 111

state 65

    (66) Term -> id diveq . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 110
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Factor                         shift and go to state 112

state 66

    (67) Term -> id modeq . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 110
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Factor                         shift and go to state 113

state 67

    (68) Term -> id muleql . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 110
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Factor                         shift and go to state 114

state 68

    (69) Term -> id diveql . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 110
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Factor                         shift and go to state 115

state 69

    (70) Term -> id modeql . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 110
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Factor                         shift and go to state 116

state 70

    (72) Factor -> id plus .

    *               reduce using rule 72 (Factor -> id plus .)
    /               reduce using rule 72 (Factor -> id plus .)
    %               reduce using rule 72 (Factor -> id plus .)
    +               reduce using rule 72 (Factor -> id plus .)
    -               reduce using rule 72 (Factor -> id plus .)
    }               reduce using rule 72 (Factor -> id plus .)
    id              reduce using rule 72 (Factor -> id plus .)
    gid             reduce using rule 72 (Factor -> id plus .)
    return          reduce using rule 72 (Factor -> id plus .)
    print           reduce using rule 72 (Factor -> id plus .)
    println         reduce using rule 72 (Factor -> id plus .)
    prints          reduce using rule 72 (Factor -> id plus .)
    for             reduce using rule 72 (Factor -> id plus .)
    while           reduce using rule 72 (Factor -> id plus .)
    read            reduce using rule 72 (Factor -> id plus .)
    if              reduce using rule 72 (Factor -> id plus .)
    repeat          reduce using rule 72 (Factor -> id plus .)
    num             reduce using rule 72 (Factor -> id plus .)
    (               reduce using rule 72 (Factor -> id plus .)
    )               reduce using rule 72 (Factor -> id plus .)
    sup             reduce using rule 72 (Factor -> id plus .)
    inf             reduce using rule 72 (Factor -> id plus .)
    supeq           reduce using rule 72 (Factor -> id plus .)
    infeq           reduce using rule 72 (Factor -> id plus .)
    eq              reduce using rule 72 (Factor -> id plus .)
    diff            reduce using rule 72 (Factor -> id plus .)
    ;               reduce using rule 72 (Factor -> id plus .)
    ]               reduce using rule 72 (Factor -> id plus .)
    and             reduce using rule 72 (Factor -> id plus .)
    or              reduce using rule 72 (Factor -> id plus .)


state 71

    (73) Factor -> id plusl .

    *               reduce using rule 73 (Factor -> id plusl .)
    /               reduce using rule 73 (Factor -> id plusl .)
    %               reduce using rule 73 (Factor -> id plusl .)
    +               reduce using rule 73 (Factor -> id plusl .)
    -               reduce using rule 73 (Factor -> id plusl .)
    }               reduce using rule 73 (Factor -> id plusl .)
    id              reduce using rule 73 (Factor -> id plusl .)
    gid             reduce using rule 73 (Factor -> id plusl .)
    return          reduce using rule 73 (Factor -> id plusl .)
    print           reduce using rule 73 (Factor -> id plusl .)
    println         reduce using rule 73 (Factor -> id plusl .)
    prints          reduce using rule 73 (Factor -> id plusl .)
    for             reduce using rule 73 (Factor -> id plusl .)
    while           reduce using rule 73 (Factor -> id plusl .)
    read            reduce using rule 73 (Factor -> id plusl .)
    if              reduce using rule 73 (Factor -> id plusl .)
    repeat          reduce using rule 73 (Factor -> id plusl .)
    num             reduce using rule 73 (Factor -> id plusl .)
    (               reduce using rule 73 (Factor -> id plusl .)
    )               reduce using rule 73 (Factor -> id plusl .)
    sup             reduce using rule 73 (Factor -> id plusl .)
    inf             reduce using rule 73 (Factor -> id plusl .)
    supeq           reduce using rule 73 (Factor -> id plusl .)
    infeq           reduce using rule 73 (Factor -> id plusl .)
    eq              reduce using rule 73 (Factor -> id plusl .)
    diff            reduce using rule 73 (Factor -> id plusl .)
    ;               reduce using rule 73 (Factor -> id plusl .)
    ]               reduce using rule 73 (Factor -> id plusl .)
    and             reduce using rule 73 (Factor -> id plusl .)
    or              reduce using rule 73 (Factor -> id plusl .)


state 72

    (74) Factor -> id minus .

    *               reduce using rule 74 (Factor -> id minus .)
    /               reduce using rule 74 (Factor -> id minus .)
    %               reduce using rule 74 (Factor -> id minus .)
    +               reduce using rule 74 (Factor -> id minus .)
    -               reduce using rule 74 (Factor -> id minus .)
    }               reduce using rule 74 (Factor -> id minus .)
    id              reduce using rule 74 (Factor -> id minus .)
    gid             reduce using rule 74 (Factor -> id minus .)
    return          reduce using rule 74 (Factor -> id minus .)
    print           reduce using rule 74 (Factor -> id minus .)
    println         reduce using rule 74 (Factor -> id minus .)
    prints          reduce using rule 74 (Factor -> id minus .)
    for             reduce using rule 74 (Factor -> id minus .)
    while           reduce using rule 74 (Factor -> id minus .)
    read            reduce using rule 74 (Factor -> id minus .)
    if              reduce using rule 74 (Factor -> id minus .)
    repeat          reduce using rule 74 (Factor -> id minus .)
    num             reduce using rule 74 (Factor -> id minus .)
    (               reduce using rule 74 (Factor -> id minus .)
    )               reduce using rule 74 (Factor -> id minus .)
    sup             reduce using rule 74 (Factor -> id minus .)
    inf             reduce using rule 74 (Factor -> id minus .)
    supeq           reduce using rule 74 (Factor -> id minus .)
    infeq           reduce using rule 74 (Factor -> id minus .)
    eq              reduce using rule 74 (Factor -> id minus .)
    diff            reduce using rule 74 (Factor -> id minus .)
    ;               reduce using rule 74 (Factor -> id minus .)
    ]               reduce using rule 74 (Factor -> id minus .)
    and             reduce using rule 74 (Factor -> id minus .)
    or              reduce using rule 74 (Factor -> id minus .)


state 73

    (75) Factor -> id minusl .

    *               reduce using rule 75 (Factor -> id minusl .)
    /               reduce using rule 75 (Factor -> id minusl .)
    %               reduce using rule 75 (Factor -> id minusl .)
    +               reduce using rule 75 (Factor -> id minusl .)
    -               reduce using rule 75 (Factor -> id minusl .)
    }               reduce using rule 75 (Factor -> id minusl .)
    id              reduce using rule 75 (Factor -> id minusl .)
    gid             reduce using rule 75 (Factor -> id minusl .)
    return          reduce using rule 75 (Factor -> id minusl .)
    print           reduce using rule 75 (Factor -> id minusl .)
    println         reduce using rule 75 (Factor -> id minusl .)
    prints          reduce using rule 75 (Factor -> id minusl .)
    for             reduce using rule 75 (Factor -> id minusl .)
    while           reduce using rule 75 (Factor -> id minusl .)
    read            reduce using rule 75 (Factor -> id minusl .)
    if              reduce using rule 75 (Factor -> id minusl .)
    repeat          reduce using rule 75 (Factor -> id minusl .)
    num             reduce using rule 75 (Factor -> id minusl .)
    (               reduce using rule 75 (Factor -> id minusl .)
    )               reduce using rule 75 (Factor -> id minusl .)
    sup             reduce using rule 75 (Factor -> id minusl .)
    inf             reduce using rule 75 (Factor -> id minusl .)
    supeq           reduce using rule 75 (Factor -> id minusl .)
    infeq           reduce using rule 75 (Factor -> id minusl .)
    eq              reduce using rule 75 (Factor -> id minusl .)
    diff            reduce using rule 75 (Factor -> id minusl .)
    ;               reduce using rule 75 (Factor -> id minusl .)
    ]               reduce using rule 75 (Factor -> id minusl .)
    and             reduce using rule 75 (Factor -> id minusl .)
    or              reduce using rule 75 (Factor -> id minusl .)


state 74

    (79) Factor -> id ( . )

    )               shift and go to state 117


state 75

    (46) Attr -> gid = . Exp
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 118
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 76

    (47) Attr -> gid [ . Exp ] = Exp
    (48) Attr -> gid [ . Exp ] [ Exp ] = Exp
    (83) Factor -> gid [ . Exp ]
    (84) Factor -> gid [ . Exp ] [ Exp ]
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 119
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 77

    (49) Return -> return ( . Exp )
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 120
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 78

    (91) Cond -> ( . Cond and Cond )
    (92) Cond -> ( . Cond or Cond )
    (80) Factor -> ( . Cond )
    (85) Factor -> ( . Exp )
    (89) Cond -> . Cond and Cond
    (90) Cond -> . Cond or Cond
    (91) Cond -> . ( Cond and Cond )
    (92) Cond -> . ( Cond or Cond )
    (93) Cond -> . Exp sup Exp
    (94) Cond -> . Exp inf Exp
    (95) Cond -> . Exp supeq Exp
    (96) Cond -> . Exp infeq Exp
    (97) Cond -> . not Exp
    (98) Cond -> . Exp eq Exp
    (99) Cond -> . Exp diff Exp
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    (               shift and go to state 78
    not             shift and go to state 81
    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45

    Cond                           shift and go to state 121
    Exp                            shift and go to state 80
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 79

    (80) Factor -> ( Cond . )
    (89) Cond -> Cond . and Cond
    (90) Cond -> Cond . or Cond

    )               shift and go to state 122
    and             shift and go to state 123
    or              shift and go to state 124


state 80

    (85) Factor -> ( Exp . )
    (93) Cond -> Exp . sup Exp
    (94) Cond -> Exp . inf Exp
    (95) Cond -> Exp . supeq Exp
    (96) Cond -> Exp . infeq Exp
    (98) Cond -> Exp . eq Exp
    (99) Cond -> Exp . diff Exp
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    )               shift and go to state 125
    sup             shift and go to state 126
    inf             shift and go to state 127
    supeq           shift and go to state 128
    infeq           shift and go to state 129
    eq              shift and go to state 130
    diff            shift and go to state 131
    +               shift and go to state 56
    -               shift and go to state 57


state 81

    (97) Cond -> not . Exp
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 132
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 82

    (57) Exp -> id . addeq Term
    (58) Exp -> id . subeq Term
    (59) Exp -> id . addeql Term
    (60) Exp -> id . subeql Term
    (65) Term -> id . muleq Factor
    (66) Term -> id . diveq Factor
    (67) Term -> id . modeq Factor
    (68) Term -> id . muleql Factor
    (69) Term -> id . diveql Factor
    (70) Term -> id . modeql Factor
    (72) Factor -> id . plus
    (73) Factor -> id . plusl
    (74) Factor -> id . minus
    (75) Factor -> id . minusl
    (76) Factor -> id .
    (79) Factor -> id . ( )
    (81) Factor -> id . [ Exp ]
    (82) Factor -> id . [ Exp ] [ Exp ]

  ! shift/reduce conflict for ( resolved as shift
    addeq           shift and go to state 60
    subeq           shift and go to state 61
    addeql          shift and go to state 62
    subeql          shift and go to state 63
    muleq           shift and go to state 64
    diveq           shift and go to state 65
    modeq           shift and go to state 66
    muleql          shift and go to state 67
    diveql          shift and go to state 68
    modeql          shift and go to state 69
    plus            shift and go to state 70
    plusl           shift and go to state 71
    minus           shift and go to state 72
    minusl          shift and go to state 73
    *               reduce using rule 76 (Factor -> id .)
    /               reduce using rule 76 (Factor -> id .)
    %               reduce using rule 76 (Factor -> id .)
    )               reduce using rule 76 (Factor -> id .)
    sup             reduce using rule 76 (Factor -> id .)
    inf             reduce using rule 76 (Factor -> id .)
    supeq           reduce using rule 76 (Factor -> id .)
    infeq           reduce using rule 76 (Factor -> id .)
    eq              reduce using rule 76 (Factor -> id .)
    diff            reduce using rule 76 (Factor -> id .)
    +               reduce using rule 76 (Factor -> id .)
    -               reduce using rule 76 (Factor -> id .)
    }               reduce using rule 76 (Factor -> id .)
    id              reduce using rule 76 (Factor -> id .)
    gid             reduce using rule 76 (Factor -> id .)
    return          reduce using rule 76 (Factor -> id .)
    print           reduce using rule 76 (Factor -> id .)
    println         reduce using rule 76 (Factor -> id .)
    prints          reduce using rule 76 (Factor -> id .)
    for             reduce using rule 76 (Factor -> id .)
    while           reduce using rule 76 (Factor -> id .)
    read            reduce using rule 76 (Factor -> id .)
    if              reduce using rule 76 (Factor -> id .)
    repeat          reduce using rule 76 (Factor -> id .)
    num             reduce using rule 76 (Factor -> id .)
    ;               reduce using rule 76 (Factor -> id .)
    ]               reduce using rule 76 (Factor -> id .)
    and             reduce using rule 76 (Factor -> id .)
    or              reduce using rule 76 (Factor -> id .)
    (               shift and go to state 74
    [               shift and go to state 133

  ! (               [ reduce using rule 76 (Factor -> id .) ]


state 83

    (77) Factor -> gid .
    (83) Factor -> gid . [ Exp ]
    (84) Factor -> gid . [ Exp ] [ Exp ]

    *               reduce using rule 77 (Factor -> gid .)
    /               reduce using rule 77 (Factor -> gid .)
    %               reduce using rule 77 (Factor -> gid .)
    )               reduce using rule 77 (Factor -> gid .)
    sup             reduce using rule 77 (Factor -> gid .)
    inf             reduce using rule 77 (Factor -> gid .)
    supeq           reduce using rule 77 (Factor -> gid .)
    infeq           reduce using rule 77 (Factor -> gid .)
    eq              reduce using rule 77 (Factor -> gid .)
    diff            reduce using rule 77 (Factor -> gid .)
    +               reduce using rule 77 (Factor -> gid .)
    -               reduce using rule 77 (Factor -> gid .)
    }               reduce using rule 77 (Factor -> gid .)
    id              reduce using rule 77 (Factor -> gid .)
    gid             reduce using rule 77 (Factor -> gid .)
    return          reduce using rule 77 (Factor -> gid .)
    print           reduce using rule 77 (Factor -> gid .)
    println         reduce using rule 77 (Factor -> gid .)
    prints          reduce using rule 77 (Factor -> gid .)
    for             reduce using rule 77 (Factor -> gid .)
    while           reduce using rule 77 (Factor -> gid .)
    read            reduce using rule 77 (Factor -> gid .)
    if              reduce using rule 77 (Factor -> gid .)
    repeat          reduce using rule 77 (Factor -> gid .)
    num             reduce using rule 77 (Factor -> gid .)
    (               reduce using rule 77 (Factor -> gid .)
    ;               reduce using rule 77 (Factor -> gid .)
    ]               reduce using rule 77 (Factor -> gid .)
    and             reduce using rule 77 (Factor -> gid .)
    or              reduce using rule 77 (Factor -> gid .)
    [               shift and go to state 134


state 84

    (62) Term -> Term * . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 110
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Factor                         shift and go to state 135

state 85

    (63) Term -> Term / . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 110
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Factor                         shift and go to state 136

state 86

    (64) Term -> Term % . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 110
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Factor                         shift and go to state 137

state 87

    (31) Print -> print ( . Exp )
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 138
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 88

    (32) Println -> println ( . Exp )
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 139
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 89

    (33) Prints -> prints ( . string )

    string          shift and go to state 140


state 90

    (26) Repeat -> RepeatS ( . num ) { Insts }

    num             shift and go to state 141


state 91

    (28) For -> for ( . Insts ; Cond ; Insts ) { Insts }
    (13) Insts -> . Insts Inst
    (14) Insts -> .

    ;               reduce using rule 14 (Insts -> .)
    id              reduce using rule 14 (Insts -> .)
    gid             reduce using rule 14 (Insts -> .)
    return          reduce using rule 14 (Insts -> .)
    print           reduce using rule 14 (Insts -> .)
    println         reduce using rule 14 (Insts -> .)
    prints          reduce using rule 14 (Insts -> .)
    for             reduce using rule 14 (Insts -> .)
    while           reduce using rule 14 (Insts -> .)
    read            reduce using rule 14 (Insts -> .)
    if              reduce using rule 14 (Insts -> .)
    repeat          reduce using rule 14 (Insts -> .)
    num             reduce using rule 14 (Insts -> .)
    (               reduce using rule 14 (Insts -> .)

    Insts                          shift and go to state 142

state 92

    (29) While -> while ( . Cond ) { Insts }
    (89) Cond -> . Cond and Cond
    (90) Cond -> . Cond or Cond
    (91) Cond -> . ( Cond and Cond )
    (92) Cond -> . ( Cond or Cond )
    (93) Cond -> . Exp sup Exp
    (94) Cond -> . Exp inf Exp
    (95) Cond -> . Exp supeq Exp
    (96) Cond -> . Exp infeq Exp
    (97) Cond -> . not Exp
    (98) Cond -> . Exp eq Exp
    (99) Cond -> . Exp diff Exp
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    (               shift and go to state 78
    not             shift and go to state 81
    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45

    Cond                           shift and go to state 143
    Exp                            shift and go to state 144
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 93

    (30) Read -> read ( . id )

    id              shift and go to state 145


state 94

    (50) If -> if ( . Cond ) { Insts }
    (51) If -> if ( . Cond ) Inst
    (53) If -> if ( . Cond ) { Insts } else { Insts }
    (89) Cond -> . Cond and Cond
    (90) Cond -> . Cond or Cond
    (91) Cond -> . ( Cond and Cond )
    (92) Cond -> . ( Cond or Cond )
    (93) Cond -> . Exp sup Exp
    (94) Cond -> . Exp inf Exp
    (95) Cond -> . Exp supeq Exp
    (96) Cond -> . Exp infeq Exp
    (97) Cond -> . not Exp
    (98) Cond -> . Exp eq Exp
    (99) Cond -> . Exp diff Exp
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    (               shift and go to state 78
    not             shift and go to state 81
    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45

    Cond                           shift and go to state 146
    Exp                            shift and go to state 144
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 95

    (34) BlcInt -> int { Dcls } .

    }               reduce using rule 34 (BlcInt -> int { Dcls } .)
    id              reduce using rule 34 (BlcInt -> int { Dcls } .)
    gid             reduce using rule 34 (BlcInt -> int { Dcls } .)
    return          reduce using rule 34 (BlcInt -> int { Dcls } .)
    print           reduce using rule 34 (BlcInt -> int { Dcls } .)
    println         reduce using rule 34 (BlcInt -> int { Dcls } .)
    prints          reduce using rule 34 (BlcInt -> int { Dcls } .)
    for             reduce using rule 34 (BlcInt -> int { Dcls } .)
    while           reduce using rule 34 (BlcInt -> int { Dcls } .)
    read            reduce using rule 34 (BlcInt -> int { Dcls } .)
    if              reduce using rule 34 (BlcInt -> int { Dcls } .)
    repeat          reduce using rule 34 (BlcInt -> int { Dcls } .)
    num             reduce using rule 34 (BlcInt -> int { Dcls } .)
    (               reduce using rule 34 (BlcInt -> int { Dcls } .)


state 96

    (10) Dcls -> Dcls Dcl .

    }               reduce using rule 10 (Dcls -> Dcls Dcl .)
    id              reduce using rule 10 (Dcls -> Dcls Dcl .)


state 97

    (35) Dcl -> id . [ num ]
    (36) Dcl -> id . [ num ] [ num ]
    (37) Dcl -> id .
    (38) Dcl -> id . = num

    [               shift and go to state 147
    }               reduce using rule 37 (Dcl -> id .)
    id              reduce using rule 37 (Dcl -> id .)
    =               shift and go to state 148


state 98

    (39) DclGlobal -> int id [ num . ]
    (40) DclGlobal -> int id [ num . ] [ num ]

    ]               shift and go to state 149


state 99

    (42) DclGlobal -> int id = num .

    }               reduce using rule 42 (DclGlobal -> int id = num .)
    int             reduce using rule 42 (DclGlobal -> int id = num .)


state 100

    (4) DefBlc -> id { VarBlc Insts } .

    id              reduce using rule 4 (DefBlc -> id { VarBlc Insts } .)
    $end            reduce using rule 4 (DefBlc -> id { VarBlc Insts } .)


state 101

    (55) Exp -> Exp + Term .
    (62) Term -> Term . * Factor
    (63) Term -> Term . / Factor
    (64) Term -> Term . % Factor

    +               reduce using rule 55 (Exp -> Exp + Term .)
    -               reduce using rule 55 (Exp -> Exp + Term .)
    }               reduce using rule 55 (Exp -> Exp + Term .)
    id              reduce using rule 55 (Exp -> Exp + Term .)
    gid             reduce using rule 55 (Exp -> Exp + Term .)
    return          reduce using rule 55 (Exp -> Exp + Term .)
    print           reduce using rule 55 (Exp -> Exp + Term .)
    println         reduce using rule 55 (Exp -> Exp + Term .)
    prints          reduce using rule 55 (Exp -> Exp + Term .)
    for             reduce using rule 55 (Exp -> Exp + Term .)
    while           reduce using rule 55 (Exp -> Exp + Term .)
    read            reduce using rule 55 (Exp -> Exp + Term .)
    if              reduce using rule 55 (Exp -> Exp + Term .)
    repeat          reduce using rule 55 (Exp -> Exp + Term .)
    num             reduce using rule 55 (Exp -> Exp + Term .)
    (               reduce using rule 55 (Exp -> Exp + Term .)
    )               reduce using rule 55 (Exp -> Exp + Term .)
    sup             reduce using rule 55 (Exp -> Exp + Term .)
    inf             reduce using rule 55 (Exp -> Exp + Term .)
    supeq           reduce using rule 55 (Exp -> Exp + Term .)
    infeq           reduce using rule 55 (Exp -> Exp + Term .)
    eq              reduce using rule 55 (Exp -> Exp + Term .)
    diff            reduce using rule 55 (Exp -> Exp + Term .)
    ;               reduce using rule 55 (Exp -> Exp + Term .)
    ]               reduce using rule 55 (Exp -> Exp + Term .)
    and             reduce using rule 55 (Exp -> Exp + Term .)
    or              reduce using rule 55 (Exp -> Exp + Term .)
    *               shift and go to state 84
    /               shift and go to state 85
    %               shift and go to state 86


state 102

    (65) Term -> id . muleq Factor
    (66) Term -> id . diveq Factor
    (67) Term -> id . modeq Factor
    (68) Term -> id . muleql Factor
    (69) Term -> id . diveql Factor
    (70) Term -> id . modeql Factor
    (72) Factor -> id . plus
    (73) Factor -> id . plusl
    (74) Factor -> id . minus
    (75) Factor -> id . minusl
    (76) Factor -> id .
    (79) Factor -> id . ( )
    (81) Factor -> id . [ Exp ]
    (82) Factor -> id . [ Exp ] [ Exp ]

  ! shift/reduce conflict for ( resolved as shift
    muleq           shift and go to state 64
    diveq           shift and go to state 65
    modeq           shift and go to state 66
    muleql          shift and go to state 67
    diveql          shift and go to state 68
    modeql          shift and go to state 69
    plus            shift and go to state 70
    plusl           shift and go to state 71
    minus           shift and go to state 72
    minusl          shift and go to state 73
    *               reduce using rule 76 (Factor -> id .)
    /               reduce using rule 76 (Factor -> id .)
    %               reduce using rule 76 (Factor -> id .)
    +               reduce using rule 76 (Factor -> id .)
    -               reduce using rule 76 (Factor -> id .)
    }               reduce using rule 76 (Factor -> id .)
    id              reduce using rule 76 (Factor -> id .)
    gid             reduce using rule 76 (Factor -> id .)
    return          reduce using rule 76 (Factor -> id .)
    print           reduce using rule 76 (Factor -> id .)
    println         reduce using rule 76 (Factor -> id .)
    prints          reduce using rule 76 (Factor -> id .)
    for             reduce using rule 76 (Factor -> id .)
    while           reduce using rule 76 (Factor -> id .)
    read            reduce using rule 76 (Factor -> id .)
    if              reduce using rule 76 (Factor -> id .)
    repeat          reduce using rule 76 (Factor -> id .)
    num             reduce using rule 76 (Factor -> id .)
    )               reduce using rule 76 (Factor -> id .)
    sup             reduce using rule 76 (Factor -> id .)
    inf             reduce using rule 76 (Factor -> id .)
    supeq           reduce using rule 76 (Factor -> id .)
    infeq           reduce using rule 76 (Factor -> id .)
    eq              reduce using rule 76 (Factor -> id .)
    diff            reduce using rule 76 (Factor -> id .)
    ;               reduce using rule 76 (Factor -> id .)
    ]               reduce using rule 76 (Factor -> id .)
    and             reduce using rule 76 (Factor -> id .)
    or              reduce using rule 76 (Factor -> id .)
    (               shift and go to state 74
    [               shift and go to state 133

  ! (               [ reduce using rule 76 (Factor -> id .) ]


state 103

    (56) Exp -> Exp - Term .
    (62) Term -> Term . * Factor
    (63) Term -> Term . / Factor
    (64) Term -> Term . % Factor

    +               reduce using rule 56 (Exp -> Exp - Term .)
    -               reduce using rule 56 (Exp -> Exp - Term .)
    }               reduce using rule 56 (Exp -> Exp - Term .)
    id              reduce using rule 56 (Exp -> Exp - Term .)
    gid             reduce using rule 56 (Exp -> Exp - Term .)
    return          reduce using rule 56 (Exp -> Exp - Term .)
    print           reduce using rule 56 (Exp -> Exp - Term .)
    println         reduce using rule 56 (Exp -> Exp - Term .)
    prints          reduce using rule 56 (Exp -> Exp - Term .)
    for             reduce using rule 56 (Exp -> Exp - Term .)
    while           reduce using rule 56 (Exp -> Exp - Term .)
    read            reduce using rule 56 (Exp -> Exp - Term .)
    if              reduce using rule 56 (Exp -> Exp - Term .)
    repeat          reduce using rule 56 (Exp -> Exp - Term .)
    num             reduce using rule 56 (Exp -> Exp - Term .)
    (               reduce using rule 56 (Exp -> Exp - Term .)
    )               reduce using rule 56 (Exp -> Exp - Term .)
    sup             reduce using rule 56 (Exp -> Exp - Term .)
    inf             reduce using rule 56 (Exp -> Exp - Term .)
    supeq           reduce using rule 56 (Exp -> Exp - Term .)
    infeq           reduce using rule 56 (Exp -> Exp - Term .)
    eq              reduce using rule 56 (Exp -> Exp - Term .)
    diff            reduce using rule 56 (Exp -> Exp - Term .)
    ;               reduce using rule 56 (Exp -> Exp - Term .)
    ]               reduce using rule 56 (Exp -> Exp - Term .)
    and             reduce using rule 56 (Exp -> Exp - Term .)
    or              reduce using rule 56 (Exp -> Exp - Term .)
    *               shift and go to state 84
    /               shift and go to state 85
    %               shift and go to state 86


state 104

    (43) Attr -> id = Exp .
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    }               reduce using rule 43 (Attr -> id = Exp .)
    id              reduce using rule 43 (Attr -> id = Exp .)
    gid             reduce using rule 43 (Attr -> id = Exp .)
    return          reduce using rule 43 (Attr -> id = Exp .)
    print           reduce using rule 43 (Attr -> id = Exp .)
    println         reduce using rule 43 (Attr -> id = Exp .)
    prints          reduce using rule 43 (Attr -> id = Exp .)
    for             reduce using rule 43 (Attr -> id = Exp .)
    while           reduce using rule 43 (Attr -> id = Exp .)
    read            reduce using rule 43 (Attr -> id = Exp .)
    if              reduce using rule 43 (Attr -> id = Exp .)
    repeat          reduce using rule 43 (Attr -> id = Exp .)
    num             reduce using rule 43 (Attr -> id = Exp .)
    (               reduce using rule 43 (Attr -> id = Exp .)
    ;               reduce using rule 43 (Attr -> id = Exp .)
    )               reduce using rule 43 (Attr -> id = Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 105

    (44) Attr -> id [ Exp . ] = Exp
    (45) Attr -> id [ Exp . ] [ Exp ] = Exp
    (81) Factor -> id [ Exp . ]
    (82) Factor -> id [ Exp . ] [ Exp ]
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    ]               shift and go to state 150
    +               shift and go to state 56
    -               shift and go to state 57


state 106

    (57) Exp -> id addeq Term .
    (62) Term -> Term . * Factor
    (63) Term -> Term . / Factor
    (64) Term -> Term . % Factor

    +               reduce using rule 57 (Exp -> id addeq Term .)
    -               reduce using rule 57 (Exp -> id addeq Term .)
    }               reduce using rule 57 (Exp -> id addeq Term .)
    id              reduce using rule 57 (Exp -> id addeq Term .)
    gid             reduce using rule 57 (Exp -> id addeq Term .)
    return          reduce using rule 57 (Exp -> id addeq Term .)
    print           reduce using rule 57 (Exp -> id addeq Term .)
    println         reduce using rule 57 (Exp -> id addeq Term .)
    prints          reduce using rule 57 (Exp -> id addeq Term .)
    for             reduce using rule 57 (Exp -> id addeq Term .)
    while           reduce using rule 57 (Exp -> id addeq Term .)
    read            reduce using rule 57 (Exp -> id addeq Term .)
    if              reduce using rule 57 (Exp -> id addeq Term .)
    repeat          reduce using rule 57 (Exp -> id addeq Term .)
    num             reduce using rule 57 (Exp -> id addeq Term .)
    (               reduce using rule 57 (Exp -> id addeq Term .)
    )               reduce using rule 57 (Exp -> id addeq Term .)
    sup             reduce using rule 57 (Exp -> id addeq Term .)
    inf             reduce using rule 57 (Exp -> id addeq Term .)
    supeq           reduce using rule 57 (Exp -> id addeq Term .)
    infeq           reduce using rule 57 (Exp -> id addeq Term .)
    eq              reduce using rule 57 (Exp -> id addeq Term .)
    diff            reduce using rule 57 (Exp -> id addeq Term .)
    ;               reduce using rule 57 (Exp -> id addeq Term .)
    ]               reduce using rule 57 (Exp -> id addeq Term .)
    and             reduce using rule 57 (Exp -> id addeq Term .)
    or              reduce using rule 57 (Exp -> id addeq Term .)
    *               shift and go to state 84
    /               shift and go to state 85
    %               shift and go to state 86


state 107

    (58) Exp -> id subeq Term .
    (62) Term -> Term . * Factor
    (63) Term -> Term . / Factor
    (64) Term -> Term . % Factor

    +               reduce using rule 58 (Exp -> id subeq Term .)
    -               reduce using rule 58 (Exp -> id subeq Term .)
    }               reduce using rule 58 (Exp -> id subeq Term .)
    id              reduce using rule 58 (Exp -> id subeq Term .)
    gid             reduce using rule 58 (Exp -> id subeq Term .)
    return          reduce using rule 58 (Exp -> id subeq Term .)
    print           reduce using rule 58 (Exp -> id subeq Term .)
    println         reduce using rule 58 (Exp -> id subeq Term .)
    prints          reduce using rule 58 (Exp -> id subeq Term .)
    for             reduce using rule 58 (Exp -> id subeq Term .)
    while           reduce using rule 58 (Exp -> id subeq Term .)
    read            reduce using rule 58 (Exp -> id subeq Term .)
    if              reduce using rule 58 (Exp -> id subeq Term .)
    repeat          reduce using rule 58 (Exp -> id subeq Term .)
    num             reduce using rule 58 (Exp -> id subeq Term .)
    (               reduce using rule 58 (Exp -> id subeq Term .)
    )               reduce using rule 58 (Exp -> id subeq Term .)
    sup             reduce using rule 58 (Exp -> id subeq Term .)
    inf             reduce using rule 58 (Exp -> id subeq Term .)
    supeq           reduce using rule 58 (Exp -> id subeq Term .)
    infeq           reduce using rule 58 (Exp -> id subeq Term .)
    eq              reduce using rule 58 (Exp -> id subeq Term .)
    diff            reduce using rule 58 (Exp -> id subeq Term .)
    ;               reduce using rule 58 (Exp -> id subeq Term .)
    ]               reduce using rule 58 (Exp -> id subeq Term .)
    and             reduce using rule 58 (Exp -> id subeq Term .)
    or              reduce using rule 58 (Exp -> id subeq Term .)
    *               shift and go to state 84
    /               shift and go to state 85
    %               shift and go to state 86


state 108

    (59) Exp -> id addeql Term .
    (62) Term -> Term . * Factor
    (63) Term -> Term . / Factor
    (64) Term -> Term . % Factor

    +               reduce using rule 59 (Exp -> id addeql Term .)
    -               reduce using rule 59 (Exp -> id addeql Term .)
    }               reduce using rule 59 (Exp -> id addeql Term .)
    id              reduce using rule 59 (Exp -> id addeql Term .)
    gid             reduce using rule 59 (Exp -> id addeql Term .)
    return          reduce using rule 59 (Exp -> id addeql Term .)
    print           reduce using rule 59 (Exp -> id addeql Term .)
    println         reduce using rule 59 (Exp -> id addeql Term .)
    prints          reduce using rule 59 (Exp -> id addeql Term .)
    for             reduce using rule 59 (Exp -> id addeql Term .)
    while           reduce using rule 59 (Exp -> id addeql Term .)
    read            reduce using rule 59 (Exp -> id addeql Term .)
    if              reduce using rule 59 (Exp -> id addeql Term .)
    repeat          reduce using rule 59 (Exp -> id addeql Term .)
    num             reduce using rule 59 (Exp -> id addeql Term .)
    (               reduce using rule 59 (Exp -> id addeql Term .)
    )               reduce using rule 59 (Exp -> id addeql Term .)
    sup             reduce using rule 59 (Exp -> id addeql Term .)
    inf             reduce using rule 59 (Exp -> id addeql Term .)
    supeq           reduce using rule 59 (Exp -> id addeql Term .)
    infeq           reduce using rule 59 (Exp -> id addeql Term .)
    eq              reduce using rule 59 (Exp -> id addeql Term .)
    diff            reduce using rule 59 (Exp -> id addeql Term .)
    ;               reduce using rule 59 (Exp -> id addeql Term .)
    ]               reduce using rule 59 (Exp -> id addeql Term .)
    and             reduce using rule 59 (Exp -> id addeql Term .)
    or              reduce using rule 59 (Exp -> id addeql Term .)
    *               shift and go to state 84
    /               shift and go to state 85
    %               shift and go to state 86


state 109

    (60) Exp -> id subeql Term .
    (62) Term -> Term . * Factor
    (63) Term -> Term . / Factor
    (64) Term -> Term . % Factor

    +               reduce using rule 60 (Exp -> id subeql Term .)
    -               reduce using rule 60 (Exp -> id subeql Term .)
    }               reduce using rule 60 (Exp -> id subeql Term .)
    id              reduce using rule 60 (Exp -> id subeql Term .)
    gid             reduce using rule 60 (Exp -> id subeql Term .)
    return          reduce using rule 60 (Exp -> id subeql Term .)
    print           reduce using rule 60 (Exp -> id subeql Term .)
    println         reduce using rule 60 (Exp -> id subeql Term .)
    prints          reduce using rule 60 (Exp -> id subeql Term .)
    for             reduce using rule 60 (Exp -> id subeql Term .)
    while           reduce using rule 60 (Exp -> id subeql Term .)
    read            reduce using rule 60 (Exp -> id subeql Term .)
    if              reduce using rule 60 (Exp -> id subeql Term .)
    repeat          reduce using rule 60 (Exp -> id subeql Term .)
    num             reduce using rule 60 (Exp -> id subeql Term .)
    (               reduce using rule 60 (Exp -> id subeql Term .)
    )               reduce using rule 60 (Exp -> id subeql Term .)
    sup             reduce using rule 60 (Exp -> id subeql Term .)
    inf             reduce using rule 60 (Exp -> id subeql Term .)
    supeq           reduce using rule 60 (Exp -> id subeql Term .)
    infeq           reduce using rule 60 (Exp -> id subeql Term .)
    eq              reduce using rule 60 (Exp -> id subeql Term .)
    diff            reduce using rule 60 (Exp -> id subeql Term .)
    ;               reduce using rule 60 (Exp -> id subeql Term .)
    ]               reduce using rule 60 (Exp -> id subeql Term .)
    and             reduce using rule 60 (Exp -> id subeql Term .)
    or              reduce using rule 60 (Exp -> id subeql Term .)
    *               shift and go to state 84
    /               shift and go to state 85
    %               shift and go to state 86


state 110

    (72) Factor -> id . plus
    (73) Factor -> id . plusl
    (74) Factor -> id . minus
    (75) Factor -> id . minusl
    (76) Factor -> id .
    (79) Factor -> id . ( )
    (81) Factor -> id . [ Exp ]
    (82) Factor -> id . [ Exp ] [ Exp ]

  ! shift/reduce conflict for ( resolved as shift
    plus            shift and go to state 70
    plusl           shift and go to state 71
    minus           shift and go to state 72
    minusl          shift and go to state 73
    *               reduce using rule 76 (Factor -> id .)
    /               reduce using rule 76 (Factor -> id .)
    %               reduce using rule 76 (Factor -> id .)
    +               reduce using rule 76 (Factor -> id .)
    -               reduce using rule 76 (Factor -> id .)
    }               reduce using rule 76 (Factor -> id .)
    id              reduce using rule 76 (Factor -> id .)
    gid             reduce using rule 76 (Factor -> id .)
    return          reduce using rule 76 (Factor -> id .)
    print           reduce using rule 76 (Factor -> id .)
    println         reduce using rule 76 (Factor -> id .)
    prints          reduce using rule 76 (Factor -> id .)
    for             reduce using rule 76 (Factor -> id .)
    while           reduce using rule 76 (Factor -> id .)
    read            reduce using rule 76 (Factor -> id .)
    if              reduce using rule 76 (Factor -> id .)
    repeat          reduce using rule 76 (Factor -> id .)
    num             reduce using rule 76 (Factor -> id .)
    )               reduce using rule 76 (Factor -> id .)
    sup             reduce using rule 76 (Factor -> id .)
    inf             reduce using rule 76 (Factor -> id .)
    supeq           reduce using rule 76 (Factor -> id .)
    infeq           reduce using rule 76 (Factor -> id .)
    eq              reduce using rule 76 (Factor -> id .)
    diff            reduce using rule 76 (Factor -> id .)
    ;               reduce using rule 76 (Factor -> id .)
    ]               reduce using rule 76 (Factor -> id .)
    and             reduce using rule 76 (Factor -> id .)
    or              reduce using rule 76 (Factor -> id .)
    (               shift and go to state 74
    [               shift and go to state 133

  ! (               [ reduce using rule 76 (Factor -> id .) ]


state 111

    (65) Term -> id muleq Factor .

    *               reduce using rule 65 (Term -> id muleq Factor .)
    /               reduce using rule 65 (Term -> id muleq Factor .)
    %               reduce using rule 65 (Term -> id muleq Factor .)
    +               reduce using rule 65 (Term -> id muleq Factor .)
    -               reduce using rule 65 (Term -> id muleq Factor .)
    }               reduce using rule 65 (Term -> id muleq Factor .)
    id              reduce using rule 65 (Term -> id muleq Factor .)
    gid             reduce using rule 65 (Term -> id muleq Factor .)
    return          reduce using rule 65 (Term -> id muleq Factor .)
    print           reduce using rule 65 (Term -> id muleq Factor .)
    println         reduce using rule 65 (Term -> id muleq Factor .)
    prints          reduce using rule 65 (Term -> id muleq Factor .)
    for             reduce using rule 65 (Term -> id muleq Factor .)
    while           reduce using rule 65 (Term -> id muleq Factor .)
    read            reduce using rule 65 (Term -> id muleq Factor .)
    if              reduce using rule 65 (Term -> id muleq Factor .)
    repeat          reduce using rule 65 (Term -> id muleq Factor .)
    num             reduce using rule 65 (Term -> id muleq Factor .)
    (               reduce using rule 65 (Term -> id muleq Factor .)
    )               reduce using rule 65 (Term -> id muleq Factor .)
    sup             reduce using rule 65 (Term -> id muleq Factor .)
    inf             reduce using rule 65 (Term -> id muleq Factor .)
    supeq           reduce using rule 65 (Term -> id muleq Factor .)
    infeq           reduce using rule 65 (Term -> id muleq Factor .)
    eq              reduce using rule 65 (Term -> id muleq Factor .)
    diff            reduce using rule 65 (Term -> id muleq Factor .)
    ;               reduce using rule 65 (Term -> id muleq Factor .)
    ]               reduce using rule 65 (Term -> id muleq Factor .)
    and             reduce using rule 65 (Term -> id muleq Factor .)
    or              reduce using rule 65 (Term -> id muleq Factor .)


state 112

    (66) Term -> id diveq Factor .

    *               reduce using rule 66 (Term -> id diveq Factor .)
    /               reduce using rule 66 (Term -> id diveq Factor .)
    %               reduce using rule 66 (Term -> id diveq Factor .)
    +               reduce using rule 66 (Term -> id diveq Factor .)
    -               reduce using rule 66 (Term -> id diveq Factor .)
    }               reduce using rule 66 (Term -> id diveq Factor .)
    id              reduce using rule 66 (Term -> id diveq Factor .)
    gid             reduce using rule 66 (Term -> id diveq Factor .)
    return          reduce using rule 66 (Term -> id diveq Factor .)
    print           reduce using rule 66 (Term -> id diveq Factor .)
    println         reduce using rule 66 (Term -> id diveq Factor .)
    prints          reduce using rule 66 (Term -> id diveq Factor .)
    for             reduce using rule 66 (Term -> id diveq Factor .)
    while           reduce using rule 66 (Term -> id diveq Factor .)
    read            reduce using rule 66 (Term -> id diveq Factor .)
    if              reduce using rule 66 (Term -> id diveq Factor .)
    repeat          reduce using rule 66 (Term -> id diveq Factor .)
    num             reduce using rule 66 (Term -> id diveq Factor .)
    (               reduce using rule 66 (Term -> id diveq Factor .)
    )               reduce using rule 66 (Term -> id diveq Factor .)
    sup             reduce using rule 66 (Term -> id diveq Factor .)
    inf             reduce using rule 66 (Term -> id diveq Factor .)
    supeq           reduce using rule 66 (Term -> id diveq Factor .)
    infeq           reduce using rule 66 (Term -> id diveq Factor .)
    eq              reduce using rule 66 (Term -> id diveq Factor .)
    diff            reduce using rule 66 (Term -> id diveq Factor .)
    ;               reduce using rule 66 (Term -> id diveq Factor .)
    ]               reduce using rule 66 (Term -> id diveq Factor .)
    and             reduce using rule 66 (Term -> id diveq Factor .)
    or              reduce using rule 66 (Term -> id diveq Factor .)


state 113

    (67) Term -> id modeq Factor .

    *               reduce using rule 67 (Term -> id modeq Factor .)
    /               reduce using rule 67 (Term -> id modeq Factor .)
    %               reduce using rule 67 (Term -> id modeq Factor .)
    +               reduce using rule 67 (Term -> id modeq Factor .)
    -               reduce using rule 67 (Term -> id modeq Factor .)
    }               reduce using rule 67 (Term -> id modeq Factor .)
    id              reduce using rule 67 (Term -> id modeq Factor .)
    gid             reduce using rule 67 (Term -> id modeq Factor .)
    return          reduce using rule 67 (Term -> id modeq Factor .)
    print           reduce using rule 67 (Term -> id modeq Factor .)
    println         reduce using rule 67 (Term -> id modeq Factor .)
    prints          reduce using rule 67 (Term -> id modeq Factor .)
    for             reduce using rule 67 (Term -> id modeq Factor .)
    while           reduce using rule 67 (Term -> id modeq Factor .)
    read            reduce using rule 67 (Term -> id modeq Factor .)
    if              reduce using rule 67 (Term -> id modeq Factor .)
    repeat          reduce using rule 67 (Term -> id modeq Factor .)
    num             reduce using rule 67 (Term -> id modeq Factor .)
    (               reduce using rule 67 (Term -> id modeq Factor .)
    )               reduce using rule 67 (Term -> id modeq Factor .)
    sup             reduce using rule 67 (Term -> id modeq Factor .)
    inf             reduce using rule 67 (Term -> id modeq Factor .)
    supeq           reduce using rule 67 (Term -> id modeq Factor .)
    infeq           reduce using rule 67 (Term -> id modeq Factor .)
    eq              reduce using rule 67 (Term -> id modeq Factor .)
    diff            reduce using rule 67 (Term -> id modeq Factor .)
    ;               reduce using rule 67 (Term -> id modeq Factor .)
    ]               reduce using rule 67 (Term -> id modeq Factor .)
    and             reduce using rule 67 (Term -> id modeq Factor .)
    or              reduce using rule 67 (Term -> id modeq Factor .)


state 114

    (68) Term -> id muleql Factor .

    *               reduce using rule 68 (Term -> id muleql Factor .)
    /               reduce using rule 68 (Term -> id muleql Factor .)
    %               reduce using rule 68 (Term -> id muleql Factor .)
    +               reduce using rule 68 (Term -> id muleql Factor .)
    -               reduce using rule 68 (Term -> id muleql Factor .)
    }               reduce using rule 68 (Term -> id muleql Factor .)
    id              reduce using rule 68 (Term -> id muleql Factor .)
    gid             reduce using rule 68 (Term -> id muleql Factor .)
    return          reduce using rule 68 (Term -> id muleql Factor .)
    print           reduce using rule 68 (Term -> id muleql Factor .)
    println         reduce using rule 68 (Term -> id muleql Factor .)
    prints          reduce using rule 68 (Term -> id muleql Factor .)
    for             reduce using rule 68 (Term -> id muleql Factor .)
    while           reduce using rule 68 (Term -> id muleql Factor .)
    read            reduce using rule 68 (Term -> id muleql Factor .)
    if              reduce using rule 68 (Term -> id muleql Factor .)
    repeat          reduce using rule 68 (Term -> id muleql Factor .)
    num             reduce using rule 68 (Term -> id muleql Factor .)
    (               reduce using rule 68 (Term -> id muleql Factor .)
    )               reduce using rule 68 (Term -> id muleql Factor .)
    sup             reduce using rule 68 (Term -> id muleql Factor .)
    inf             reduce using rule 68 (Term -> id muleql Factor .)
    supeq           reduce using rule 68 (Term -> id muleql Factor .)
    infeq           reduce using rule 68 (Term -> id muleql Factor .)
    eq              reduce using rule 68 (Term -> id muleql Factor .)
    diff            reduce using rule 68 (Term -> id muleql Factor .)
    ;               reduce using rule 68 (Term -> id muleql Factor .)
    ]               reduce using rule 68 (Term -> id muleql Factor .)
    and             reduce using rule 68 (Term -> id muleql Factor .)
    or              reduce using rule 68 (Term -> id muleql Factor .)


state 115

    (69) Term -> id diveql Factor .

    *               reduce using rule 69 (Term -> id diveql Factor .)
    /               reduce using rule 69 (Term -> id diveql Factor .)
    %               reduce using rule 69 (Term -> id diveql Factor .)
    +               reduce using rule 69 (Term -> id diveql Factor .)
    -               reduce using rule 69 (Term -> id diveql Factor .)
    }               reduce using rule 69 (Term -> id diveql Factor .)
    id              reduce using rule 69 (Term -> id diveql Factor .)
    gid             reduce using rule 69 (Term -> id diveql Factor .)
    return          reduce using rule 69 (Term -> id diveql Factor .)
    print           reduce using rule 69 (Term -> id diveql Factor .)
    println         reduce using rule 69 (Term -> id diveql Factor .)
    prints          reduce using rule 69 (Term -> id diveql Factor .)
    for             reduce using rule 69 (Term -> id diveql Factor .)
    while           reduce using rule 69 (Term -> id diveql Factor .)
    read            reduce using rule 69 (Term -> id diveql Factor .)
    if              reduce using rule 69 (Term -> id diveql Factor .)
    repeat          reduce using rule 69 (Term -> id diveql Factor .)
    num             reduce using rule 69 (Term -> id diveql Factor .)
    (               reduce using rule 69 (Term -> id diveql Factor .)
    )               reduce using rule 69 (Term -> id diveql Factor .)
    sup             reduce using rule 69 (Term -> id diveql Factor .)
    inf             reduce using rule 69 (Term -> id diveql Factor .)
    supeq           reduce using rule 69 (Term -> id diveql Factor .)
    infeq           reduce using rule 69 (Term -> id diveql Factor .)
    eq              reduce using rule 69 (Term -> id diveql Factor .)
    diff            reduce using rule 69 (Term -> id diveql Factor .)
    ;               reduce using rule 69 (Term -> id diveql Factor .)
    ]               reduce using rule 69 (Term -> id diveql Factor .)
    and             reduce using rule 69 (Term -> id diveql Factor .)
    or              reduce using rule 69 (Term -> id diveql Factor .)


state 116

    (70) Term -> id modeql Factor .

    *               reduce using rule 70 (Term -> id modeql Factor .)
    /               reduce using rule 70 (Term -> id modeql Factor .)
    %               reduce using rule 70 (Term -> id modeql Factor .)
    +               reduce using rule 70 (Term -> id modeql Factor .)
    -               reduce using rule 70 (Term -> id modeql Factor .)
    }               reduce using rule 70 (Term -> id modeql Factor .)
    id              reduce using rule 70 (Term -> id modeql Factor .)
    gid             reduce using rule 70 (Term -> id modeql Factor .)
    return          reduce using rule 70 (Term -> id modeql Factor .)
    print           reduce using rule 70 (Term -> id modeql Factor .)
    println         reduce using rule 70 (Term -> id modeql Factor .)
    prints          reduce using rule 70 (Term -> id modeql Factor .)
    for             reduce using rule 70 (Term -> id modeql Factor .)
    while           reduce using rule 70 (Term -> id modeql Factor .)
    read            reduce using rule 70 (Term -> id modeql Factor .)
    if              reduce using rule 70 (Term -> id modeql Factor .)
    repeat          reduce using rule 70 (Term -> id modeql Factor .)
    num             reduce using rule 70 (Term -> id modeql Factor .)
    (               reduce using rule 70 (Term -> id modeql Factor .)
    )               reduce using rule 70 (Term -> id modeql Factor .)
    sup             reduce using rule 70 (Term -> id modeql Factor .)
    inf             reduce using rule 70 (Term -> id modeql Factor .)
    supeq           reduce using rule 70 (Term -> id modeql Factor .)
    infeq           reduce using rule 70 (Term -> id modeql Factor .)
    eq              reduce using rule 70 (Term -> id modeql Factor .)
    diff            reduce using rule 70 (Term -> id modeql Factor .)
    ;               reduce using rule 70 (Term -> id modeql Factor .)
    ]               reduce using rule 70 (Term -> id modeql Factor .)
    and             reduce using rule 70 (Term -> id modeql Factor .)
    or              reduce using rule 70 (Term -> id modeql Factor .)


state 117

    (79) Factor -> id ( ) .

    *               reduce using rule 79 (Factor -> id ( ) .)
    /               reduce using rule 79 (Factor -> id ( ) .)
    %               reduce using rule 79 (Factor -> id ( ) .)
    +               reduce using rule 79 (Factor -> id ( ) .)
    -               reduce using rule 79 (Factor -> id ( ) .)
    }               reduce using rule 79 (Factor -> id ( ) .)
    id              reduce using rule 79 (Factor -> id ( ) .)
    gid             reduce using rule 79 (Factor -> id ( ) .)
    return          reduce using rule 79 (Factor -> id ( ) .)
    print           reduce using rule 79 (Factor -> id ( ) .)
    println         reduce using rule 79 (Factor -> id ( ) .)
    prints          reduce using rule 79 (Factor -> id ( ) .)
    for             reduce using rule 79 (Factor -> id ( ) .)
    while           reduce using rule 79 (Factor -> id ( ) .)
    read            reduce using rule 79 (Factor -> id ( ) .)
    if              reduce using rule 79 (Factor -> id ( ) .)
    repeat          reduce using rule 79 (Factor -> id ( ) .)
    num             reduce using rule 79 (Factor -> id ( ) .)
    (               reduce using rule 79 (Factor -> id ( ) .)
    )               reduce using rule 79 (Factor -> id ( ) .)
    sup             reduce using rule 79 (Factor -> id ( ) .)
    inf             reduce using rule 79 (Factor -> id ( ) .)
    supeq           reduce using rule 79 (Factor -> id ( ) .)
    infeq           reduce using rule 79 (Factor -> id ( ) .)
    eq              reduce using rule 79 (Factor -> id ( ) .)
    diff            reduce using rule 79 (Factor -> id ( ) .)
    ;               reduce using rule 79 (Factor -> id ( ) .)
    ]               reduce using rule 79 (Factor -> id ( ) .)
    and             reduce using rule 79 (Factor -> id ( ) .)
    or              reduce using rule 79 (Factor -> id ( ) .)


state 118

    (46) Attr -> gid = Exp .
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    }               reduce using rule 46 (Attr -> gid = Exp .)
    id              reduce using rule 46 (Attr -> gid = Exp .)
    gid             reduce using rule 46 (Attr -> gid = Exp .)
    return          reduce using rule 46 (Attr -> gid = Exp .)
    print           reduce using rule 46 (Attr -> gid = Exp .)
    println         reduce using rule 46 (Attr -> gid = Exp .)
    prints          reduce using rule 46 (Attr -> gid = Exp .)
    for             reduce using rule 46 (Attr -> gid = Exp .)
    while           reduce using rule 46 (Attr -> gid = Exp .)
    read            reduce using rule 46 (Attr -> gid = Exp .)
    if              reduce using rule 46 (Attr -> gid = Exp .)
    repeat          reduce using rule 46 (Attr -> gid = Exp .)
    num             reduce using rule 46 (Attr -> gid = Exp .)
    (               reduce using rule 46 (Attr -> gid = Exp .)
    ;               reduce using rule 46 (Attr -> gid = Exp .)
    )               reduce using rule 46 (Attr -> gid = Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 119

    (47) Attr -> gid [ Exp . ] = Exp
    (48) Attr -> gid [ Exp . ] [ Exp ] = Exp
    (83) Factor -> gid [ Exp . ]
    (84) Factor -> gid [ Exp . ] [ Exp ]
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    ]               shift and go to state 151
    +               shift and go to state 56
    -               shift and go to state 57


state 120

    (49) Return -> return ( Exp . )
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    )               shift and go to state 152
    +               shift and go to state 56
    -               shift and go to state 57


state 121

    (91) Cond -> ( Cond . and Cond )
    (92) Cond -> ( Cond . or Cond )
    (80) Factor -> ( Cond . )
    (89) Cond -> Cond . and Cond
    (90) Cond -> Cond . or Cond

    and             shift and go to state 153
    or              shift and go to state 154
    )               shift and go to state 122


state 122

    (80) Factor -> ( Cond ) .

    *               reduce using rule 80 (Factor -> ( Cond ) .)
    /               reduce using rule 80 (Factor -> ( Cond ) .)
    %               reduce using rule 80 (Factor -> ( Cond ) .)
    +               reduce using rule 80 (Factor -> ( Cond ) .)
    -               reduce using rule 80 (Factor -> ( Cond ) .)
    }               reduce using rule 80 (Factor -> ( Cond ) .)
    id              reduce using rule 80 (Factor -> ( Cond ) .)
    gid             reduce using rule 80 (Factor -> ( Cond ) .)
    return          reduce using rule 80 (Factor -> ( Cond ) .)
    print           reduce using rule 80 (Factor -> ( Cond ) .)
    println         reduce using rule 80 (Factor -> ( Cond ) .)
    prints          reduce using rule 80 (Factor -> ( Cond ) .)
    for             reduce using rule 80 (Factor -> ( Cond ) .)
    while           reduce using rule 80 (Factor -> ( Cond ) .)
    read            reduce using rule 80 (Factor -> ( Cond ) .)
    if              reduce using rule 80 (Factor -> ( Cond ) .)
    repeat          reduce using rule 80 (Factor -> ( Cond ) .)
    num             reduce using rule 80 (Factor -> ( Cond ) .)
    (               reduce using rule 80 (Factor -> ( Cond ) .)
    )               reduce using rule 80 (Factor -> ( Cond ) .)
    sup             reduce using rule 80 (Factor -> ( Cond ) .)
    inf             reduce using rule 80 (Factor -> ( Cond ) .)
    supeq           reduce using rule 80 (Factor -> ( Cond ) .)
    infeq           reduce using rule 80 (Factor -> ( Cond ) .)
    eq              reduce using rule 80 (Factor -> ( Cond ) .)
    diff            reduce using rule 80 (Factor -> ( Cond ) .)
    ;               reduce using rule 80 (Factor -> ( Cond ) .)
    ]               reduce using rule 80 (Factor -> ( Cond ) .)
    and             reduce using rule 80 (Factor -> ( Cond ) .)
    or              reduce using rule 80 (Factor -> ( Cond ) .)


state 123

    (89) Cond -> Cond and . Cond
    (89) Cond -> . Cond and Cond
    (90) Cond -> . Cond or Cond
    (91) Cond -> . ( Cond and Cond )
    (92) Cond -> . ( Cond or Cond )
    (93) Cond -> . Exp sup Exp
    (94) Cond -> . Exp inf Exp
    (95) Cond -> . Exp supeq Exp
    (96) Cond -> . Exp infeq Exp
    (97) Cond -> . not Exp
    (98) Cond -> . Exp eq Exp
    (99) Cond -> . Exp diff Exp
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    (               shift and go to state 78
    not             shift and go to state 81
    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45

    Cond                           shift and go to state 155
    Exp                            shift and go to state 144
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 124

    (90) Cond -> Cond or . Cond
    (89) Cond -> . Cond and Cond
    (90) Cond -> . Cond or Cond
    (91) Cond -> . ( Cond and Cond )
    (92) Cond -> . ( Cond or Cond )
    (93) Cond -> . Exp sup Exp
    (94) Cond -> . Exp inf Exp
    (95) Cond -> . Exp supeq Exp
    (96) Cond -> . Exp infeq Exp
    (97) Cond -> . not Exp
    (98) Cond -> . Exp eq Exp
    (99) Cond -> . Exp diff Exp
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    (               shift and go to state 78
    not             shift and go to state 81
    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45

    Cond                           shift and go to state 156
    Exp                            shift and go to state 144
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 125

    (85) Factor -> ( Exp ) .

    *               reduce using rule 85 (Factor -> ( Exp ) .)
    /               reduce using rule 85 (Factor -> ( Exp ) .)
    %               reduce using rule 85 (Factor -> ( Exp ) .)
    +               reduce using rule 85 (Factor -> ( Exp ) .)
    -               reduce using rule 85 (Factor -> ( Exp ) .)
    }               reduce using rule 85 (Factor -> ( Exp ) .)
    id              reduce using rule 85 (Factor -> ( Exp ) .)
    gid             reduce using rule 85 (Factor -> ( Exp ) .)
    return          reduce using rule 85 (Factor -> ( Exp ) .)
    print           reduce using rule 85 (Factor -> ( Exp ) .)
    println         reduce using rule 85 (Factor -> ( Exp ) .)
    prints          reduce using rule 85 (Factor -> ( Exp ) .)
    for             reduce using rule 85 (Factor -> ( Exp ) .)
    while           reduce using rule 85 (Factor -> ( Exp ) .)
    read            reduce using rule 85 (Factor -> ( Exp ) .)
    if              reduce using rule 85 (Factor -> ( Exp ) .)
    repeat          reduce using rule 85 (Factor -> ( Exp ) .)
    num             reduce using rule 85 (Factor -> ( Exp ) .)
    (               reduce using rule 85 (Factor -> ( Exp ) .)
    )               reduce using rule 85 (Factor -> ( Exp ) .)
    sup             reduce using rule 85 (Factor -> ( Exp ) .)
    inf             reduce using rule 85 (Factor -> ( Exp ) .)
    supeq           reduce using rule 85 (Factor -> ( Exp ) .)
    infeq           reduce using rule 85 (Factor -> ( Exp ) .)
    eq              reduce using rule 85 (Factor -> ( Exp ) .)
    diff            reduce using rule 85 (Factor -> ( Exp ) .)
    ;               reduce using rule 85 (Factor -> ( Exp ) .)
    ]               reduce using rule 85 (Factor -> ( Exp ) .)
    and             reduce using rule 85 (Factor -> ( Exp ) .)
    or              reduce using rule 85 (Factor -> ( Exp ) .)


state 126

    (93) Cond -> Exp sup . Exp
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 157
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 127

    (94) Cond -> Exp inf . Exp
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 158
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 128

    (95) Cond -> Exp supeq . Exp
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 159
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 129

    (96) Cond -> Exp infeq . Exp
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 160
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 130

    (98) Cond -> Exp eq . Exp
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 161
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 131

    (99) Cond -> Exp diff . Exp
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 162
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 132

    (97) Cond -> not Exp .
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    )               reduce using rule 97 (Cond -> not Exp .)
    and             reduce using rule 97 (Cond -> not Exp .)
    or              reduce using rule 97 (Cond -> not Exp .)
    ;               reduce using rule 97 (Cond -> not Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 133

    (81) Factor -> id [ . Exp ]
    (82) Factor -> id [ . Exp ] [ Exp ]
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 163
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 134

    (83) Factor -> gid [ . Exp ]
    (84) Factor -> gid [ . Exp ] [ Exp ]
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 164
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 135

    (62) Term -> Term * Factor .

    *               reduce using rule 62 (Term -> Term * Factor .)
    /               reduce using rule 62 (Term -> Term * Factor .)
    %               reduce using rule 62 (Term -> Term * Factor .)
    +               reduce using rule 62 (Term -> Term * Factor .)
    -               reduce using rule 62 (Term -> Term * Factor .)
    }               reduce using rule 62 (Term -> Term * Factor .)
    id              reduce using rule 62 (Term -> Term * Factor .)
    gid             reduce using rule 62 (Term -> Term * Factor .)
    return          reduce using rule 62 (Term -> Term * Factor .)
    print           reduce using rule 62 (Term -> Term * Factor .)
    println         reduce using rule 62 (Term -> Term * Factor .)
    prints          reduce using rule 62 (Term -> Term * Factor .)
    for             reduce using rule 62 (Term -> Term * Factor .)
    while           reduce using rule 62 (Term -> Term * Factor .)
    read            reduce using rule 62 (Term -> Term * Factor .)
    if              reduce using rule 62 (Term -> Term * Factor .)
    repeat          reduce using rule 62 (Term -> Term * Factor .)
    num             reduce using rule 62 (Term -> Term * Factor .)
    (               reduce using rule 62 (Term -> Term * Factor .)
    )               reduce using rule 62 (Term -> Term * Factor .)
    sup             reduce using rule 62 (Term -> Term * Factor .)
    inf             reduce using rule 62 (Term -> Term * Factor .)
    supeq           reduce using rule 62 (Term -> Term * Factor .)
    infeq           reduce using rule 62 (Term -> Term * Factor .)
    eq              reduce using rule 62 (Term -> Term * Factor .)
    diff            reduce using rule 62 (Term -> Term * Factor .)
    ;               reduce using rule 62 (Term -> Term * Factor .)
    ]               reduce using rule 62 (Term -> Term * Factor .)
    and             reduce using rule 62 (Term -> Term * Factor .)
    or              reduce using rule 62 (Term -> Term * Factor .)


state 136

    (63) Term -> Term / Factor .

    *               reduce using rule 63 (Term -> Term / Factor .)
    /               reduce using rule 63 (Term -> Term / Factor .)
    %               reduce using rule 63 (Term -> Term / Factor .)
    +               reduce using rule 63 (Term -> Term / Factor .)
    -               reduce using rule 63 (Term -> Term / Factor .)
    }               reduce using rule 63 (Term -> Term / Factor .)
    id              reduce using rule 63 (Term -> Term / Factor .)
    gid             reduce using rule 63 (Term -> Term / Factor .)
    return          reduce using rule 63 (Term -> Term / Factor .)
    print           reduce using rule 63 (Term -> Term / Factor .)
    println         reduce using rule 63 (Term -> Term / Factor .)
    prints          reduce using rule 63 (Term -> Term / Factor .)
    for             reduce using rule 63 (Term -> Term / Factor .)
    while           reduce using rule 63 (Term -> Term / Factor .)
    read            reduce using rule 63 (Term -> Term / Factor .)
    if              reduce using rule 63 (Term -> Term / Factor .)
    repeat          reduce using rule 63 (Term -> Term / Factor .)
    num             reduce using rule 63 (Term -> Term / Factor .)
    (               reduce using rule 63 (Term -> Term / Factor .)
    )               reduce using rule 63 (Term -> Term / Factor .)
    sup             reduce using rule 63 (Term -> Term / Factor .)
    inf             reduce using rule 63 (Term -> Term / Factor .)
    supeq           reduce using rule 63 (Term -> Term / Factor .)
    infeq           reduce using rule 63 (Term -> Term / Factor .)
    eq              reduce using rule 63 (Term -> Term / Factor .)
    diff            reduce using rule 63 (Term -> Term / Factor .)
    ;               reduce using rule 63 (Term -> Term / Factor .)
    ]               reduce using rule 63 (Term -> Term / Factor .)
    and             reduce using rule 63 (Term -> Term / Factor .)
    or              reduce using rule 63 (Term -> Term / Factor .)


state 137

    (64) Term -> Term % Factor .

    *               reduce using rule 64 (Term -> Term % Factor .)
    /               reduce using rule 64 (Term -> Term % Factor .)
    %               reduce using rule 64 (Term -> Term % Factor .)
    +               reduce using rule 64 (Term -> Term % Factor .)
    -               reduce using rule 64 (Term -> Term % Factor .)
    }               reduce using rule 64 (Term -> Term % Factor .)
    id              reduce using rule 64 (Term -> Term % Factor .)
    gid             reduce using rule 64 (Term -> Term % Factor .)
    return          reduce using rule 64 (Term -> Term % Factor .)
    print           reduce using rule 64 (Term -> Term % Factor .)
    println         reduce using rule 64 (Term -> Term % Factor .)
    prints          reduce using rule 64 (Term -> Term % Factor .)
    for             reduce using rule 64 (Term -> Term % Factor .)
    while           reduce using rule 64 (Term -> Term % Factor .)
    read            reduce using rule 64 (Term -> Term % Factor .)
    if              reduce using rule 64 (Term -> Term % Factor .)
    repeat          reduce using rule 64 (Term -> Term % Factor .)
    num             reduce using rule 64 (Term -> Term % Factor .)
    (               reduce using rule 64 (Term -> Term % Factor .)
    )               reduce using rule 64 (Term -> Term % Factor .)
    sup             reduce using rule 64 (Term -> Term % Factor .)
    inf             reduce using rule 64 (Term -> Term % Factor .)
    supeq           reduce using rule 64 (Term -> Term % Factor .)
    infeq           reduce using rule 64 (Term -> Term % Factor .)
    eq              reduce using rule 64 (Term -> Term % Factor .)
    diff            reduce using rule 64 (Term -> Term % Factor .)
    ;               reduce using rule 64 (Term -> Term % Factor .)
    ]               reduce using rule 64 (Term -> Term % Factor .)
    and             reduce using rule 64 (Term -> Term % Factor .)
    or              reduce using rule 64 (Term -> Term % Factor .)


state 138

    (31) Print -> print ( Exp . )
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    )               shift and go to state 165
    +               shift and go to state 56
    -               shift and go to state 57


state 139

    (32) Println -> println ( Exp . )
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    )               shift and go to state 166
    +               shift and go to state 56
    -               shift and go to state 57


state 140

    (33) Prints -> prints ( string . )

    )               shift and go to state 167


state 141

    (26) Repeat -> RepeatS ( num . ) { Insts }

    )               shift and go to state 168


state 142

    (28) For -> for ( Insts . ; Cond ; Insts ) { Insts }
    (13) Insts -> Insts . Inst
    (15) Inst -> . Attr
    (16) Inst -> . Return
    (17) Inst -> . Exp
    (18) Inst -> . Print
    (19) Inst -> . Println
    (20) Inst -> . Prints
    (21) Inst -> . Repeat
    (22) Inst -> . For
    (23) Inst -> . While
    (24) Inst -> . Read
    (25) Inst -> . If
    (43) Attr -> . id = Exp
    (44) Attr -> . id [ Exp ] = Exp
    (45) Attr -> . id [ Exp ] [ Exp ] = Exp
    (46) Attr -> . gid = Exp
    (47) Attr -> . gid [ Exp ] = Exp
    (48) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (49) Return -> . return ( Exp )
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (31) Print -> . print ( Exp )
    (32) Println -> . println ( Exp )
    (33) Prints -> . prints ( string )
    (26) Repeat -> . RepeatS ( num ) { Insts }
    (28) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (29) While -> . while ( Cond ) { Insts }
    (30) Read -> . read ( id )
    (50) If -> . if ( Cond ) { Insts }
    (51) If -> . if ( Cond ) Inst
    (53) If -> . if ( Cond ) { Insts } else { Insts }
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (27) RepeatS -> . repeat
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    ;               shift and go to state 169
    id              shift and go to state 36
    gid             shift and go to state 37
    return          shift and go to state 38
    print           shift and go to state 41
    println         shift and go to state 42
    prints          shift and go to state 43
    for             shift and go to state 46
    while           shift and go to state 47
    read            shift and go to state 48
    if              shift and go to state 49
    repeat          shift and go to state 51
    num             shift and go to state 45
    (               shift and go to state 39

    Inst                           shift and go to state 24
    Attr                           shift and go to state 25
    Return                         shift and go to state 26
    Exp                            shift and go to state 27
    Print                          shift and go to state 28
    Println                        shift and go to state 29
    Prints                         shift and go to state 30
    Repeat                         shift and go to state 31
    For                            shift and go to state 32
    While                          shift and go to state 33
    Read                           shift and go to state 34
    If                             shift and go to state 35
    Term                           shift and go to state 40
    RepeatS                        shift and go to state 44
    Factor                         shift and go to state 50

state 143

    (29) While -> while ( Cond . ) { Insts }
    (89) Cond -> Cond . and Cond
    (90) Cond -> Cond . or Cond

    )               shift and go to state 170
    and             shift and go to state 123
    or              shift and go to state 124


state 144

    (93) Cond -> Exp . sup Exp
    (94) Cond -> Exp . inf Exp
    (95) Cond -> Exp . supeq Exp
    (96) Cond -> Exp . infeq Exp
    (98) Cond -> Exp . eq Exp
    (99) Cond -> Exp . diff Exp
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    sup             shift and go to state 126
    inf             shift and go to state 127
    supeq           shift and go to state 128
    infeq           shift and go to state 129
    eq              shift and go to state 130
    diff            shift and go to state 131
    +               shift and go to state 56
    -               shift and go to state 57


state 145

    (30) Read -> read ( id . )

    )               shift and go to state 171


state 146

    (50) If -> if ( Cond . ) { Insts }
    (51) If -> if ( Cond . ) Inst
    (53) If -> if ( Cond . ) { Insts } else { Insts }
    (89) Cond -> Cond . and Cond
    (90) Cond -> Cond . or Cond

    )               shift and go to state 172
    and             shift and go to state 123
    or              shift and go to state 124


state 147

    (35) Dcl -> id [ . num ]
    (36) Dcl -> id [ . num ] [ num ]

    num             shift and go to state 173


state 148

    (38) Dcl -> id = . num

    num             shift and go to state 174


state 149

    (39) DclGlobal -> int id [ num ] .
    (40) DclGlobal -> int id [ num ] . [ num ]

    }               reduce using rule 39 (DclGlobal -> int id [ num ] .)
    int             reduce using rule 39 (DclGlobal -> int id [ num ] .)
    [               shift and go to state 175


state 150

    (44) Attr -> id [ Exp ] . = Exp
    (45) Attr -> id [ Exp ] . [ Exp ] = Exp
    (81) Factor -> id [ Exp ] .
    (82) Factor -> id [ Exp ] . [ Exp ]

    =               shift and go to state 177
    [               shift and go to state 176
    *               reduce using rule 81 (Factor -> id [ Exp ] .)
    /               reduce using rule 81 (Factor -> id [ Exp ] .)
    %               reduce using rule 81 (Factor -> id [ Exp ] .)
    +               reduce using rule 81 (Factor -> id [ Exp ] .)
    -               reduce using rule 81 (Factor -> id [ Exp ] .)
    }               reduce using rule 81 (Factor -> id [ Exp ] .)
    id              reduce using rule 81 (Factor -> id [ Exp ] .)
    gid             reduce using rule 81 (Factor -> id [ Exp ] .)
    return          reduce using rule 81 (Factor -> id [ Exp ] .)
    print           reduce using rule 81 (Factor -> id [ Exp ] .)
    println         reduce using rule 81 (Factor -> id [ Exp ] .)
    prints          reduce using rule 81 (Factor -> id [ Exp ] .)
    for             reduce using rule 81 (Factor -> id [ Exp ] .)
    while           reduce using rule 81 (Factor -> id [ Exp ] .)
    read            reduce using rule 81 (Factor -> id [ Exp ] .)
    if              reduce using rule 81 (Factor -> id [ Exp ] .)
    repeat          reduce using rule 81 (Factor -> id [ Exp ] .)
    num             reduce using rule 81 (Factor -> id [ Exp ] .)
    (               reduce using rule 81 (Factor -> id [ Exp ] .)
    ;               reduce using rule 81 (Factor -> id [ Exp ] .)
    )               reduce using rule 81 (Factor -> id [ Exp ] .)


state 151

    (47) Attr -> gid [ Exp ] . = Exp
    (48) Attr -> gid [ Exp ] . [ Exp ] = Exp
    (83) Factor -> gid [ Exp ] .
    (84) Factor -> gid [ Exp ] . [ Exp ]

    =               shift and go to state 179
    [               shift and go to state 178
    *               reduce using rule 83 (Factor -> gid [ Exp ] .)
    /               reduce using rule 83 (Factor -> gid [ Exp ] .)
    %               reduce using rule 83 (Factor -> gid [ Exp ] .)
    +               reduce using rule 83 (Factor -> gid [ Exp ] .)
    -               reduce using rule 83 (Factor -> gid [ Exp ] .)
    }               reduce using rule 83 (Factor -> gid [ Exp ] .)
    id              reduce using rule 83 (Factor -> gid [ Exp ] .)
    gid             reduce using rule 83 (Factor -> gid [ Exp ] .)
    return          reduce using rule 83 (Factor -> gid [ Exp ] .)
    print           reduce using rule 83 (Factor -> gid [ Exp ] .)
    println         reduce using rule 83 (Factor -> gid [ Exp ] .)
    prints          reduce using rule 83 (Factor -> gid [ Exp ] .)
    for             reduce using rule 83 (Factor -> gid [ Exp ] .)
    while           reduce using rule 83 (Factor -> gid [ Exp ] .)
    read            reduce using rule 83 (Factor -> gid [ Exp ] .)
    if              reduce using rule 83 (Factor -> gid [ Exp ] .)
    repeat          reduce using rule 83 (Factor -> gid [ Exp ] .)
    num             reduce using rule 83 (Factor -> gid [ Exp ] .)
    (               reduce using rule 83 (Factor -> gid [ Exp ] .)
    ;               reduce using rule 83 (Factor -> gid [ Exp ] .)
    )               reduce using rule 83 (Factor -> gid [ Exp ] .)


state 152

    (49) Return -> return ( Exp ) .

    }               reduce using rule 49 (Return -> return ( Exp ) .)
    id              reduce using rule 49 (Return -> return ( Exp ) .)
    gid             reduce using rule 49 (Return -> return ( Exp ) .)
    return          reduce using rule 49 (Return -> return ( Exp ) .)
    print           reduce using rule 49 (Return -> return ( Exp ) .)
    println         reduce using rule 49 (Return -> return ( Exp ) .)
    prints          reduce using rule 49 (Return -> return ( Exp ) .)
    for             reduce using rule 49 (Return -> return ( Exp ) .)
    while           reduce using rule 49 (Return -> return ( Exp ) .)
    read            reduce using rule 49 (Return -> return ( Exp ) .)
    if              reduce using rule 49 (Return -> return ( Exp ) .)
    repeat          reduce using rule 49 (Return -> return ( Exp ) .)
    num             reduce using rule 49 (Return -> return ( Exp ) .)
    (               reduce using rule 49 (Return -> return ( Exp ) .)
    ;               reduce using rule 49 (Return -> return ( Exp ) .)
    )               reduce using rule 49 (Return -> return ( Exp ) .)


state 153

    (91) Cond -> ( Cond and . Cond )
    (89) Cond -> Cond and . Cond
    (89) Cond -> . Cond and Cond
    (90) Cond -> . Cond or Cond
    (91) Cond -> . ( Cond and Cond )
    (92) Cond -> . ( Cond or Cond )
    (93) Cond -> . Exp sup Exp
    (94) Cond -> . Exp inf Exp
    (95) Cond -> . Exp supeq Exp
    (96) Cond -> . Exp infeq Exp
    (97) Cond -> . not Exp
    (98) Cond -> . Exp eq Exp
    (99) Cond -> . Exp diff Exp
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    (               shift and go to state 78
    not             shift and go to state 81
    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45

    Cond                           shift and go to state 180
    Exp                            shift and go to state 144
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 154

    (92) Cond -> ( Cond or . Cond )
    (90) Cond -> Cond or . Cond
    (89) Cond -> . Cond and Cond
    (90) Cond -> . Cond or Cond
    (91) Cond -> . ( Cond and Cond )
    (92) Cond -> . ( Cond or Cond )
    (93) Cond -> . Exp sup Exp
    (94) Cond -> . Exp inf Exp
    (95) Cond -> . Exp supeq Exp
    (96) Cond -> . Exp infeq Exp
    (97) Cond -> . not Exp
    (98) Cond -> . Exp eq Exp
    (99) Cond -> . Exp diff Exp
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    (               shift and go to state 78
    not             shift and go to state 81
    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45

    Cond                           shift and go to state 181
    Exp                            shift and go to state 144
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 155

    (89) Cond -> Cond and Cond .
    (89) Cond -> Cond . and Cond
    (90) Cond -> Cond . or Cond

  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
    )               reduce using rule 89 (Cond -> Cond and Cond .)
    ;               reduce using rule 89 (Cond -> Cond and Cond .)
    and             shift and go to state 123
    or              shift and go to state 124

  ! and             [ reduce using rule 89 (Cond -> Cond and Cond .) ]
  ! or              [ reduce using rule 89 (Cond -> Cond and Cond .) ]


state 156

    (90) Cond -> Cond or Cond .
    (89) Cond -> Cond . and Cond
    (90) Cond -> Cond . or Cond

  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
    )               reduce using rule 90 (Cond -> Cond or Cond .)
    ;               reduce using rule 90 (Cond -> Cond or Cond .)
    and             shift and go to state 123
    or              shift and go to state 124

  ! and             [ reduce using rule 90 (Cond -> Cond or Cond .) ]
  ! or              [ reduce using rule 90 (Cond -> Cond or Cond .) ]


state 157

    (93) Cond -> Exp sup Exp .
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    )               reduce using rule 93 (Cond -> Exp sup Exp .)
    and             reduce using rule 93 (Cond -> Exp sup Exp .)
    or              reduce using rule 93 (Cond -> Exp sup Exp .)
    ;               reduce using rule 93 (Cond -> Exp sup Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 158

    (94) Cond -> Exp inf Exp .
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    )               reduce using rule 94 (Cond -> Exp inf Exp .)
    and             reduce using rule 94 (Cond -> Exp inf Exp .)
    or              reduce using rule 94 (Cond -> Exp inf Exp .)
    ;               reduce using rule 94 (Cond -> Exp inf Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 159

    (95) Cond -> Exp supeq Exp .
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    )               reduce using rule 95 (Cond -> Exp supeq Exp .)
    and             reduce using rule 95 (Cond -> Exp supeq Exp .)
    or              reduce using rule 95 (Cond -> Exp supeq Exp .)
    ;               reduce using rule 95 (Cond -> Exp supeq Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 160

    (96) Cond -> Exp infeq Exp .
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    )               reduce using rule 96 (Cond -> Exp infeq Exp .)
    and             reduce using rule 96 (Cond -> Exp infeq Exp .)
    or              reduce using rule 96 (Cond -> Exp infeq Exp .)
    ;               reduce using rule 96 (Cond -> Exp infeq Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 161

    (98) Cond -> Exp eq Exp .
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    )               reduce using rule 98 (Cond -> Exp eq Exp .)
    and             reduce using rule 98 (Cond -> Exp eq Exp .)
    or              reduce using rule 98 (Cond -> Exp eq Exp .)
    ;               reduce using rule 98 (Cond -> Exp eq Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 162

    (99) Cond -> Exp diff Exp .
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    )               reduce using rule 99 (Cond -> Exp diff Exp .)
    and             reduce using rule 99 (Cond -> Exp diff Exp .)
    or              reduce using rule 99 (Cond -> Exp diff Exp .)
    ;               reduce using rule 99 (Cond -> Exp diff Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 163

    (81) Factor -> id [ Exp . ]
    (82) Factor -> id [ Exp . ] [ Exp ]
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    ]               shift and go to state 182
    +               shift and go to state 56
    -               shift and go to state 57


state 164

    (83) Factor -> gid [ Exp . ]
    (84) Factor -> gid [ Exp . ] [ Exp ]
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    ]               shift and go to state 183
    +               shift and go to state 56
    -               shift and go to state 57


state 165

    (31) Print -> print ( Exp ) .

    }               reduce using rule 31 (Print -> print ( Exp ) .)
    id              reduce using rule 31 (Print -> print ( Exp ) .)
    gid             reduce using rule 31 (Print -> print ( Exp ) .)
    return          reduce using rule 31 (Print -> print ( Exp ) .)
    print           reduce using rule 31 (Print -> print ( Exp ) .)
    println         reduce using rule 31 (Print -> print ( Exp ) .)
    prints          reduce using rule 31 (Print -> print ( Exp ) .)
    for             reduce using rule 31 (Print -> print ( Exp ) .)
    while           reduce using rule 31 (Print -> print ( Exp ) .)
    read            reduce using rule 31 (Print -> print ( Exp ) .)
    if              reduce using rule 31 (Print -> print ( Exp ) .)
    repeat          reduce using rule 31 (Print -> print ( Exp ) .)
    num             reduce using rule 31 (Print -> print ( Exp ) .)
    (               reduce using rule 31 (Print -> print ( Exp ) .)
    ;               reduce using rule 31 (Print -> print ( Exp ) .)
    )               reduce using rule 31 (Print -> print ( Exp ) .)


state 166

    (32) Println -> println ( Exp ) .

    }               reduce using rule 32 (Println -> println ( Exp ) .)
    id              reduce using rule 32 (Println -> println ( Exp ) .)
    gid             reduce using rule 32 (Println -> println ( Exp ) .)
    return          reduce using rule 32 (Println -> println ( Exp ) .)
    print           reduce using rule 32 (Println -> println ( Exp ) .)
    println         reduce using rule 32 (Println -> println ( Exp ) .)
    prints          reduce using rule 32 (Println -> println ( Exp ) .)
    for             reduce using rule 32 (Println -> println ( Exp ) .)
    while           reduce using rule 32 (Println -> println ( Exp ) .)
    read            reduce using rule 32 (Println -> println ( Exp ) .)
    if              reduce using rule 32 (Println -> println ( Exp ) .)
    repeat          reduce using rule 32 (Println -> println ( Exp ) .)
    num             reduce using rule 32 (Println -> println ( Exp ) .)
    (               reduce using rule 32 (Println -> println ( Exp ) .)
    ;               reduce using rule 32 (Println -> println ( Exp ) .)
    )               reduce using rule 32 (Println -> println ( Exp ) .)


state 167

    (33) Prints -> prints ( string ) .

    }               reduce using rule 33 (Prints -> prints ( string ) .)
    id              reduce using rule 33 (Prints -> prints ( string ) .)
    gid             reduce using rule 33 (Prints -> prints ( string ) .)
    return          reduce using rule 33 (Prints -> prints ( string ) .)
    print           reduce using rule 33 (Prints -> prints ( string ) .)
    println         reduce using rule 33 (Prints -> prints ( string ) .)
    prints          reduce using rule 33 (Prints -> prints ( string ) .)
    for             reduce using rule 33 (Prints -> prints ( string ) .)
    while           reduce using rule 33 (Prints -> prints ( string ) .)
    read            reduce using rule 33 (Prints -> prints ( string ) .)
    if              reduce using rule 33 (Prints -> prints ( string ) .)
    repeat          reduce using rule 33 (Prints -> prints ( string ) .)
    num             reduce using rule 33 (Prints -> prints ( string ) .)
    (               reduce using rule 33 (Prints -> prints ( string ) .)
    ;               reduce using rule 33 (Prints -> prints ( string ) .)
    )               reduce using rule 33 (Prints -> prints ( string ) .)


state 168

    (26) Repeat -> RepeatS ( num ) . { Insts }

    {               shift and go to state 184


state 169

    (28) For -> for ( Insts ; . Cond ; Insts ) { Insts }
    (89) Cond -> . Cond and Cond
    (90) Cond -> . Cond or Cond
    (91) Cond -> . ( Cond and Cond )
    (92) Cond -> . ( Cond or Cond )
    (93) Cond -> . Exp sup Exp
    (94) Cond -> . Exp inf Exp
    (95) Cond -> . Exp supeq Exp
    (96) Cond -> . Exp infeq Exp
    (97) Cond -> . not Exp
    (98) Cond -> . Exp eq Exp
    (99) Cond -> . Exp diff Exp
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    (               shift and go to state 78
    not             shift and go to state 81
    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45

    Cond                           shift and go to state 185
    Exp                            shift and go to state 144
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 170

    (29) While -> while ( Cond ) . { Insts }

    {               shift and go to state 186


state 171

    (30) Read -> read ( id ) .

    }               reduce using rule 30 (Read -> read ( id ) .)
    id              reduce using rule 30 (Read -> read ( id ) .)
    gid             reduce using rule 30 (Read -> read ( id ) .)
    return          reduce using rule 30 (Read -> read ( id ) .)
    print           reduce using rule 30 (Read -> read ( id ) .)
    println         reduce using rule 30 (Read -> read ( id ) .)
    prints          reduce using rule 30 (Read -> read ( id ) .)
    for             reduce using rule 30 (Read -> read ( id ) .)
    while           reduce using rule 30 (Read -> read ( id ) .)
    read            reduce using rule 30 (Read -> read ( id ) .)
    if              reduce using rule 30 (Read -> read ( id ) .)
    repeat          reduce using rule 30 (Read -> read ( id ) .)
    num             reduce using rule 30 (Read -> read ( id ) .)
    (               reduce using rule 30 (Read -> read ( id ) .)
    ;               reduce using rule 30 (Read -> read ( id ) .)
    )               reduce using rule 30 (Read -> read ( id ) .)


state 172

    (50) If -> if ( Cond ) . { Insts }
    (51) If -> if ( Cond ) . Inst
    (53) If -> if ( Cond ) . { Insts } else { Insts }
    (15) Inst -> . Attr
    (16) Inst -> . Return
    (17) Inst -> . Exp
    (18) Inst -> . Print
    (19) Inst -> . Println
    (20) Inst -> . Prints
    (21) Inst -> . Repeat
    (22) Inst -> . For
    (23) Inst -> . While
    (24) Inst -> . Read
    (25) Inst -> . If
    (43) Attr -> . id = Exp
    (44) Attr -> . id [ Exp ] = Exp
    (45) Attr -> . id [ Exp ] [ Exp ] = Exp
    (46) Attr -> . gid = Exp
    (47) Attr -> . gid [ Exp ] = Exp
    (48) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (49) Return -> . return ( Exp )
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (31) Print -> . print ( Exp )
    (32) Println -> . println ( Exp )
    (33) Prints -> . prints ( string )
    (26) Repeat -> . RepeatS ( num ) { Insts }
    (28) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (29) While -> . while ( Cond ) { Insts }
    (30) Read -> . read ( id )
    (50) If -> . if ( Cond ) { Insts }
    (51) If -> . if ( Cond ) Inst
    (53) If -> . if ( Cond ) { Insts } else { Insts }
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (27) RepeatS -> . repeat
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    {               shift and go to state 187
    id              shift and go to state 36
    gid             shift and go to state 37
    return          shift and go to state 38
    print           shift and go to state 41
    println         shift and go to state 42
    prints          shift and go to state 43
    for             shift and go to state 46
    while           shift and go to state 47
    read            shift and go to state 48
    if              shift and go to state 49
    repeat          shift and go to state 51
    num             shift and go to state 45
    (               shift and go to state 39

    Inst                           shift and go to state 188
    Attr                           shift and go to state 25
    Return                         shift and go to state 26
    Exp                            shift and go to state 27
    Print                          shift and go to state 28
    Println                        shift and go to state 29
    Prints                         shift and go to state 30
    Repeat                         shift and go to state 31
    For                            shift and go to state 32
    While                          shift and go to state 33
    Read                           shift and go to state 34
    If                             shift and go to state 35
    Term                           shift and go to state 40
    RepeatS                        shift and go to state 44
    Factor                         shift and go to state 50

state 173

    (35) Dcl -> id [ num . ]
    (36) Dcl -> id [ num . ] [ num ]

    ]               shift and go to state 189


state 174

    (38) Dcl -> id = num .

    }               reduce using rule 38 (Dcl -> id = num .)
    id              reduce using rule 38 (Dcl -> id = num .)


state 175

    (40) DclGlobal -> int id [ num ] [ . num ]

    num             shift and go to state 190


state 176

    (45) Attr -> id [ Exp ] [ . Exp ] = Exp
    (82) Factor -> id [ Exp ] [ . Exp ]
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 191
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 177

    (44) Attr -> id [ Exp ] = . Exp
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 192
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 178

    (48) Attr -> gid [ Exp ] [ . Exp ] = Exp
    (84) Factor -> gid [ Exp ] [ . Exp ]
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 193
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 179

    (47) Attr -> gid [ Exp ] = . Exp
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 194
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 180

    (91) Cond -> ( Cond and Cond . )
    (89) Cond -> Cond and Cond .
    (89) Cond -> Cond . and Cond
    (90) Cond -> Cond . or Cond

  ! shift/reduce conflict for ) resolved as shift
  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
    )               shift and go to state 195
    and             shift and go to state 123
    or              shift and go to state 124

  ! and             [ reduce using rule 89 (Cond -> Cond and Cond .) ]
  ! or              [ reduce using rule 89 (Cond -> Cond and Cond .) ]
  ! )               [ reduce using rule 89 (Cond -> Cond and Cond .) ]


state 181

    (92) Cond -> ( Cond or Cond . )
    (90) Cond -> Cond or Cond .
    (89) Cond -> Cond . and Cond
    (90) Cond -> Cond . or Cond

  ! shift/reduce conflict for ) resolved as shift
  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
    )               shift and go to state 196
    and             shift and go to state 123
    or              shift and go to state 124

  ! and             [ reduce using rule 90 (Cond -> Cond or Cond .) ]
  ! or              [ reduce using rule 90 (Cond -> Cond or Cond .) ]
  ! )               [ reduce using rule 90 (Cond -> Cond or Cond .) ]


state 182

    (81) Factor -> id [ Exp ] .
    (82) Factor -> id [ Exp ] . [ Exp ]

    *               reduce using rule 81 (Factor -> id [ Exp ] .)
    /               reduce using rule 81 (Factor -> id [ Exp ] .)
    %               reduce using rule 81 (Factor -> id [ Exp ] .)
    )               reduce using rule 81 (Factor -> id [ Exp ] .)
    sup             reduce using rule 81 (Factor -> id [ Exp ] .)
    inf             reduce using rule 81 (Factor -> id [ Exp ] .)
    supeq           reduce using rule 81 (Factor -> id [ Exp ] .)
    infeq           reduce using rule 81 (Factor -> id [ Exp ] .)
    eq              reduce using rule 81 (Factor -> id [ Exp ] .)
    diff            reduce using rule 81 (Factor -> id [ Exp ] .)
    +               reduce using rule 81 (Factor -> id [ Exp ] .)
    -               reduce using rule 81 (Factor -> id [ Exp ] .)
    }               reduce using rule 81 (Factor -> id [ Exp ] .)
    id              reduce using rule 81 (Factor -> id [ Exp ] .)
    gid             reduce using rule 81 (Factor -> id [ Exp ] .)
    return          reduce using rule 81 (Factor -> id [ Exp ] .)
    print           reduce using rule 81 (Factor -> id [ Exp ] .)
    println         reduce using rule 81 (Factor -> id [ Exp ] .)
    prints          reduce using rule 81 (Factor -> id [ Exp ] .)
    for             reduce using rule 81 (Factor -> id [ Exp ] .)
    while           reduce using rule 81 (Factor -> id [ Exp ] .)
    read            reduce using rule 81 (Factor -> id [ Exp ] .)
    if              reduce using rule 81 (Factor -> id [ Exp ] .)
    repeat          reduce using rule 81 (Factor -> id [ Exp ] .)
    num             reduce using rule 81 (Factor -> id [ Exp ] .)
    (               reduce using rule 81 (Factor -> id [ Exp ] .)
    ;               reduce using rule 81 (Factor -> id [ Exp ] .)
    ]               reduce using rule 81 (Factor -> id [ Exp ] .)
    and             reduce using rule 81 (Factor -> id [ Exp ] .)
    or              reduce using rule 81 (Factor -> id [ Exp ] .)
    [               shift and go to state 197


state 183

    (83) Factor -> gid [ Exp ] .
    (84) Factor -> gid [ Exp ] . [ Exp ]

    *               reduce using rule 83 (Factor -> gid [ Exp ] .)
    /               reduce using rule 83 (Factor -> gid [ Exp ] .)
    %               reduce using rule 83 (Factor -> gid [ Exp ] .)
    )               reduce using rule 83 (Factor -> gid [ Exp ] .)
    sup             reduce using rule 83 (Factor -> gid [ Exp ] .)
    inf             reduce using rule 83 (Factor -> gid [ Exp ] .)
    supeq           reduce using rule 83 (Factor -> gid [ Exp ] .)
    infeq           reduce using rule 83 (Factor -> gid [ Exp ] .)
    eq              reduce using rule 83 (Factor -> gid [ Exp ] .)
    diff            reduce using rule 83 (Factor -> gid [ Exp ] .)
    +               reduce using rule 83 (Factor -> gid [ Exp ] .)
    -               reduce using rule 83 (Factor -> gid [ Exp ] .)
    }               reduce using rule 83 (Factor -> gid [ Exp ] .)
    id              reduce using rule 83 (Factor -> gid [ Exp ] .)
    gid             reduce using rule 83 (Factor -> gid [ Exp ] .)
    return          reduce using rule 83 (Factor -> gid [ Exp ] .)
    print           reduce using rule 83 (Factor -> gid [ Exp ] .)
    println         reduce using rule 83 (Factor -> gid [ Exp ] .)
    prints          reduce using rule 83 (Factor -> gid [ Exp ] .)
    for             reduce using rule 83 (Factor -> gid [ Exp ] .)
    while           reduce using rule 83 (Factor -> gid [ Exp ] .)
    read            reduce using rule 83 (Factor -> gid [ Exp ] .)
    if              reduce using rule 83 (Factor -> gid [ Exp ] .)
    repeat          reduce using rule 83 (Factor -> gid [ Exp ] .)
    num             reduce using rule 83 (Factor -> gid [ Exp ] .)
    (               reduce using rule 83 (Factor -> gid [ Exp ] .)
    ;               reduce using rule 83 (Factor -> gid [ Exp ] .)
    ]               reduce using rule 83 (Factor -> gid [ Exp ] .)
    and             reduce using rule 83 (Factor -> gid [ Exp ] .)
    or              reduce using rule 83 (Factor -> gid [ Exp ] .)
    [               shift and go to state 198


state 184

    (26) Repeat -> RepeatS ( num ) { . Insts }
    (13) Insts -> . Insts Inst
    (14) Insts -> .

    }               reduce using rule 14 (Insts -> .)
    id              reduce using rule 14 (Insts -> .)
    gid             reduce using rule 14 (Insts -> .)
    return          reduce using rule 14 (Insts -> .)
    print           reduce using rule 14 (Insts -> .)
    println         reduce using rule 14 (Insts -> .)
    prints          reduce using rule 14 (Insts -> .)
    for             reduce using rule 14 (Insts -> .)
    while           reduce using rule 14 (Insts -> .)
    read            reduce using rule 14 (Insts -> .)
    if              reduce using rule 14 (Insts -> .)
    repeat          reduce using rule 14 (Insts -> .)
    num             reduce using rule 14 (Insts -> .)
    (               reduce using rule 14 (Insts -> .)

    Insts                          shift and go to state 199

state 185

    (28) For -> for ( Insts ; Cond . ; Insts ) { Insts }
    (89) Cond -> Cond . and Cond
    (90) Cond -> Cond . or Cond

    ;               shift and go to state 200
    and             shift and go to state 123
    or              shift and go to state 124


state 186

    (29) While -> while ( Cond ) { . Insts }
    (13) Insts -> . Insts Inst
    (14) Insts -> .

    }               reduce using rule 14 (Insts -> .)
    id              reduce using rule 14 (Insts -> .)
    gid             reduce using rule 14 (Insts -> .)
    return          reduce using rule 14 (Insts -> .)
    print           reduce using rule 14 (Insts -> .)
    println         reduce using rule 14 (Insts -> .)
    prints          reduce using rule 14 (Insts -> .)
    for             reduce using rule 14 (Insts -> .)
    while           reduce using rule 14 (Insts -> .)
    read            reduce using rule 14 (Insts -> .)
    if              reduce using rule 14 (Insts -> .)
    repeat          reduce using rule 14 (Insts -> .)
    num             reduce using rule 14 (Insts -> .)
    (               reduce using rule 14 (Insts -> .)

    Insts                          shift and go to state 201

state 187

    (50) If -> if ( Cond ) { . Insts }
    (53) If -> if ( Cond ) { . Insts } else { Insts }
    (13) Insts -> . Insts Inst
    (14) Insts -> .

    }               reduce using rule 14 (Insts -> .)
    id              reduce using rule 14 (Insts -> .)
    gid             reduce using rule 14 (Insts -> .)
    return          reduce using rule 14 (Insts -> .)
    print           reduce using rule 14 (Insts -> .)
    println         reduce using rule 14 (Insts -> .)
    prints          reduce using rule 14 (Insts -> .)
    for             reduce using rule 14 (Insts -> .)
    while           reduce using rule 14 (Insts -> .)
    read            reduce using rule 14 (Insts -> .)
    if              reduce using rule 14 (Insts -> .)
    repeat          reduce using rule 14 (Insts -> .)
    num             reduce using rule 14 (Insts -> .)
    (               reduce using rule 14 (Insts -> .)

    Insts                          shift and go to state 202

state 188

    (51) If -> if ( Cond ) Inst .

    }               reduce using rule 51 (If -> if ( Cond ) Inst .)
    id              reduce using rule 51 (If -> if ( Cond ) Inst .)
    gid             reduce using rule 51 (If -> if ( Cond ) Inst .)
    return          reduce using rule 51 (If -> if ( Cond ) Inst .)
    print           reduce using rule 51 (If -> if ( Cond ) Inst .)
    println         reduce using rule 51 (If -> if ( Cond ) Inst .)
    prints          reduce using rule 51 (If -> if ( Cond ) Inst .)
    for             reduce using rule 51 (If -> if ( Cond ) Inst .)
    while           reduce using rule 51 (If -> if ( Cond ) Inst .)
    read            reduce using rule 51 (If -> if ( Cond ) Inst .)
    if              reduce using rule 51 (If -> if ( Cond ) Inst .)
    repeat          reduce using rule 51 (If -> if ( Cond ) Inst .)
    num             reduce using rule 51 (If -> if ( Cond ) Inst .)
    (               reduce using rule 51 (If -> if ( Cond ) Inst .)
    ;               reduce using rule 51 (If -> if ( Cond ) Inst .)
    )               reduce using rule 51 (If -> if ( Cond ) Inst .)


state 189

    (35) Dcl -> id [ num ] .
    (36) Dcl -> id [ num ] . [ num ]

    }               reduce using rule 35 (Dcl -> id [ num ] .)
    id              reduce using rule 35 (Dcl -> id [ num ] .)
    [               shift and go to state 203


state 190

    (40) DclGlobal -> int id [ num ] [ num . ]

    ]               shift and go to state 204


state 191

    (45) Attr -> id [ Exp ] [ Exp . ] = Exp
    (82) Factor -> id [ Exp ] [ Exp . ]
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    ]               shift and go to state 205
    +               shift and go to state 56
    -               shift and go to state 57


state 192

    (44) Attr -> id [ Exp ] = Exp .
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    }               reduce using rule 44 (Attr -> id [ Exp ] = Exp .)
    id              reduce using rule 44 (Attr -> id [ Exp ] = Exp .)
    gid             reduce using rule 44 (Attr -> id [ Exp ] = Exp .)
    return          reduce using rule 44 (Attr -> id [ Exp ] = Exp .)
    print           reduce using rule 44 (Attr -> id [ Exp ] = Exp .)
    println         reduce using rule 44 (Attr -> id [ Exp ] = Exp .)
    prints          reduce using rule 44 (Attr -> id [ Exp ] = Exp .)
    for             reduce using rule 44 (Attr -> id [ Exp ] = Exp .)
    while           reduce using rule 44 (Attr -> id [ Exp ] = Exp .)
    read            reduce using rule 44 (Attr -> id [ Exp ] = Exp .)
    if              reduce using rule 44 (Attr -> id [ Exp ] = Exp .)
    repeat          reduce using rule 44 (Attr -> id [ Exp ] = Exp .)
    num             reduce using rule 44 (Attr -> id [ Exp ] = Exp .)
    (               reduce using rule 44 (Attr -> id [ Exp ] = Exp .)
    ;               reduce using rule 44 (Attr -> id [ Exp ] = Exp .)
    )               reduce using rule 44 (Attr -> id [ Exp ] = Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 193

    (48) Attr -> gid [ Exp ] [ Exp . ] = Exp
    (84) Factor -> gid [ Exp ] [ Exp . ]
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    ]               shift and go to state 206
    +               shift and go to state 56
    -               shift and go to state 57


state 194

    (47) Attr -> gid [ Exp ] = Exp .
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    }               reduce using rule 47 (Attr -> gid [ Exp ] = Exp .)
    id              reduce using rule 47 (Attr -> gid [ Exp ] = Exp .)
    gid             reduce using rule 47 (Attr -> gid [ Exp ] = Exp .)
    return          reduce using rule 47 (Attr -> gid [ Exp ] = Exp .)
    print           reduce using rule 47 (Attr -> gid [ Exp ] = Exp .)
    println         reduce using rule 47 (Attr -> gid [ Exp ] = Exp .)
    prints          reduce using rule 47 (Attr -> gid [ Exp ] = Exp .)
    for             reduce using rule 47 (Attr -> gid [ Exp ] = Exp .)
    while           reduce using rule 47 (Attr -> gid [ Exp ] = Exp .)
    read            reduce using rule 47 (Attr -> gid [ Exp ] = Exp .)
    if              reduce using rule 47 (Attr -> gid [ Exp ] = Exp .)
    repeat          reduce using rule 47 (Attr -> gid [ Exp ] = Exp .)
    num             reduce using rule 47 (Attr -> gid [ Exp ] = Exp .)
    (               reduce using rule 47 (Attr -> gid [ Exp ] = Exp .)
    ;               reduce using rule 47 (Attr -> gid [ Exp ] = Exp .)
    )               reduce using rule 47 (Attr -> gid [ Exp ] = Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 195

    (91) Cond -> ( Cond and Cond ) .

    )               reduce using rule 91 (Cond -> ( Cond and Cond ) .)
    and             reduce using rule 91 (Cond -> ( Cond and Cond ) .)
    or              reduce using rule 91 (Cond -> ( Cond and Cond ) .)
    ;               reduce using rule 91 (Cond -> ( Cond and Cond ) .)


state 196

    (92) Cond -> ( Cond or Cond ) .

    )               reduce using rule 92 (Cond -> ( Cond or Cond ) .)
    and             reduce using rule 92 (Cond -> ( Cond or Cond ) .)
    or              reduce using rule 92 (Cond -> ( Cond or Cond ) .)
    ;               reduce using rule 92 (Cond -> ( Cond or Cond ) .)


state 197

    (82) Factor -> id [ Exp ] [ . Exp ]
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 207
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 198

    (84) Factor -> gid [ Exp ] [ . Exp ]
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 208
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 199

    (26) Repeat -> RepeatS ( num ) { Insts . }
    (13) Insts -> Insts . Inst
    (15) Inst -> . Attr
    (16) Inst -> . Return
    (17) Inst -> . Exp
    (18) Inst -> . Print
    (19) Inst -> . Println
    (20) Inst -> . Prints
    (21) Inst -> . Repeat
    (22) Inst -> . For
    (23) Inst -> . While
    (24) Inst -> . Read
    (25) Inst -> . If
    (43) Attr -> . id = Exp
    (44) Attr -> . id [ Exp ] = Exp
    (45) Attr -> . id [ Exp ] [ Exp ] = Exp
    (46) Attr -> . gid = Exp
    (47) Attr -> . gid [ Exp ] = Exp
    (48) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (49) Return -> . return ( Exp )
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (31) Print -> . print ( Exp )
    (32) Println -> . println ( Exp )
    (33) Prints -> . prints ( string )
    (26) Repeat -> . RepeatS ( num ) { Insts }
    (28) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (29) While -> . while ( Cond ) { Insts }
    (30) Read -> . read ( id )
    (50) If -> . if ( Cond ) { Insts }
    (51) If -> . if ( Cond ) Inst
    (53) If -> . if ( Cond ) { Insts } else { Insts }
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (27) RepeatS -> . repeat
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    }               shift and go to state 209
    id              shift and go to state 36
    gid             shift and go to state 37
    return          shift and go to state 38
    print           shift and go to state 41
    println         shift and go to state 42
    prints          shift and go to state 43
    for             shift and go to state 46
    while           shift and go to state 47
    read            shift and go to state 48
    if              shift and go to state 49
    repeat          shift and go to state 51
    num             shift and go to state 45
    (               shift and go to state 39

    RepeatS                        shift and go to state 44
    Inst                           shift and go to state 24
    Attr                           shift and go to state 25
    Return                         shift and go to state 26
    Exp                            shift and go to state 27
    Print                          shift and go to state 28
    Println                        shift and go to state 29
    Prints                         shift and go to state 30
    Repeat                         shift and go to state 31
    For                            shift and go to state 32
    While                          shift and go to state 33
    Read                           shift and go to state 34
    If                             shift and go to state 35
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 200

    (28) For -> for ( Insts ; Cond ; . Insts ) { Insts }
    (13) Insts -> . Insts Inst
    (14) Insts -> .

    )               reduce using rule 14 (Insts -> .)
    id              reduce using rule 14 (Insts -> .)
    gid             reduce using rule 14 (Insts -> .)
    return          reduce using rule 14 (Insts -> .)
    print           reduce using rule 14 (Insts -> .)
    println         reduce using rule 14 (Insts -> .)
    prints          reduce using rule 14 (Insts -> .)
    for             reduce using rule 14 (Insts -> .)
    while           reduce using rule 14 (Insts -> .)
    read            reduce using rule 14 (Insts -> .)
    if              reduce using rule 14 (Insts -> .)
    repeat          reduce using rule 14 (Insts -> .)
    num             reduce using rule 14 (Insts -> .)
    (               reduce using rule 14 (Insts -> .)

    Insts                          shift and go to state 210

state 201

    (29) While -> while ( Cond ) { Insts . }
    (13) Insts -> Insts . Inst
    (15) Inst -> . Attr
    (16) Inst -> . Return
    (17) Inst -> . Exp
    (18) Inst -> . Print
    (19) Inst -> . Println
    (20) Inst -> . Prints
    (21) Inst -> . Repeat
    (22) Inst -> . For
    (23) Inst -> . While
    (24) Inst -> . Read
    (25) Inst -> . If
    (43) Attr -> . id = Exp
    (44) Attr -> . id [ Exp ] = Exp
    (45) Attr -> . id [ Exp ] [ Exp ] = Exp
    (46) Attr -> . gid = Exp
    (47) Attr -> . gid [ Exp ] = Exp
    (48) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (49) Return -> . return ( Exp )
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (31) Print -> . print ( Exp )
    (32) Println -> . println ( Exp )
    (33) Prints -> . prints ( string )
    (26) Repeat -> . RepeatS ( num ) { Insts }
    (28) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (29) While -> . while ( Cond ) { Insts }
    (30) Read -> . read ( id )
    (50) If -> . if ( Cond ) { Insts }
    (51) If -> . if ( Cond ) Inst
    (53) If -> . if ( Cond ) { Insts } else { Insts }
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (27) RepeatS -> . repeat
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    }               shift and go to state 211
    id              shift and go to state 36
    gid             shift and go to state 37
    return          shift and go to state 38
    print           shift and go to state 41
    println         shift and go to state 42
    prints          shift and go to state 43
    for             shift and go to state 46
    while           shift and go to state 47
    read            shift and go to state 48
    if              shift and go to state 49
    repeat          shift and go to state 51
    num             shift and go to state 45
    (               shift and go to state 39

    Inst                           shift and go to state 24
    Attr                           shift and go to state 25
    Return                         shift and go to state 26
    Exp                            shift and go to state 27
    Print                          shift and go to state 28
    Println                        shift and go to state 29
    Prints                         shift and go to state 30
    Repeat                         shift and go to state 31
    For                            shift and go to state 32
    While                          shift and go to state 33
    Read                           shift and go to state 34
    If                             shift and go to state 35
    Term                           shift and go to state 40
    RepeatS                        shift and go to state 44
    Factor                         shift and go to state 50

state 202

    (50) If -> if ( Cond ) { Insts . }
    (53) If -> if ( Cond ) { Insts . } else { Insts }
    (13) Insts -> Insts . Inst
    (15) Inst -> . Attr
    (16) Inst -> . Return
    (17) Inst -> . Exp
    (18) Inst -> . Print
    (19) Inst -> . Println
    (20) Inst -> . Prints
    (21) Inst -> . Repeat
    (22) Inst -> . For
    (23) Inst -> . While
    (24) Inst -> . Read
    (25) Inst -> . If
    (43) Attr -> . id = Exp
    (44) Attr -> . id [ Exp ] = Exp
    (45) Attr -> . id [ Exp ] [ Exp ] = Exp
    (46) Attr -> . gid = Exp
    (47) Attr -> . gid [ Exp ] = Exp
    (48) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (49) Return -> . return ( Exp )
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (31) Print -> . print ( Exp )
    (32) Println -> . println ( Exp )
    (33) Prints -> . prints ( string )
    (26) Repeat -> . RepeatS ( num ) { Insts }
    (28) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (29) While -> . while ( Cond ) { Insts }
    (30) Read -> . read ( id )
    (50) If -> . if ( Cond ) { Insts }
    (51) If -> . if ( Cond ) Inst
    (53) If -> . if ( Cond ) { Insts } else { Insts }
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (27) RepeatS -> . repeat
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    }               shift and go to state 212
    id              shift and go to state 36
    gid             shift and go to state 37
    return          shift and go to state 38
    print           shift and go to state 41
    println         shift and go to state 42
    prints          shift and go to state 43
    for             shift and go to state 46
    while           shift and go to state 47
    read            shift and go to state 48
    if              shift and go to state 49
    repeat          shift and go to state 51
    num             shift and go to state 45
    (               shift and go to state 39

    Inst                           shift and go to state 24
    Attr                           shift and go to state 25
    Return                         shift and go to state 26
    Exp                            shift and go to state 27
    Print                          shift and go to state 28
    Println                        shift and go to state 29
    Prints                         shift and go to state 30
    Repeat                         shift and go to state 31
    For                            shift and go to state 32
    While                          shift and go to state 33
    Read                           shift and go to state 34
    If                             shift and go to state 35
    Term                           shift and go to state 40
    RepeatS                        shift and go to state 44
    Factor                         shift and go to state 50

state 203

    (36) Dcl -> id [ num ] [ . num ]

    num             shift and go to state 213


state 204

    (40) DclGlobal -> int id [ num ] [ num ] .

    }               reduce using rule 40 (DclGlobal -> int id [ num ] [ num ] .)
    int             reduce using rule 40 (DclGlobal -> int id [ num ] [ num ] .)


state 205

    (45) Attr -> id [ Exp ] [ Exp ] . = Exp
    (82) Factor -> id [ Exp ] [ Exp ] .

    =               shift and go to state 214
    *               reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    /               reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    %               reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    +               reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    -               reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    }               reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    id              reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    gid             reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    return          reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    print           reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    println         reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    prints          reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    for             reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    while           reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    read            reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    if              reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    repeat          reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    num             reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    (               reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    ;               reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    )               reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)


state 206

    (48) Attr -> gid [ Exp ] [ Exp ] . = Exp
    (84) Factor -> gid [ Exp ] [ Exp ] .

    =               shift and go to state 215
    *               reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    /               reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    %               reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    +               reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    -               reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    }               reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    id              reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    gid             reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    return          reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    print           reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    println         reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    prints          reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    for             reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    while           reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    read            reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    if              reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    repeat          reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    num             reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    (               reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    ;               reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    )               reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)


state 207

    (82) Factor -> id [ Exp ] [ Exp . ]
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    ]               shift and go to state 216
    +               shift and go to state 56
    -               shift and go to state 57


state 208

    (84) Factor -> gid [ Exp ] [ Exp . ]
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    ]               shift and go to state 217
    +               shift and go to state 56
    -               shift and go to state 57


state 209

    (26) Repeat -> RepeatS ( num ) { Insts } .

    }               reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    id              reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    gid             reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    return          reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    print           reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    println         reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    prints          reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    for             reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    while           reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    read            reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    if              reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    repeat          reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    num             reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    (               reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    ;               reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)
    )               reduce using rule 26 (Repeat -> RepeatS ( num ) { Insts } .)


state 210

    (28) For -> for ( Insts ; Cond ; Insts . ) { Insts }
    (13) Insts -> Insts . Inst
    (15) Inst -> . Attr
    (16) Inst -> . Return
    (17) Inst -> . Exp
    (18) Inst -> . Print
    (19) Inst -> . Println
    (20) Inst -> . Prints
    (21) Inst -> . Repeat
    (22) Inst -> . For
    (23) Inst -> . While
    (24) Inst -> . Read
    (25) Inst -> . If
    (43) Attr -> . id = Exp
    (44) Attr -> . id [ Exp ] = Exp
    (45) Attr -> . id [ Exp ] [ Exp ] = Exp
    (46) Attr -> . gid = Exp
    (47) Attr -> . gid [ Exp ] = Exp
    (48) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (49) Return -> . return ( Exp )
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (31) Print -> . print ( Exp )
    (32) Println -> . println ( Exp )
    (33) Prints -> . prints ( string )
    (26) Repeat -> . RepeatS ( num ) { Insts }
    (28) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (29) While -> . while ( Cond ) { Insts }
    (30) Read -> . read ( id )
    (50) If -> . if ( Cond ) { Insts }
    (51) If -> . if ( Cond ) Inst
    (53) If -> . if ( Cond ) { Insts } else { Insts }
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (27) RepeatS -> . repeat
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    )               shift and go to state 218
    id              shift and go to state 36
    gid             shift and go to state 37
    return          shift and go to state 38
    print           shift and go to state 41
    println         shift and go to state 42
    prints          shift and go to state 43
    for             shift and go to state 46
    while           shift and go to state 47
    read            shift and go to state 48
    if              shift and go to state 49
    repeat          shift and go to state 51
    num             shift and go to state 45
    (               shift and go to state 39

    Inst                           shift and go to state 24
    Attr                           shift and go to state 25
    Return                         shift and go to state 26
    Exp                            shift and go to state 27
    Print                          shift and go to state 28
    Println                        shift and go to state 29
    Prints                         shift and go to state 30
    Repeat                         shift and go to state 31
    For                            shift and go to state 32
    While                          shift and go to state 33
    Read                           shift and go to state 34
    If                             shift and go to state 35
    Term                           shift and go to state 40
    RepeatS                        shift and go to state 44
    Factor                         shift and go to state 50

state 211

    (29) While -> while ( Cond ) { Insts } .

    }               reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    id              reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    gid             reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    return          reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    print           reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    println         reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    prints          reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    for             reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    while           reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    read            reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    if              reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    repeat          reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    num             reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    (               reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    ;               reduce using rule 29 (While -> while ( Cond ) { Insts } .)
    )               reduce using rule 29 (While -> while ( Cond ) { Insts } .)


state 212

    (50) If -> if ( Cond ) { Insts } .
    (53) If -> if ( Cond ) { Insts } . else { Insts }

    }               reduce using rule 50 (If -> if ( Cond ) { Insts } .)
    id              reduce using rule 50 (If -> if ( Cond ) { Insts } .)
    gid             reduce using rule 50 (If -> if ( Cond ) { Insts } .)
    return          reduce using rule 50 (If -> if ( Cond ) { Insts } .)
    print           reduce using rule 50 (If -> if ( Cond ) { Insts } .)
    println         reduce using rule 50 (If -> if ( Cond ) { Insts } .)
    prints          reduce using rule 50 (If -> if ( Cond ) { Insts } .)
    for             reduce using rule 50 (If -> if ( Cond ) { Insts } .)
    while           reduce using rule 50 (If -> if ( Cond ) { Insts } .)
    read            reduce using rule 50 (If -> if ( Cond ) { Insts } .)
    if              reduce using rule 50 (If -> if ( Cond ) { Insts } .)
    repeat          reduce using rule 50 (If -> if ( Cond ) { Insts } .)
    num             reduce using rule 50 (If -> if ( Cond ) { Insts } .)
    (               reduce using rule 50 (If -> if ( Cond ) { Insts } .)
    ;               reduce using rule 50 (If -> if ( Cond ) { Insts } .)
    )               reduce using rule 50 (If -> if ( Cond ) { Insts } .)
    else            shift and go to state 219


state 213

    (36) Dcl -> id [ num ] [ num . ]

    ]               shift and go to state 220


state 214

    (45) Attr -> id [ Exp ] [ Exp ] = . Exp
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 221
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 215

    (48) Attr -> gid [ Exp ] [ Exp ] = . Exp
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    id              shift and go to state 82
    gid             shift and go to state 83
    num             shift and go to state 45
    (               shift and go to state 39

    Exp                            shift and go to state 222
    Term                           shift and go to state 40
    Factor                         shift and go to state 50

state 216

    (82) Factor -> id [ Exp ] [ Exp ] .

    *               reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    /               reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    %               reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    )               reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    sup             reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    inf             reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    supeq           reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    infeq           reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    eq              reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    diff            reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    +               reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    -               reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    }               reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    id              reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    gid             reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    return          reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    print           reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    println         reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    prints          reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    for             reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    while           reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    read            reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    if              reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    repeat          reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    num             reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    (               reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    ;               reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    ]               reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    and             reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)
    or              reduce using rule 82 (Factor -> id [ Exp ] [ Exp ] .)


state 217

    (84) Factor -> gid [ Exp ] [ Exp ] .

    *               reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    /               reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    %               reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    )               reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    sup             reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    inf             reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    supeq           reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    infeq           reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    eq              reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    diff            reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    +               reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    -               reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    }               reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    id              reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    gid             reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    return          reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    print           reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    println         reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    prints          reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    for             reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    while           reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    read            reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    if              reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    repeat          reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    num             reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    (               reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    ;               reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    ]               reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    and             reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)
    or              reduce using rule 84 (Factor -> gid [ Exp ] [ Exp ] .)


state 218

    (28) For -> for ( Insts ; Cond ; Insts ) . { Insts }

    {               shift and go to state 223


state 219

    (53) If -> if ( Cond ) { Insts } else . { Insts }

    {               shift and go to state 224


state 220

    (36) Dcl -> id [ num ] [ num ] .

    }               reduce using rule 36 (Dcl -> id [ num ] [ num ] .)
    id              reduce using rule 36 (Dcl -> id [ num ] [ num ] .)


state 221

    (45) Attr -> id [ Exp ] [ Exp ] = Exp .
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    }               reduce using rule 45 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    id              reduce using rule 45 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    gid             reduce using rule 45 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    return          reduce using rule 45 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    print           reduce using rule 45 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    println         reduce using rule 45 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    prints          reduce using rule 45 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    for             reduce using rule 45 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    while           reduce using rule 45 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    read            reduce using rule 45 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    if              reduce using rule 45 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    repeat          reduce using rule 45 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    num             reduce using rule 45 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    (               reduce using rule 45 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    ;               reduce using rule 45 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    )               reduce using rule 45 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 222

    (48) Attr -> gid [ Exp ] [ Exp ] = Exp .
    (55) Exp -> Exp . + Term
    (56) Exp -> Exp . - Term

    }               reduce using rule 48 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    id              reduce using rule 48 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    gid             reduce using rule 48 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    return          reduce using rule 48 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    print           reduce using rule 48 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    println         reduce using rule 48 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    prints          reduce using rule 48 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    for             reduce using rule 48 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    while           reduce using rule 48 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    read            reduce using rule 48 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    if              reduce using rule 48 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    repeat          reduce using rule 48 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    num             reduce using rule 48 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    (               reduce using rule 48 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    ;               reduce using rule 48 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    )               reduce using rule 48 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    +               shift and go to state 56
    -               shift and go to state 57


state 223

    (28) For -> for ( Insts ; Cond ; Insts ) { . Insts }
    (13) Insts -> . Insts Inst
    (14) Insts -> .

    }               reduce using rule 14 (Insts -> .)
    id              reduce using rule 14 (Insts -> .)
    gid             reduce using rule 14 (Insts -> .)
    return          reduce using rule 14 (Insts -> .)
    print           reduce using rule 14 (Insts -> .)
    println         reduce using rule 14 (Insts -> .)
    prints          reduce using rule 14 (Insts -> .)
    for             reduce using rule 14 (Insts -> .)
    while           reduce using rule 14 (Insts -> .)
    read            reduce using rule 14 (Insts -> .)
    if              reduce using rule 14 (Insts -> .)
    repeat          reduce using rule 14 (Insts -> .)
    num             reduce using rule 14 (Insts -> .)
    (               reduce using rule 14 (Insts -> .)

    Insts                          shift and go to state 225

state 224

    (53) If -> if ( Cond ) { Insts } else { . Insts }
    (13) Insts -> . Insts Inst
    (14) Insts -> .

    }               reduce using rule 14 (Insts -> .)
    id              reduce using rule 14 (Insts -> .)
    gid             reduce using rule 14 (Insts -> .)
    return          reduce using rule 14 (Insts -> .)
    print           reduce using rule 14 (Insts -> .)
    println         reduce using rule 14 (Insts -> .)
    prints          reduce using rule 14 (Insts -> .)
    for             reduce using rule 14 (Insts -> .)
    while           reduce using rule 14 (Insts -> .)
    read            reduce using rule 14 (Insts -> .)
    if              reduce using rule 14 (Insts -> .)
    repeat          reduce using rule 14 (Insts -> .)
    num             reduce using rule 14 (Insts -> .)
    (               reduce using rule 14 (Insts -> .)

    Insts                          shift and go to state 226

state 225

    (28) For -> for ( Insts ; Cond ; Insts ) { Insts . }
    (13) Insts -> Insts . Inst
    (15) Inst -> . Attr
    (16) Inst -> . Return
    (17) Inst -> . Exp
    (18) Inst -> . Print
    (19) Inst -> . Println
    (20) Inst -> . Prints
    (21) Inst -> . Repeat
    (22) Inst -> . For
    (23) Inst -> . While
    (24) Inst -> . Read
    (25) Inst -> . If
    (43) Attr -> . id = Exp
    (44) Attr -> . id [ Exp ] = Exp
    (45) Attr -> . id [ Exp ] [ Exp ] = Exp
    (46) Attr -> . gid = Exp
    (47) Attr -> . gid [ Exp ] = Exp
    (48) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (49) Return -> . return ( Exp )
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (31) Print -> . print ( Exp )
    (32) Println -> . println ( Exp )
    (33) Prints -> . prints ( string )
    (26) Repeat -> . RepeatS ( num ) { Insts }
    (28) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (29) While -> . while ( Cond ) { Insts }
    (30) Read -> . read ( id )
    (50) If -> . if ( Cond ) { Insts }
    (51) If -> . if ( Cond ) Inst
    (53) If -> . if ( Cond ) { Insts } else { Insts }
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (27) RepeatS -> . repeat
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    }               shift and go to state 227
    id              shift and go to state 36
    gid             shift and go to state 37
    return          shift and go to state 38
    print           shift and go to state 41
    println         shift and go to state 42
    prints          shift and go to state 43
    for             shift and go to state 46
    while           shift and go to state 47
    read            shift and go to state 48
    if              shift and go to state 49
    repeat          shift and go to state 51
    num             shift and go to state 45
    (               shift and go to state 39

    Inst                           shift and go to state 24
    Attr                           shift and go to state 25
    Return                         shift and go to state 26
    Exp                            shift and go to state 27
    Print                          shift and go to state 28
    Println                        shift and go to state 29
    Prints                         shift and go to state 30
    Repeat                         shift and go to state 31
    For                            shift and go to state 32
    While                          shift and go to state 33
    Read                           shift and go to state 34
    If                             shift and go to state 35
    Term                           shift and go to state 40
    RepeatS                        shift and go to state 44
    Factor                         shift and go to state 50

state 226

    (53) If -> if ( Cond ) { Insts } else { Insts . }
    (13) Insts -> Insts . Inst
    (15) Inst -> . Attr
    (16) Inst -> . Return
    (17) Inst -> . Exp
    (18) Inst -> . Print
    (19) Inst -> . Println
    (20) Inst -> . Prints
    (21) Inst -> . Repeat
    (22) Inst -> . For
    (23) Inst -> . While
    (24) Inst -> . Read
    (25) Inst -> . If
    (43) Attr -> . id = Exp
    (44) Attr -> . id [ Exp ] = Exp
    (45) Attr -> . id [ Exp ] [ Exp ] = Exp
    (46) Attr -> . gid = Exp
    (47) Attr -> . gid [ Exp ] = Exp
    (48) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (49) Return -> . return ( Exp )
    (55) Exp -> . Exp + Term
    (56) Exp -> . Exp - Term
    (57) Exp -> . id addeq Term
    (58) Exp -> . id subeq Term
    (59) Exp -> . id addeql Term
    (60) Exp -> . id subeql Term
    (61) Exp -> . Term
    (31) Print -> . print ( Exp )
    (32) Println -> . println ( Exp )
    (33) Prints -> . prints ( string )
    (26) Repeat -> . RepeatS ( num ) { Insts }
    (28) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (29) While -> . while ( Cond ) { Insts }
    (30) Read -> . read ( id )
    (50) If -> . if ( Cond ) { Insts }
    (51) If -> . if ( Cond ) Inst
    (53) If -> . if ( Cond ) { Insts } else { Insts }
    (62) Term -> . Term * Factor
    (63) Term -> . Term / Factor
    (64) Term -> . Term % Factor
    (65) Term -> . id muleq Factor
    (66) Term -> . id diveq Factor
    (67) Term -> . id modeq Factor
    (68) Term -> . id muleql Factor
    (69) Term -> . id diveql Factor
    (70) Term -> . id modeql Factor
    (71) Term -> . Factor
    (27) RepeatS -> . repeat
    (72) Factor -> . id plus
    (73) Factor -> . id plusl
    (74) Factor -> . id minus
    (75) Factor -> . id minusl
    (76) Factor -> . id
    (77) Factor -> . gid
    (78) Factor -> . num
    (79) Factor -> . id ( )
    (80) Factor -> . ( Cond )
    (81) Factor -> . id [ Exp ]
    (82) Factor -> . id [ Exp ] [ Exp ]
    (83) Factor -> . gid [ Exp ]
    (84) Factor -> . gid [ Exp ] [ Exp ]
    (85) Factor -> . ( Exp )

    }               shift and go to state 228
    id              shift and go to state 36
    gid             shift and go to state 37
    return          shift and go to state 38
    print           shift and go to state 41
    println         shift and go to state 42
    prints          shift and go to state 43
    for             shift and go to state 46
    while           shift and go to state 47
    read            shift and go to state 48
    if              shift and go to state 49
    repeat          shift and go to state 51
    num             shift and go to state 45
    (               shift and go to state 39

    Inst                           shift and go to state 24
    Attr                           shift and go to state 25
    Return                         shift and go to state 26
    Exp                            shift and go to state 27
    Print                          shift and go to state 28
    Println                        shift and go to state 29
    Prints                         shift and go to state 30
    Repeat                         shift and go to state 31
    For                            shift and go to state 32
    While                          shift and go to state 33
    Read                           shift and go to state 34
    If                             shift and go to state 35
    Term                           shift and go to state 40
    RepeatS                        shift and go to state 44
    Factor                         shift and go to state 50

state 227

    (28) For -> for ( Insts ; Cond ; Insts ) { Insts } .

    }               reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    id              reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    gid             reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    return          reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    print           reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    println         reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    prints          reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    for             reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    while           reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    read            reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    if              reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    repeat          reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    num             reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    (               reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    ;               reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    )               reduce using rule 28 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)


state 228

    (53) If -> if ( Cond ) { Insts } else { Insts } .

    }               reduce using rule 53 (If -> if ( Cond ) { Insts } else { Insts } .)
    id              reduce using rule 53 (If -> if ( Cond ) { Insts } else { Insts } .)
    gid             reduce using rule 53 (If -> if ( Cond ) { Insts } else { Insts } .)
    return          reduce using rule 53 (If -> if ( Cond ) { Insts } else { Insts } .)
    print           reduce using rule 53 (If -> if ( Cond ) { Insts } else { Insts } .)
    println         reduce using rule 53 (If -> if ( Cond ) { Insts } else { Insts } .)
    prints          reduce using rule 53 (If -> if ( Cond ) { Insts } else { Insts } .)
    for             reduce using rule 53 (If -> if ( Cond ) { Insts } else { Insts } .)
    while           reduce using rule 53 (If -> if ( Cond ) { Insts } else { Insts } .)
    read            reduce using rule 53 (If -> if ( Cond ) { Insts } else { Insts } .)
    if              reduce using rule 53 (If -> if ( Cond ) { Insts } else { Insts } .)
    repeat          reduce using rule 53 (If -> if ( Cond ) { Insts } else { Insts } .)
    num             reduce using rule 53 (If -> if ( Cond ) { Insts } else { Insts } .)
    (               reduce using rule 53 (If -> if ( Cond ) { Insts } else { Insts } .)
    ;               reduce using rule 53 (If -> if ( Cond ) { Insts } else { Insts } .)
    )               reduce using rule 53 (If -> if ( Cond ) { Insts } else { Insts } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ( in state 36 resolved as shift
WARNING: shift/reduce conflict for ( in state 82 resolved as shift
WARNING: shift/reduce conflict for ( in state 102 resolved as shift
WARNING: shift/reduce conflict for ( in state 110 resolved as shift
WARNING: shift/reduce conflict for and in state 155 resolved as shift
WARNING: shift/reduce conflict for or in state 155 resolved as shift
WARNING: shift/reduce conflict for and in state 156 resolved as shift
WARNING: shift/reduce conflict for or in state 156 resolved as shift
WARNING: shift/reduce conflict for ) in state 180 resolved as shift
WARNING: shift/reduce conflict for and in state 180 resolved as shift
WARNING: shift/reduce conflict for or in state 180 resolved as shift
WARNING: shift/reduce conflict for ) in state 181 resolved as shift
WARNING: shift/reduce conflict for and in state 181 resolved as shift
WARNING: shift/reduce conflict for or in state 181 resolved as shift
