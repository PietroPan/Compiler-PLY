Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    numR

Grammar

Rule 0     S' -> Prog
Rule 1     Prog -> GlobalBlc MainBlc DefBlcs
Rule 2     DefBlcs -> DefBlcs DefBlc
Rule 3     DefBlcs -> <empty>
Rule 4     DefBlc -> id { VarBlcs Insts }
Rule 5     VarBlcs -> VarBlcs BlcInt
Rule 6     VarBlcs -> <empty>
Rule 7     GlobalBlc -> global { VarBlcs }
Rule 8     GlobalBlc -> <empty>
Rule 9     Dcls -> Dcls Dcl
Rule 10    Dcls -> <empty>
Rule 11    MainBlc -> main { VarBlcs Insts }
Rule 12    Insts -> Insts Inst
Rule 13    Insts -> <empty>
Rule 14    Inst -> Attr
Rule 15    Inst -> Return
Rule 16    Inst -> Exp
Rule 17    Inst -> Print
Rule 18    Inst -> Println
Rule 19    Inst -> Prints
Rule 20    Inst -> Repeat
Rule 21    Inst -> For
Rule 22    Inst -> While
Rule 23    Inst -> Read
Rule 24    Inst -> If
Rule 25    Repeat -> RepeatS ( num ) { Insts }
Rule 26    RepeatS -> repeat
Rule 27    For -> for ( Insts ; Cond ; Insts ) { Insts }
Rule 28    While -> while ( Cond ) { Insts }
Rule 29    Read -> read ( id )
Rule 30    Print -> print ( Exp )
Rule 31    Println -> println ( Exp )
Rule 32    Prints -> prints ( string )
Rule 33    BlcInt -> int { Dcls }
Rule 34    Dcl -> id [ num ]
Rule 35    Dcl -> id [ num ] [ num ]
Rule 36    Dcl -> id
Rule 37    Dcl -> id = num
Rule 38    Attr -> id = Exp
Rule 39    Attr -> id [ Exp ] = Exp
Rule 40    Attr -> id [ Exp ] [ Exp ] = Exp
Rule 41    Attr -> gid = Exp
Rule 42    Attr -> gid [ Exp ] = Exp
Rule 43    Attr -> gid [ Exp ] [ Exp ] = Exp
Rule 44    Return -> return ( Exp )
Rule 45    If -> if ( Cond ) { Insts }
Rule 46    If -> if ( Cond ) Inst
Rule 47    If -> if ( Cond ) { Insts } else { Insts }
Rule 48    Exp -> Exp + Term
Rule 49    Exp -> Exp - Term
Rule 50    Exp -> id addeq Term
Rule 51    Exp -> id subeq Term
Rule 52    Exp -> id addeql Term
Rule 53    Exp -> id subeql Term
Rule 54    Exp -> Term
Rule 55    Term -> Term * Factor
Rule 56    Term -> Term / Factor
Rule 57    Term -> Term % Factor
Rule 58    Term -> id muleq Factor
Rule 59    Term -> id diveq Factor
Rule 60    Term -> id modeq Factor
Rule 61    Term -> id muleql Factor
Rule 62    Term -> id diveql Factor
Rule 63    Term -> id modeql Factor
Rule 64    Term -> Factor
Rule 65    Factor -> id plus
Rule 66    Factor -> id plusl
Rule 67    Factor -> id minus
Rule 68    Factor -> id minusl
Rule 69    Factor -> id
Rule 70    Factor -> gid
Rule 71    Factor -> num
Rule 72    Factor -> id ( )
Rule 73    Factor -> ( Cond )
Rule 74    Factor -> id [ Exp ]
Rule 75    Factor -> id [ Exp ] [ Exp ]
Rule 76    Factor -> gid [ Exp ]
Rule 77    Factor -> gid [ Exp ] [ Exp ]
Rule 78    Factor -> ( Exp )
Rule 79    Cond -> Cond and Cond
Rule 80    Cond -> Cond or Cond
Rule 81    Cond -> ( Cond and Cond )
Rule 82    Cond -> ( Cond or Cond )
Rule 83    Cond -> Exp sup Exp
Rule 84    Cond -> Exp inf Exp
Rule 85    Cond -> Exp supeq Exp
Rule 86    Cond -> Exp infeq Exp
Rule 87    Cond -> not Exp
Rule 88    Cond -> Exp eq Exp
Rule 89    Cond -> Exp diff Exp

Terminals, with rules where they appear

%                    : 57
(                    : 25 27 28 29 30 31 32 44 45 46 47 72 73 78 81 82
)                    : 25 27 28 29 30 31 32 44 45 46 47 72 73 78 81 82
*                    : 55
+                    : 48
-                    : 49
/                    : 56
;                    : 27 27
=                    : 37 38 39 40 41 42 43
[                    : 34 35 35 39 40 40 42 43 43 74 75 75 76 77 77
]                    : 34 35 35 39 40 40 42 43 43 74 75 75 76 77 77
addeq                : 50
addeql               : 52
and                  : 79 81
diff                 : 89
diveq                : 59
diveql               : 62
else                 : 47
eq                   : 88
error                : 
for                  : 27
gid                  : 41 42 43 70 76 77
global               : 7
id                   : 4 29 34 35 36 37 38 39 40 50 51 52 53 58 59 60 61 62 63 65 66 67 68 69 72 74 75
if                   : 45 46 47
inf                  : 84
infeq                : 86
int                  : 33
main                 : 11
minus                : 67
minusl               : 68
modeq                : 60
modeql               : 63
muleq                : 58
muleql               : 61
not                  : 87
num                  : 25 34 35 35 37 71
numR                 : 
or                   : 80 82
plus                 : 65
plusl                : 66
print                : 30
println              : 31
prints               : 32
read                 : 29
repeat               : 26
return               : 44
string               : 32
subeq                : 51
subeql               : 53
sup                  : 83
supeq                : 85
while                : 28
{                    : 4 7 11 25 27 28 33 45 47 47
}                    : 4 7 11 25 27 28 33 45 47 47

Nonterminals, with rules where they appear

Attr                 : 14
BlcInt               : 5
Cond                 : 27 28 45 46 47 73 79 79 80 80 81 81 82 82
Dcl                  : 9
Dcls                 : 9 33
DefBlc               : 2
DefBlcs              : 1 2
Exp                  : 16 30 31 38 39 39 40 40 40 41 42 42 43 43 43 44 48 49 74 75 75 76 77 77 78 83 83 84 84 85 85 86 86 87 88 88 89 89
Factor               : 55 56 57 58 59 60 61 62 63 64
For                  : 21
GlobalBlc            : 1
If                   : 24
Inst                 : 12 46
Insts                : 4 11 12 25 27 27 27 28 45 47 47
MainBlc              : 1
Print                : 17
Println              : 18
Prints               : 19
Prog                 : 0
Read                 : 23
Repeat               : 20
RepeatS              : 25
Return               : 15
Term                 : 48 49 50 51 52 53 54 55 56 57
VarBlcs              : 4 5 7 11
While                : 22

Parsing method: LALR

state 0

    (0) S' -> . Prog
    (1) Prog -> . GlobalBlc MainBlc DefBlcs
    (7) GlobalBlc -> . global { VarBlcs }
    (8) GlobalBlc -> .

    global          shift and go to state 3
    main            reduce using rule 8 (GlobalBlc -> .)

    Prog                           shift and go to state 1
    GlobalBlc                      shift and go to state 2

state 1

    (0) S' -> Prog .



state 2

    (1) Prog -> GlobalBlc . MainBlc DefBlcs
    (11) MainBlc -> . main { VarBlcs Insts }

    main            shift and go to state 5

    MainBlc                        shift and go to state 4

state 3

    (7) GlobalBlc -> global . { VarBlcs }

    {               shift and go to state 6


state 4

    (1) Prog -> GlobalBlc MainBlc . DefBlcs
    (2) DefBlcs -> . DefBlcs DefBlc
    (3) DefBlcs -> .

    id              reduce using rule 3 (DefBlcs -> .)
    $end            reduce using rule 3 (DefBlcs -> .)

    DefBlcs                        shift and go to state 7

state 5

    (11) MainBlc -> main . { VarBlcs Insts }

    {               shift and go to state 8


state 6

    (7) GlobalBlc -> global { . VarBlcs }
    (5) VarBlcs -> . VarBlcs BlcInt
    (6) VarBlcs -> .

    }               reduce using rule 6 (VarBlcs -> .)
    int             reduce using rule 6 (VarBlcs -> .)

    VarBlcs                        shift and go to state 9

state 7

    (1) Prog -> GlobalBlc MainBlc DefBlcs .
    (2) DefBlcs -> DefBlcs . DefBlc
    (4) DefBlc -> . id { VarBlcs Insts }

    $end            reduce using rule 1 (Prog -> GlobalBlc MainBlc DefBlcs .)
    id              shift and go to state 11

    DefBlc                         shift and go to state 10

state 8

    (11) MainBlc -> main { . VarBlcs Insts }
    (5) VarBlcs -> . VarBlcs BlcInt
    (6) VarBlcs -> .

    int             reduce using rule 6 (VarBlcs -> .)
    }               reduce using rule 6 (VarBlcs -> .)
    id              reduce using rule 6 (VarBlcs -> .)
    gid             reduce using rule 6 (VarBlcs -> .)
    return          reduce using rule 6 (VarBlcs -> .)
    print           reduce using rule 6 (VarBlcs -> .)
    println         reduce using rule 6 (VarBlcs -> .)
    prints          reduce using rule 6 (VarBlcs -> .)
    for             reduce using rule 6 (VarBlcs -> .)
    while           reduce using rule 6 (VarBlcs -> .)
    read            reduce using rule 6 (VarBlcs -> .)
    if              reduce using rule 6 (VarBlcs -> .)
    repeat          reduce using rule 6 (VarBlcs -> .)
    num             reduce using rule 6 (VarBlcs -> .)
    (               reduce using rule 6 (VarBlcs -> .)

    VarBlcs                        shift and go to state 12

state 9

    (7) GlobalBlc -> global { VarBlcs . }
    (5) VarBlcs -> VarBlcs . BlcInt
    (33) BlcInt -> . int { Dcls }

    }               shift and go to state 13
    int             shift and go to state 15

    BlcInt                         shift and go to state 14

state 10

    (2) DefBlcs -> DefBlcs DefBlc .

    id              reduce using rule 2 (DefBlcs -> DefBlcs DefBlc .)
    $end            reduce using rule 2 (DefBlcs -> DefBlcs DefBlc .)


state 11

    (4) DefBlc -> id . { VarBlcs Insts }

    {               shift and go to state 16


state 12

    (11) MainBlc -> main { VarBlcs . Insts }
    (5) VarBlcs -> VarBlcs . BlcInt
    (12) Insts -> . Insts Inst
    (13) Insts -> .
    (33) BlcInt -> . int { Dcls }

    }               reduce using rule 13 (Insts -> .)
    id              reduce using rule 13 (Insts -> .)
    gid             reduce using rule 13 (Insts -> .)
    return          reduce using rule 13 (Insts -> .)
    print           reduce using rule 13 (Insts -> .)
    println         reduce using rule 13 (Insts -> .)
    prints          reduce using rule 13 (Insts -> .)
    for             reduce using rule 13 (Insts -> .)
    while           reduce using rule 13 (Insts -> .)
    read            reduce using rule 13 (Insts -> .)
    if              reduce using rule 13 (Insts -> .)
    repeat          reduce using rule 13 (Insts -> .)
    num             reduce using rule 13 (Insts -> .)
    (               reduce using rule 13 (Insts -> .)
    int             shift and go to state 15

    Insts                          shift and go to state 17
    BlcInt                         shift and go to state 14

state 13

    (7) GlobalBlc -> global { VarBlcs } .

    main            reduce using rule 7 (GlobalBlc -> global { VarBlcs } .)


state 14

    (5) VarBlcs -> VarBlcs BlcInt .

    }               reduce using rule 5 (VarBlcs -> VarBlcs BlcInt .)
    int             reduce using rule 5 (VarBlcs -> VarBlcs BlcInt .)
    id              reduce using rule 5 (VarBlcs -> VarBlcs BlcInt .)
    gid             reduce using rule 5 (VarBlcs -> VarBlcs BlcInt .)
    return          reduce using rule 5 (VarBlcs -> VarBlcs BlcInt .)
    print           reduce using rule 5 (VarBlcs -> VarBlcs BlcInt .)
    println         reduce using rule 5 (VarBlcs -> VarBlcs BlcInt .)
    prints          reduce using rule 5 (VarBlcs -> VarBlcs BlcInt .)
    for             reduce using rule 5 (VarBlcs -> VarBlcs BlcInt .)
    while           reduce using rule 5 (VarBlcs -> VarBlcs BlcInt .)
    read            reduce using rule 5 (VarBlcs -> VarBlcs BlcInt .)
    if              reduce using rule 5 (VarBlcs -> VarBlcs BlcInt .)
    repeat          reduce using rule 5 (VarBlcs -> VarBlcs BlcInt .)
    num             reduce using rule 5 (VarBlcs -> VarBlcs BlcInt .)
    (               reduce using rule 5 (VarBlcs -> VarBlcs BlcInt .)


state 15

    (33) BlcInt -> int . { Dcls }

    {               shift and go to state 18


state 16

    (4) DefBlc -> id { . VarBlcs Insts }
    (5) VarBlcs -> . VarBlcs BlcInt
    (6) VarBlcs -> .

    int             reduce using rule 6 (VarBlcs -> .)
    }               reduce using rule 6 (VarBlcs -> .)
    id              reduce using rule 6 (VarBlcs -> .)
    gid             reduce using rule 6 (VarBlcs -> .)
    return          reduce using rule 6 (VarBlcs -> .)
    print           reduce using rule 6 (VarBlcs -> .)
    println         reduce using rule 6 (VarBlcs -> .)
    prints          reduce using rule 6 (VarBlcs -> .)
    for             reduce using rule 6 (VarBlcs -> .)
    while           reduce using rule 6 (VarBlcs -> .)
    read            reduce using rule 6 (VarBlcs -> .)
    if              reduce using rule 6 (VarBlcs -> .)
    repeat          reduce using rule 6 (VarBlcs -> .)
    num             reduce using rule 6 (VarBlcs -> .)
    (               reduce using rule 6 (VarBlcs -> .)

    VarBlcs                        shift and go to state 19

state 17

    (11) MainBlc -> main { VarBlcs Insts . }
    (12) Insts -> Insts . Inst
    (14) Inst -> . Attr
    (15) Inst -> . Return
    (16) Inst -> . Exp
    (17) Inst -> . Print
    (18) Inst -> . Println
    (19) Inst -> . Prints
    (20) Inst -> . Repeat
    (21) Inst -> . For
    (22) Inst -> . While
    (23) Inst -> . Read
    (24) Inst -> . If
    (38) Attr -> . id = Exp
    (39) Attr -> . id [ Exp ] = Exp
    (40) Attr -> . id [ Exp ] [ Exp ] = Exp
    (41) Attr -> . gid = Exp
    (42) Attr -> . gid [ Exp ] = Exp
    (43) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (44) Return -> . return ( Exp )
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (30) Print -> . print ( Exp )
    (31) Println -> . println ( Exp )
    (32) Prints -> . prints ( string )
    (25) Repeat -> . RepeatS ( num ) { Insts }
    (27) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (28) While -> . while ( Cond ) { Insts }
    (29) Read -> . read ( id )
    (45) If -> . if ( Cond ) { Insts }
    (46) If -> . if ( Cond ) Inst
    (47) If -> . if ( Cond ) { Insts } else { Insts }
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (26) RepeatS -> . repeat
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    }               shift and go to state 20
    id              shift and go to state 33
    gid             shift and go to state 34
    return          shift and go to state 35
    print           shift and go to state 38
    println         shift and go to state 39
    prints          shift and go to state 40
    for             shift and go to state 43
    while           shift and go to state 44
    read            shift and go to state 45
    if              shift and go to state 46
    repeat          shift and go to state 48
    num             shift and go to state 42
    (               shift and go to state 36

    Inst                           shift and go to state 21
    Attr                           shift and go to state 22
    Return                         shift and go to state 23
    Exp                            shift and go to state 24
    Print                          shift and go to state 25
    Println                        shift and go to state 26
    Prints                         shift and go to state 27
    Repeat                         shift and go to state 28
    For                            shift and go to state 29
    While                          shift and go to state 30
    Read                           shift and go to state 31
    If                             shift and go to state 32
    Term                           shift and go to state 37
    RepeatS                        shift and go to state 41
    Factor                         shift and go to state 47

state 18

    (33) BlcInt -> int { . Dcls }
    (9) Dcls -> . Dcls Dcl
    (10) Dcls -> .

    }               reduce using rule 10 (Dcls -> .)
    id              reduce using rule 10 (Dcls -> .)

    Dcls                           shift and go to state 49

state 19

    (4) DefBlc -> id { VarBlcs . Insts }
    (5) VarBlcs -> VarBlcs . BlcInt
    (12) Insts -> . Insts Inst
    (13) Insts -> .
    (33) BlcInt -> . int { Dcls }

    }               reduce using rule 13 (Insts -> .)
    id              reduce using rule 13 (Insts -> .)
    gid             reduce using rule 13 (Insts -> .)
    return          reduce using rule 13 (Insts -> .)
    print           reduce using rule 13 (Insts -> .)
    println         reduce using rule 13 (Insts -> .)
    prints          reduce using rule 13 (Insts -> .)
    for             reduce using rule 13 (Insts -> .)
    while           reduce using rule 13 (Insts -> .)
    read            reduce using rule 13 (Insts -> .)
    if              reduce using rule 13 (Insts -> .)
    repeat          reduce using rule 13 (Insts -> .)
    num             reduce using rule 13 (Insts -> .)
    (               reduce using rule 13 (Insts -> .)
    int             shift and go to state 15

    Insts                          shift and go to state 50
    BlcInt                         shift and go to state 14

state 20

    (11) MainBlc -> main { VarBlcs Insts } .

    id              reduce using rule 11 (MainBlc -> main { VarBlcs Insts } .)
    $end            reduce using rule 11 (MainBlc -> main { VarBlcs Insts } .)


state 21

    (12) Insts -> Insts Inst .

    }               reduce using rule 12 (Insts -> Insts Inst .)
    id              reduce using rule 12 (Insts -> Insts Inst .)
    gid             reduce using rule 12 (Insts -> Insts Inst .)
    return          reduce using rule 12 (Insts -> Insts Inst .)
    print           reduce using rule 12 (Insts -> Insts Inst .)
    println         reduce using rule 12 (Insts -> Insts Inst .)
    prints          reduce using rule 12 (Insts -> Insts Inst .)
    for             reduce using rule 12 (Insts -> Insts Inst .)
    while           reduce using rule 12 (Insts -> Insts Inst .)
    read            reduce using rule 12 (Insts -> Insts Inst .)
    if              reduce using rule 12 (Insts -> Insts Inst .)
    repeat          reduce using rule 12 (Insts -> Insts Inst .)
    num             reduce using rule 12 (Insts -> Insts Inst .)
    (               reduce using rule 12 (Insts -> Insts Inst .)
    ;               reduce using rule 12 (Insts -> Insts Inst .)
    )               reduce using rule 12 (Insts -> Insts Inst .)


state 22

    (14) Inst -> Attr .

    }               reduce using rule 14 (Inst -> Attr .)
    id              reduce using rule 14 (Inst -> Attr .)
    gid             reduce using rule 14 (Inst -> Attr .)
    return          reduce using rule 14 (Inst -> Attr .)
    print           reduce using rule 14 (Inst -> Attr .)
    println         reduce using rule 14 (Inst -> Attr .)
    prints          reduce using rule 14 (Inst -> Attr .)
    for             reduce using rule 14 (Inst -> Attr .)
    while           reduce using rule 14 (Inst -> Attr .)
    read            reduce using rule 14 (Inst -> Attr .)
    if              reduce using rule 14 (Inst -> Attr .)
    repeat          reduce using rule 14 (Inst -> Attr .)
    num             reduce using rule 14 (Inst -> Attr .)
    (               reduce using rule 14 (Inst -> Attr .)
    ;               reduce using rule 14 (Inst -> Attr .)
    )               reduce using rule 14 (Inst -> Attr .)


state 23

    (15) Inst -> Return .

    }               reduce using rule 15 (Inst -> Return .)
    id              reduce using rule 15 (Inst -> Return .)
    gid             reduce using rule 15 (Inst -> Return .)
    return          reduce using rule 15 (Inst -> Return .)
    print           reduce using rule 15 (Inst -> Return .)
    println         reduce using rule 15 (Inst -> Return .)
    prints          reduce using rule 15 (Inst -> Return .)
    for             reduce using rule 15 (Inst -> Return .)
    while           reduce using rule 15 (Inst -> Return .)
    read            reduce using rule 15 (Inst -> Return .)
    if              reduce using rule 15 (Inst -> Return .)
    repeat          reduce using rule 15 (Inst -> Return .)
    num             reduce using rule 15 (Inst -> Return .)
    (               reduce using rule 15 (Inst -> Return .)
    ;               reduce using rule 15 (Inst -> Return .)
    )               reduce using rule 15 (Inst -> Return .)


state 24

    (16) Inst -> Exp .
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    }               reduce using rule 16 (Inst -> Exp .)
    id              reduce using rule 16 (Inst -> Exp .)
    gid             reduce using rule 16 (Inst -> Exp .)
    return          reduce using rule 16 (Inst -> Exp .)
    print           reduce using rule 16 (Inst -> Exp .)
    println         reduce using rule 16 (Inst -> Exp .)
    prints          reduce using rule 16 (Inst -> Exp .)
    for             reduce using rule 16 (Inst -> Exp .)
    while           reduce using rule 16 (Inst -> Exp .)
    read            reduce using rule 16 (Inst -> Exp .)
    if              reduce using rule 16 (Inst -> Exp .)
    repeat          reduce using rule 16 (Inst -> Exp .)
    num             reduce using rule 16 (Inst -> Exp .)
    (               reduce using rule 16 (Inst -> Exp .)
    ;               reduce using rule 16 (Inst -> Exp .)
    )               reduce using rule 16 (Inst -> Exp .)
    +               shift and go to state 51
    -               shift and go to state 52


state 25

    (17) Inst -> Print .

    }               reduce using rule 17 (Inst -> Print .)
    id              reduce using rule 17 (Inst -> Print .)
    gid             reduce using rule 17 (Inst -> Print .)
    return          reduce using rule 17 (Inst -> Print .)
    print           reduce using rule 17 (Inst -> Print .)
    println         reduce using rule 17 (Inst -> Print .)
    prints          reduce using rule 17 (Inst -> Print .)
    for             reduce using rule 17 (Inst -> Print .)
    while           reduce using rule 17 (Inst -> Print .)
    read            reduce using rule 17 (Inst -> Print .)
    if              reduce using rule 17 (Inst -> Print .)
    repeat          reduce using rule 17 (Inst -> Print .)
    num             reduce using rule 17 (Inst -> Print .)
    (               reduce using rule 17 (Inst -> Print .)
    ;               reduce using rule 17 (Inst -> Print .)
    )               reduce using rule 17 (Inst -> Print .)


state 26

    (18) Inst -> Println .

    }               reduce using rule 18 (Inst -> Println .)
    id              reduce using rule 18 (Inst -> Println .)
    gid             reduce using rule 18 (Inst -> Println .)
    return          reduce using rule 18 (Inst -> Println .)
    print           reduce using rule 18 (Inst -> Println .)
    println         reduce using rule 18 (Inst -> Println .)
    prints          reduce using rule 18 (Inst -> Println .)
    for             reduce using rule 18 (Inst -> Println .)
    while           reduce using rule 18 (Inst -> Println .)
    read            reduce using rule 18 (Inst -> Println .)
    if              reduce using rule 18 (Inst -> Println .)
    repeat          reduce using rule 18 (Inst -> Println .)
    num             reduce using rule 18 (Inst -> Println .)
    (               reduce using rule 18 (Inst -> Println .)
    ;               reduce using rule 18 (Inst -> Println .)
    )               reduce using rule 18 (Inst -> Println .)


state 27

    (19) Inst -> Prints .

    }               reduce using rule 19 (Inst -> Prints .)
    id              reduce using rule 19 (Inst -> Prints .)
    gid             reduce using rule 19 (Inst -> Prints .)
    return          reduce using rule 19 (Inst -> Prints .)
    print           reduce using rule 19 (Inst -> Prints .)
    println         reduce using rule 19 (Inst -> Prints .)
    prints          reduce using rule 19 (Inst -> Prints .)
    for             reduce using rule 19 (Inst -> Prints .)
    while           reduce using rule 19 (Inst -> Prints .)
    read            reduce using rule 19 (Inst -> Prints .)
    if              reduce using rule 19 (Inst -> Prints .)
    repeat          reduce using rule 19 (Inst -> Prints .)
    num             reduce using rule 19 (Inst -> Prints .)
    (               reduce using rule 19 (Inst -> Prints .)
    ;               reduce using rule 19 (Inst -> Prints .)
    )               reduce using rule 19 (Inst -> Prints .)


state 28

    (20) Inst -> Repeat .

    }               reduce using rule 20 (Inst -> Repeat .)
    id              reduce using rule 20 (Inst -> Repeat .)
    gid             reduce using rule 20 (Inst -> Repeat .)
    return          reduce using rule 20 (Inst -> Repeat .)
    print           reduce using rule 20 (Inst -> Repeat .)
    println         reduce using rule 20 (Inst -> Repeat .)
    prints          reduce using rule 20 (Inst -> Repeat .)
    for             reduce using rule 20 (Inst -> Repeat .)
    while           reduce using rule 20 (Inst -> Repeat .)
    read            reduce using rule 20 (Inst -> Repeat .)
    if              reduce using rule 20 (Inst -> Repeat .)
    repeat          reduce using rule 20 (Inst -> Repeat .)
    num             reduce using rule 20 (Inst -> Repeat .)
    (               reduce using rule 20 (Inst -> Repeat .)
    ;               reduce using rule 20 (Inst -> Repeat .)
    )               reduce using rule 20 (Inst -> Repeat .)


state 29

    (21) Inst -> For .

    }               reduce using rule 21 (Inst -> For .)
    id              reduce using rule 21 (Inst -> For .)
    gid             reduce using rule 21 (Inst -> For .)
    return          reduce using rule 21 (Inst -> For .)
    print           reduce using rule 21 (Inst -> For .)
    println         reduce using rule 21 (Inst -> For .)
    prints          reduce using rule 21 (Inst -> For .)
    for             reduce using rule 21 (Inst -> For .)
    while           reduce using rule 21 (Inst -> For .)
    read            reduce using rule 21 (Inst -> For .)
    if              reduce using rule 21 (Inst -> For .)
    repeat          reduce using rule 21 (Inst -> For .)
    num             reduce using rule 21 (Inst -> For .)
    (               reduce using rule 21 (Inst -> For .)
    ;               reduce using rule 21 (Inst -> For .)
    )               reduce using rule 21 (Inst -> For .)


state 30

    (22) Inst -> While .

    }               reduce using rule 22 (Inst -> While .)
    id              reduce using rule 22 (Inst -> While .)
    gid             reduce using rule 22 (Inst -> While .)
    return          reduce using rule 22 (Inst -> While .)
    print           reduce using rule 22 (Inst -> While .)
    println         reduce using rule 22 (Inst -> While .)
    prints          reduce using rule 22 (Inst -> While .)
    for             reduce using rule 22 (Inst -> While .)
    while           reduce using rule 22 (Inst -> While .)
    read            reduce using rule 22 (Inst -> While .)
    if              reduce using rule 22 (Inst -> While .)
    repeat          reduce using rule 22 (Inst -> While .)
    num             reduce using rule 22 (Inst -> While .)
    (               reduce using rule 22 (Inst -> While .)
    ;               reduce using rule 22 (Inst -> While .)
    )               reduce using rule 22 (Inst -> While .)


state 31

    (23) Inst -> Read .

    }               reduce using rule 23 (Inst -> Read .)
    id              reduce using rule 23 (Inst -> Read .)
    gid             reduce using rule 23 (Inst -> Read .)
    return          reduce using rule 23 (Inst -> Read .)
    print           reduce using rule 23 (Inst -> Read .)
    println         reduce using rule 23 (Inst -> Read .)
    prints          reduce using rule 23 (Inst -> Read .)
    for             reduce using rule 23 (Inst -> Read .)
    while           reduce using rule 23 (Inst -> Read .)
    read            reduce using rule 23 (Inst -> Read .)
    if              reduce using rule 23 (Inst -> Read .)
    repeat          reduce using rule 23 (Inst -> Read .)
    num             reduce using rule 23 (Inst -> Read .)
    (               reduce using rule 23 (Inst -> Read .)
    ;               reduce using rule 23 (Inst -> Read .)
    )               reduce using rule 23 (Inst -> Read .)


state 32

    (24) Inst -> If .

    }               reduce using rule 24 (Inst -> If .)
    id              reduce using rule 24 (Inst -> If .)
    gid             reduce using rule 24 (Inst -> If .)
    return          reduce using rule 24 (Inst -> If .)
    print           reduce using rule 24 (Inst -> If .)
    println         reduce using rule 24 (Inst -> If .)
    prints          reduce using rule 24 (Inst -> If .)
    for             reduce using rule 24 (Inst -> If .)
    while           reduce using rule 24 (Inst -> If .)
    read            reduce using rule 24 (Inst -> If .)
    if              reduce using rule 24 (Inst -> If .)
    repeat          reduce using rule 24 (Inst -> If .)
    num             reduce using rule 24 (Inst -> If .)
    (               reduce using rule 24 (Inst -> If .)
    ;               reduce using rule 24 (Inst -> If .)
    )               reduce using rule 24 (Inst -> If .)


state 33

    (38) Attr -> id . = Exp
    (39) Attr -> id . [ Exp ] = Exp
    (40) Attr -> id . [ Exp ] [ Exp ] = Exp
    (50) Exp -> id . addeq Term
    (51) Exp -> id . subeq Term
    (52) Exp -> id . addeql Term
    (53) Exp -> id . subeql Term
    (58) Term -> id . muleq Factor
    (59) Term -> id . diveq Factor
    (60) Term -> id . modeq Factor
    (61) Term -> id . muleql Factor
    (62) Term -> id . diveql Factor
    (63) Term -> id . modeql Factor
    (65) Factor -> id . plus
    (66) Factor -> id . plusl
    (67) Factor -> id . minus
    (68) Factor -> id . minusl
    (69) Factor -> id .
    (72) Factor -> id . ( )
    (74) Factor -> id . [ Exp ]
    (75) Factor -> id . [ Exp ] [ Exp ]

  ! shift/reduce conflict for ( resolved as shift
    =               shift and go to state 53
    [               shift and go to state 54
    addeq           shift and go to state 55
    subeq           shift and go to state 56
    addeql          shift and go to state 57
    subeql          shift and go to state 58
    muleq           shift and go to state 59
    diveq           shift and go to state 60
    modeq           shift and go to state 61
    muleql          shift and go to state 62
    diveql          shift and go to state 63
    modeql          shift and go to state 64
    plus            shift and go to state 65
    plusl           shift and go to state 66
    minus           shift and go to state 67
    minusl          shift and go to state 68
    *               reduce using rule 69 (Factor -> id .)
    /               reduce using rule 69 (Factor -> id .)
    %               reduce using rule 69 (Factor -> id .)
    +               reduce using rule 69 (Factor -> id .)
    -               reduce using rule 69 (Factor -> id .)
    }               reduce using rule 69 (Factor -> id .)
    id              reduce using rule 69 (Factor -> id .)
    gid             reduce using rule 69 (Factor -> id .)
    return          reduce using rule 69 (Factor -> id .)
    print           reduce using rule 69 (Factor -> id .)
    println         reduce using rule 69 (Factor -> id .)
    prints          reduce using rule 69 (Factor -> id .)
    for             reduce using rule 69 (Factor -> id .)
    while           reduce using rule 69 (Factor -> id .)
    read            reduce using rule 69 (Factor -> id .)
    if              reduce using rule 69 (Factor -> id .)
    repeat          reduce using rule 69 (Factor -> id .)
    num             reduce using rule 69 (Factor -> id .)
    ;               reduce using rule 69 (Factor -> id .)
    )               reduce using rule 69 (Factor -> id .)
    (               shift and go to state 69

  ! (               [ reduce using rule 69 (Factor -> id .) ]


state 34

    (41) Attr -> gid . = Exp
    (42) Attr -> gid . [ Exp ] = Exp
    (43) Attr -> gid . [ Exp ] [ Exp ] = Exp
    (70) Factor -> gid .
    (76) Factor -> gid . [ Exp ]
    (77) Factor -> gid . [ Exp ] [ Exp ]

    =               shift and go to state 70
    [               shift and go to state 71
    *               reduce using rule 70 (Factor -> gid .)
    /               reduce using rule 70 (Factor -> gid .)
    %               reduce using rule 70 (Factor -> gid .)
    +               reduce using rule 70 (Factor -> gid .)
    -               reduce using rule 70 (Factor -> gid .)
    }               reduce using rule 70 (Factor -> gid .)
    id              reduce using rule 70 (Factor -> gid .)
    gid             reduce using rule 70 (Factor -> gid .)
    return          reduce using rule 70 (Factor -> gid .)
    print           reduce using rule 70 (Factor -> gid .)
    println         reduce using rule 70 (Factor -> gid .)
    prints          reduce using rule 70 (Factor -> gid .)
    for             reduce using rule 70 (Factor -> gid .)
    while           reduce using rule 70 (Factor -> gid .)
    read            reduce using rule 70 (Factor -> gid .)
    if              reduce using rule 70 (Factor -> gid .)
    repeat          reduce using rule 70 (Factor -> gid .)
    num             reduce using rule 70 (Factor -> gid .)
    (               reduce using rule 70 (Factor -> gid .)
    ;               reduce using rule 70 (Factor -> gid .)
    )               reduce using rule 70 (Factor -> gid .)


state 35

    (44) Return -> return . ( Exp )

    (               shift and go to state 72


state 36

    (73) Factor -> ( . Cond )
    (78) Factor -> ( . Exp )
    (79) Cond -> . Cond and Cond
    (80) Cond -> . Cond or Cond
    (81) Cond -> . ( Cond and Cond )
    (82) Cond -> . ( Cond or Cond )
    (83) Cond -> . Exp sup Exp
    (84) Cond -> . Exp inf Exp
    (85) Cond -> . Exp supeq Exp
    (86) Cond -> . Exp infeq Exp
    (87) Cond -> . not Exp
    (88) Cond -> . Exp eq Exp
    (89) Cond -> . Exp diff Exp
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    (               shift and go to state 73
    not             shift and go to state 76
    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42

    Cond                           shift and go to state 74
    Exp                            shift and go to state 75
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 37

    (54) Exp -> Term .
    (55) Term -> Term . * Factor
    (56) Term -> Term . / Factor
    (57) Term -> Term . % Factor

    +               reduce using rule 54 (Exp -> Term .)
    -               reduce using rule 54 (Exp -> Term .)
    }               reduce using rule 54 (Exp -> Term .)
    id              reduce using rule 54 (Exp -> Term .)
    gid             reduce using rule 54 (Exp -> Term .)
    return          reduce using rule 54 (Exp -> Term .)
    print           reduce using rule 54 (Exp -> Term .)
    println         reduce using rule 54 (Exp -> Term .)
    prints          reduce using rule 54 (Exp -> Term .)
    for             reduce using rule 54 (Exp -> Term .)
    while           reduce using rule 54 (Exp -> Term .)
    read            reduce using rule 54 (Exp -> Term .)
    if              reduce using rule 54 (Exp -> Term .)
    repeat          reduce using rule 54 (Exp -> Term .)
    num             reduce using rule 54 (Exp -> Term .)
    (               reduce using rule 54 (Exp -> Term .)
    )               reduce using rule 54 (Exp -> Term .)
    sup             reduce using rule 54 (Exp -> Term .)
    inf             reduce using rule 54 (Exp -> Term .)
    supeq           reduce using rule 54 (Exp -> Term .)
    infeq           reduce using rule 54 (Exp -> Term .)
    eq              reduce using rule 54 (Exp -> Term .)
    diff            reduce using rule 54 (Exp -> Term .)
    ;               reduce using rule 54 (Exp -> Term .)
    ]               reduce using rule 54 (Exp -> Term .)
    and             reduce using rule 54 (Exp -> Term .)
    or              reduce using rule 54 (Exp -> Term .)
    *               shift and go to state 79
    /               shift and go to state 80
    %               shift and go to state 81


state 38

    (30) Print -> print . ( Exp )

    (               shift and go to state 82


state 39

    (31) Println -> println . ( Exp )

    (               shift and go to state 83


state 40

    (32) Prints -> prints . ( string )

    (               shift and go to state 84


state 41

    (25) Repeat -> RepeatS . ( num ) { Insts }

    (               shift and go to state 85


state 42

    (71) Factor -> num .

    *               reduce using rule 71 (Factor -> num .)
    /               reduce using rule 71 (Factor -> num .)
    %               reduce using rule 71 (Factor -> num .)
    +               reduce using rule 71 (Factor -> num .)
    -               reduce using rule 71 (Factor -> num .)
    }               reduce using rule 71 (Factor -> num .)
    id              reduce using rule 71 (Factor -> num .)
    gid             reduce using rule 71 (Factor -> num .)
    return          reduce using rule 71 (Factor -> num .)
    print           reduce using rule 71 (Factor -> num .)
    println         reduce using rule 71 (Factor -> num .)
    prints          reduce using rule 71 (Factor -> num .)
    for             reduce using rule 71 (Factor -> num .)
    while           reduce using rule 71 (Factor -> num .)
    read            reduce using rule 71 (Factor -> num .)
    if              reduce using rule 71 (Factor -> num .)
    repeat          reduce using rule 71 (Factor -> num .)
    num             reduce using rule 71 (Factor -> num .)
    (               reduce using rule 71 (Factor -> num .)
    )               reduce using rule 71 (Factor -> num .)
    sup             reduce using rule 71 (Factor -> num .)
    inf             reduce using rule 71 (Factor -> num .)
    supeq           reduce using rule 71 (Factor -> num .)
    infeq           reduce using rule 71 (Factor -> num .)
    eq              reduce using rule 71 (Factor -> num .)
    diff            reduce using rule 71 (Factor -> num .)
    ;               reduce using rule 71 (Factor -> num .)
    ]               reduce using rule 71 (Factor -> num .)
    and             reduce using rule 71 (Factor -> num .)
    or              reduce using rule 71 (Factor -> num .)


state 43

    (27) For -> for . ( Insts ; Cond ; Insts ) { Insts }

    (               shift and go to state 86


state 44

    (28) While -> while . ( Cond ) { Insts }

    (               shift and go to state 87


state 45

    (29) Read -> read . ( id )

    (               shift and go to state 88


state 46

    (45) If -> if . ( Cond ) { Insts }
    (46) If -> if . ( Cond ) Inst
    (47) If -> if . ( Cond ) { Insts } else { Insts }

    (               shift and go to state 89


state 47

    (64) Term -> Factor .

    *               reduce using rule 64 (Term -> Factor .)
    /               reduce using rule 64 (Term -> Factor .)
    %               reduce using rule 64 (Term -> Factor .)
    +               reduce using rule 64 (Term -> Factor .)
    -               reduce using rule 64 (Term -> Factor .)
    }               reduce using rule 64 (Term -> Factor .)
    id              reduce using rule 64 (Term -> Factor .)
    gid             reduce using rule 64 (Term -> Factor .)
    return          reduce using rule 64 (Term -> Factor .)
    print           reduce using rule 64 (Term -> Factor .)
    println         reduce using rule 64 (Term -> Factor .)
    prints          reduce using rule 64 (Term -> Factor .)
    for             reduce using rule 64 (Term -> Factor .)
    while           reduce using rule 64 (Term -> Factor .)
    read            reduce using rule 64 (Term -> Factor .)
    if              reduce using rule 64 (Term -> Factor .)
    repeat          reduce using rule 64 (Term -> Factor .)
    num             reduce using rule 64 (Term -> Factor .)
    (               reduce using rule 64 (Term -> Factor .)
    )               reduce using rule 64 (Term -> Factor .)
    sup             reduce using rule 64 (Term -> Factor .)
    inf             reduce using rule 64 (Term -> Factor .)
    supeq           reduce using rule 64 (Term -> Factor .)
    infeq           reduce using rule 64 (Term -> Factor .)
    eq              reduce using rule 64 (Term -> Factor .)
    diff            reduce using rule 64 (Term -> Factor .)
    ;               reduce using rule 64 (Term -> Factor .)
    ]               reduce using rule 64 (Term -> Factor .)
    and             reduce using rule 64 (Term -> Factor .)
    or              reduce using rule 64 (Term -> Factor .)


state 48

    (26) RepeatS -> repeat .

    (               reduce using rule 26 (RepeatS -> repeat .)


state 49

    (33) BlcInt -> int { Dcls . }
    (9) Dcls -> Dcls . Dcl
    (34) Dcl -> . id [ num ]
    (35) Dcl -> . id [ num ] [ num ]
    (36) Dcl -> . id
    (37) Dcl -> . id = num

    }               shift and go to state 90
    id              shift and go to state 92

    Dcl                            shift and go to state 91

state 50

    (4) DefBlc -> id { VarBlcs Insts . }
    (12) Insts -> Insts . Inst
    (14) Inst -> . Attr
    (15) Inst -> . Return
    (16) Inst -> . Exp
    (17) Inst -> . Print
    (18) Inst -> . Println
    (19) Inst -> . Prints
    (20) Inst -> . Repeat
    (21) Inst -> . For
    (22) Inst -> . While
    (23) Inst -> . Read
    (24) Inst -> . If
    (38) Attr -> . id = Exp
    (39) Attr -> . id [ Exp ] = Exp
    (40) Attr -> . id [ Exp ] [ Exp ] = Exp
    (41) Attr -> . gid = Exp
    (42) Attr -> . gid [ Exp ] = Exp
    (43) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (44) Return -> . return ( Exp )
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (30) Print -> . print ( Exp )
    (31) Println -> . println ( Exp )
    (32) Prints -> . prints ( string )
    (25) Repeat -> . RepeatS ( num ) { Insts }
    (27) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (28) While -> . while ( Cond ) { Insts }
    (29) Read -> . read ( id )
    (45) If -> . if ( Cond ) { Insts }
    (46) If -> . if ( Cond ) Inst
    (47) If -> . if ( Cond ) { Insts } else { Insts }
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (26) RepeatS -> . repeat
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    }               shift and go to state 93
    id              shift and go to state 33
    gid             shift and go to state 34
    return          shift and go to state 35
    print           shift and go to state 38
    println         shift and go to state 39
    prints          shift and go to state 40
    for             shift and go to state 43
    while           shift and go to state 44
    read            shift and go to state 45
    if              shift and go to state 46
    repeat          shift and go to state 48
    num             shift and go to state 42
    (               shift and go to state 36

    Inst                           shift and go to state 21
    Attr                           shift and go to state 22
    Return                         shift and go to state 23
    Exp                            shift and go to state 24
    Print                          shift and go to state 25
    Println                        shift and go to state 26
    Prints                         shift and go to state 27
    Repeat                         shift and go to state 28
    For                            shift and go to state 29
    While                          shift and go to state 30
    Read                           shift and go to state 31
    If                             shift and go to state 32
    Term                           shift and go to state 37
    RepeatS                        shift and go to state 41
    Factor                         shift and go to state 47

state 51

    (48) Exp -> Exp + . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 95
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Term                           shift and go to state 94
    Factor                         shift and go to state 47

state 52

    (49) Exp -> Exp - . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 95
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Term                           shift and go to state 96
    Factor                         shift and go to state 47

state 53

    (38) Attr -> id = . Exp
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 97
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 54

    (39) Attr -> id [ . Exp ] = Exp
    (40) Attr -> id [ . Exp ] [ Exp ] = Exp
    (74) Factor -> id [ . Exp ]
    (75) Factor -> id [ . Exp ] [ Exp ]
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 98
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 55

    (50) Exp -> id addeq . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 95
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Term                           shift and go to state 99
    Factor                         shift and go to state 47

state 56

    (51) Exp -> id subeq . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 95
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Term                           shift and go to state 100
    Factor                         shift and go to state 47

state 57

    (52) Exp -> id addeql . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 95
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Term                           shift and go to state 101
    Factor                         shift and go to state 47

state 58

    (53) Exp -> id subeql . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 95
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Term                           shift and go to state 102
    Factor                         shift and go to state 47

state 59

    (58) Term -> id muleq . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 103
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Factor                         shift and go to state 104

state 60

    (59) Term -> id diveq . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 103
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Factor                         shift and go to state 105

state 61

    (60) Term -> id modeq . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 103
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Factor                         shift and go to state 106

state 62

    (61) Term -> id muleql . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 103
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Factor                         shift and go to state 107

state 63

    (62) Term -> id diveql . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 103
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Factor                         shift and go to state 108

state 64

    (63) Term -> id modeql . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 103
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Factor                         shift and go to state 109

state 65

    (65) Factor -> id plus .

    *               reduce using rule 65 (Factor -> id plus .)
    /               reduce using rule 65 (Factor -> id plus .)
    %               reduce using rule 65 (Factor -> id plus .)
    +               reduce using rule 65 (Factor -> id plus .)
    -               reduce using rule 65 (Factor -> id plus .)
    }               reduce using rule 65 (Factor -> id plus .)
    id              reduce using rule 65 (Factor -> id plus .)
    gid             reduce using rule 65 (Factor -> id plus .)
    return          reduce using rule 65 (Factor -> id plus .)
    print           reduce using rule 65 (Factor -> id plus .)
    println         reduce using rule 65 (Factor -> id plus .)
    prints          reduce using rule 65 (Factor -> id plus .)
    for             reduce using rule 65 (Factor -> id plus .)
    while           reduce using rule 65 (Factor -> id plus .)
    read            reduce using rule 65 (Factor -> id plus .)
    if              reduce using rule 65 (Factor -> id plus .)
    repeat          reduce using rule 65 (Factor -> id plus .)
    num             reduce using rule 65 (Factor -> id plus .)
    (               reduce using rule 65 (Factor -> id plus .)
    )               reduce using rule 65 (Factor -> id plus .)
    sup             reduce using rule 65 (Factor -> id plus .)
    inf             reduce using rule 65 (Factor -> id plus .)
    supeq           reduce using rule 65 (Factor -> id plus .)
    infeq           reduce using rule 65 (Factor -> id plus .)
    eq              reduce using rule 65 (Factor -> id plus .)
    diff            reduce using rule 65 (Factor -> id plus .)
    ;               reduce using rule 65 (Factor -> id plus .)
    ]               reduce using rule 65 (Factor -> id plus .)
    and             reduce using rule 65 (Factor -> id plus .)
    or              reduce using rule 65 (Factor -> id plus .)


state 66

    (66) Factor -> id plusl .

    *               reduce using rule 66 (Factor -> id plusl .)
    /               reduce using rule 66 (Factor -> id plusl .)
    %               reduce using rule 66 (Factor -> id plusl .)
    +               reduce using rule 66 (Factor -> id plusl .)
    -               reduce using rule 66 (Factor -> id plusl .)
    }               reduce using rule 66 (Factor -> id plusl .)
    id              reduce using rule 66 (Factor -> id plusl .)
    gid             reduce using rule 66 (Factor -> id plusl .)
    return          reduce using rule 66 (Factor -> id plusl .)
    print           reduce using rule 66 (Factor -> id plusl .)
    println         reduce using rule 66 (Factor -> id plusl .)
    prints          reduce using rule 66 (Factor -> id plusl .)
    for             reduce using rule 66 (Factor -> id plusl .)
    while           reduce using rule 66 (Factor -> id plusl .)
    read            reduce using rule 66 (Factor -> id plusl .)
    if              reduce using rule 66 (Factor -> id plusl .)
    repeat          reduce using rule 66 (Factor -> id plusl .)
    num             reduce using rule 66 (Factor -> id plusl .)
    (               reduce using rule 66 (Factor -> id plusl .)
    )               reduce using rule 66 (Factor -> id plusl .)
    sup             reduce using rule 66 (Factor -> id plusl .)
    inf             reduce using rule 66 (Factor -> id plusl .)
    supeq           reduce using rule 66 (Factor -> id plusl .)
    infeq           reduce using rule 66 (Factor -> id plusl .)
    eq              reduce using rule 66 (Factor -> id plusl .)
    diff            reduce using rule 66 (Factor -> id plusl .)
    ;               reduce using rule 66 (Factor -> id plusl .)
    ]               reduce using rule 66 (Factor -> id plusl .)
    and             reduce using rule 66 (Factor -> id plusl .)
    or              reduce using rule 66 (Factor -> id plusl .)


state 67

    (67) Factor -> id minus .

    *               reduce using rule 67 (Factor -> id minus .)
    /               reduce using rule 67 (Factor -> id minus .)
    %               reduce using rule 67 (Factor -> id minus .)
    +               reduce using rule 67 (Factor -> id minus .)
    -               reduce using rule 67 (Factor -> id minus .)
    }               reduce using rule 67 (Factor -> id minus .)
    id              reduce using rule 67 (Factor -> id minus .)
    gid             reduce using rule 67 (Factor -> id minus .)
    return          reduce using rule 67 (Factor -> id minus .)
    print           reduce using rule 67 (Factor -> id minus .)
    println         reduce using rule 67 (Factor -> id minus .)
    prints          reduce using rule 67 (Factor -> id minus .)
    for             reduce using rule 67 (Factor -> id minus .)
    while           reduce using rule 67 (Factor -> id minus .)
    read            reduce using rule 67 (Factor -> id minus .)
    if              reduce using rule 67 (Factor -> id minus .)
    repeat          reduce using rule 67 (Factor -> id minus .)
    num             reduce using rule 67 (Factor -> id minus .)
    (               reduce using rule 67 (Factor -> id minus .)
    )               reduce using rule 67 (Factor -> id minus .)
    sup             reduce using rule 67 (Factor -> id minus .)
    inf             reduce using rule 67 (Factor -> id minus .)
    supeq           reduce using rule 67 (Factor -> id minus .)
    infeq           reduce using rule 67 (Factor -> id minus .)
    eq              reduce using rule 67 (Factor -> id minus .)
    diff            reduce using rule 67 (Factor -> id minus .)
    ;               reduce using rule 67 (Factor -> id minus .)
    ]               reduce using rule 67 (Factor -> id minus .)
    and             reduce using rule 67 (Factor -> id minus .)
    or              reduce using rule 67 (Factor -> id minus .)


state 68

    (68) Factor -> id minusl .

    *               reduce using rule 68 (Factor -> id minusl .)
    /               reduce using rule 68 (Factor -> id minusl .)
    %               reduce using rule 68 (Factor -> id minusl .)
    +               reduce using rule 68 (Factor -> id minusl .)
    -               reduce using rule 68 (Factor -> id minusl .)
    }               reduce using rule 68 (Factor -> id minusl .)
    id              reduce using rule 68 (Factor -> id minusl .)
    gid             reduce using rule 68 (Factor -> id minusl .)
    return          reduce using rule 68 (Factor -> id minusl .)
    print           reduce using rule 68 (Factor -> id minusl .)
    println         reduce using rule 68 (Factor -> id minusl .)
    prints          reduce using rule 68 (Factor -> id minusl .)
    for             reduce using rule 68 (Factor -> id minusl .)
    while           reduce using rule 68 (Factor -> id minusl .)
    read            reduce using rule 68 (Factor -> id minusl .)
    if              reduce using rule 68 (Factor -> id minusl .)
    repeat          reduce using rule 68 (Factor -> id minusl .)
    num             reduce using rule 68 (Factor -> id minusl .)
    (               reduce using rule 68 (Factor -> id minusl .)
    )               reduce using rule 68 (Factor -> id minusl .)
    sup             reduce using rule 68 (Factor -> id minusl .)
    inf             reduce using rule 68 (Factor -> id minusl .)
    supeq           reduce using rule 68 (Factor -> id minusl .)
    infeq           reduce using rule 68 (Factor -> id minusl .)
    eq              reduce using rule 68 (Factor -> id minusl .)
    diff            reduce using rule 68 (Factor -> id minusl .)
    ;               reduce using rule 68 (Factor -> id minusl .)
    ]               reduce using rule 68 (Factor -> id minusl .)
    and             reduce using rule 68 (Factor -> id minusl .)
    or              reduce using rule 68 (Factor -> id minusl .)


state 69

    (72) Factor -> id ( . )

    )               shift and go to state 110


state 70

    (41) Attr -> gid = . Exp
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 111
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 71

    (42) Attr -> gid [ . Exp ] = Exp
    (43) Attr -> gid [ . Exp ] [ Exp ] = Exp
    (76) Factor -> gid [ . Exp ]
    (77) Factor -> gid [ . Exp ] [ Exp ]
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 112
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 72

    (44) Return -> return ( . Exp )
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 113
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 73

    (81) Cond -> ( . Cond and Cond )
    (82) Cond -> ( . Cond or Cond )
    (73) Factor -> ( . Cond )
    (78) Factor -> ( . Exp )
    (79) Cond -> . Cond and Cond
    (80) Cond -> . Cond or Cond
    (81) Cond -> . ( Cond and Cond )
    (82) Cond -> . ( Cond or Cond )
    (83) Cond -> . Exp sup Exp
    (84) Cond -> . Exp inf Exp
    (85) Cond -> . Exp supeq Exp
    (86) Cond -> . Exp infeq Exp
    (87) Cond -> . not Exp
    (88) Cond -> . Exp eq Exp
    (89) Cond -> . Exp diff Exp
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    (               shift and go to state 73
    not             shift and go to state 76
    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42

    Cond                           shift and go to state 114
    Exp                            shift and go to state 75
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 74

    (73) Factor -> ( Cond . )
    (79) Cond -> Cond . and Cond
    (80) Cond -> Cond . or Cond

    )               shift and go to state 115
    and             shift and go to state 116
    or              shift and go to state 117


state 75

    (78) Factor -> ( Exp . )
    (83) Cond -> Exp . sup Exp
    (84) Cond -> Exp . inf Exp
    (85) Cond -> Exp . supeq Exp
    (86) Cond -> Exp . infeq Exp
    (88) Cond -> Exp . eq Exp
    (89) Cond -> Exp . diff Exp
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    )               shift and go to state 118
    sup             shift and go to state 119
    inf             shift and go to state 120
    supeq           shift and go to state 121
    infeq           shift and go to state 122
    eq              shift and go to state 123
    diff            shift and go to state 124
    +               shift and go to state 51
    -               shift and go to state 52


state 76

    (87) Cond -> not . Exp
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 125
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 77

    (50) Exp -> id . addeq Term
    (51) Exp -> id . subeq Term
    (52) Exp -> id . addeql Term
    (53) Exp -> id . subeql Term
    (58) Term -> id . muleq Factor
    (59) Term -> id . diveq Factor
    (60) Term -> id . modeq Factor
    (61) Term -> id . muleql Factor
    (62) Term -> id . diveql Factor
    (63) Term -> id . modeql Factor
    (65) Factor -> id . plus
    (66) Factor -> id . plusl
    (67) Factor -> id . minus
    (68) Factor -> id . minusl
    (69) Factor -> id .
    (72) Factor -> id . ( )
    (74) Factor -> id . [ Exp ]
    (75) Factor -> id . [ Exp ] [ Exp ]

  ! shift/reduce conflict for ( resolved as shift
    addeq           shift and go to state 55
    subeq           shift and go to state 56
    addeql          shift and go to state 57
    subeql          shift and go to state 58
    muleq           shift and go to state 59
    diveq           shift and go to state 60
    modeq           shift and go to state 61
    muleql          shift and go to state 62
    diveql          shift and go to state 63
    modeql          shift and go to state 64
    plus            shift and go to state 65
    plusl           shift and go to state 66
    minus           shift and go to state 67
    minusl          shift and go to state 68
    *               reduce using rule 69 (Factor -> id .)
    /               reduce using rule 69 (Factor -> id .)
    %               reduce using rule 69 (Factor -> id .)
    )               reduce using rule 69 (Factor -> id .)
    sup             reduce using rule 69 (Factor -> id .)
    inf             reduce using rule 69 (Factor -> id .)
    supeq           reduce using rule 69 (Factor -> id .)
    infeq           reduce using rule 69 (Factor -> id .)
    eq              reduce using rule 69 (Factor -> id .)
    diff            reduce using rule 69 (Factor -> id .)
    +               reduce using rule 69 (Factor -> id .)
    -               reduce using rule 69 (Factor -> id .)
    }               reduce using rule 69 (Factor -> id .)
    id              reduce using rule 69 (Factor -> id .)
    gid             reduce using rule 69 (Factor -> id .)
    return          reduce using rule 69 (Factor -> id .)
    print           reduce using rule 69 (Factor -> id .)
    println         reduce using rule 69 (Factor -> id .)
    prints          reduce using rule 69 (Factor -> id .)
    for             reduce using rule 69 (Factor -> id .)
    while           reduce using rule 69 (Factor -> id .)
    read            reduce using rule 69 (Factor -> id .)
    if              reduce using rule 69 (Factor -> id .)
    repeat          reduce using rule 69 (Factor -> id .)
    num             reduce using rule 69 (Factor -> id .)
    ;               reduce using rule 69 (Factor -> id .)
    ]               reduce using rule 69 (Factor -> id .)
    and             reduce using rule 69 (Factor -> id .)
    or              reduce using rule 69 (Factor -> id .)
    (               shift and go to state 69
    [               shift and go to state 126

  ! (               [ reduce using rule 69 (Factor -> id .) ]


state 78

    (70) Factor -> gid .
    (76) Factor -> gid . [ Exp ]
    (77) Factor -> gid . [ Exp ] [ Exp ]

    *               reduce using rule 70 (Factor -> gid .)
    /               reduce using rule 70 (Factor -> gid .)
    %               reduce using rule 70 (Factor -> gid .)
    )               reduce using rule 70 (Factor -> gid .)
    sup             reduce using rule 70 (Factor -> gid .)
    inf             reduce using rule 70 (Factor -> gid .)
    supeq           reduce using rule 70 (Factor -> gid .)
    infeq           reduce using rule 70 (Factor -> gid .)
    eq              reduce using rule 70 (Factor -> gid .)
    diff            reduce using rule 70 (Factor -> gid .)
    +               reduce using rule 70 (Factor -> gid .)
    -               reduce using rule 70 (Factor -> gid .)
    }               reduce using rule 70 (Factor -> gid .)
    id              reduce using rule 70 (Factor -> gid .)
    gid             reduce using rule 70 (Factor -> gid .)
    return          reduce using rule 70 (Factor -> gid .)
    print           reduce using rule 70 (Factor -> gid .)
    println         reduce using rule 70 (Factor -> gid .)
    prints          reduce using rule 70 (Factor -> gid .)
    for             reduce using rule 70 (Factor -> gid .)
    while           reduce using rule 70 (Factor -> gid .)
    read            reduce using rule 70 (Factor -> gid .)
    if              reduce using rule 70 (Factor -> gid .)
    repeat          reduce using rule 70 (Factor -> gid .)
    num             reduce using rule 70 (Factor -> gid .)
    (               reduce using rule 70 (Factor -> gid .)
    ;               reduce using rule 70 (Factor -> gid .)
    ]               reduce using rule 70 (Factor -> gid .)
    and             reduce using rule 70 (Factor -> gid .)
    or              reduce using rule 70 (Factor -> gid .)
    [               shift and go to state 127


state 79

    (55) Term -> Term * . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 103
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Factor                         shift and go to state 128

state 80

    (56) Term -> Term / . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 103
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Factor                         shift and go to state 129

state 81

    (57) Term -> Term % . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 103
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Factor                         shift and go to state 130

state 82

    (30) Print -> print ( . Exp )
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 131
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 83

    (31) Println -> println ( . Exp )
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 132
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 84

    (32) Prints -> prints ( . string )

    string          shift and go to state 133


state 85

    (25) Repeat -> RepeatS ( . num ) { Insts }

    num             shift and go to state 134


state 86

    (27) For -> for ( . Insts ; Cond ; Insts ) { Insts }
    (12) Insts -> . Insts Inst
    (13) Insts -> .

    ;               reduce using rule 13 (Insts -> .)
    id              reduce using rule 13 (Insts -> .)
    gid             reduce using rule 13 (Insts -> .)
    return          reduce using rule 13 (Insts -> .)
    print           reduce using rule 13 (Insts -> .)
    println         reduce using rule 13 (Insts -> .)
    prints          reduce using rule 13 (Insts -> .)
    for             reduce using rule 13 (Insts -> .)
    while           reduce using rule 13 (Insts -> .)
    read            reduce using rule 13 (Insts -> .)
    if              reduce using rule 13 (Insts -> .)
    repeat          reduce using rule 13 (Insts -> .)
    num             reduce using rule 13 (Insts -> .)
    (               reduce using rule 13 (Insts -> .)

    Insts                          shift and go to state 135

state 87

    (28) While -> while ( . Cond ) { Insts }
    (79) Cond -> . Cond and Cond
    (80) Cond -> . Cond or Cond
    (81) Cond -> . ( Cond and Cond )
    (82) Cond -> . ( Cond or Cond )
    (83) Cond -> . Exp sup Exp
    (84) Cond -> . Exp inf Exp
    (85) Cond -> . Exp supeq Exp
    (86) Cond -> . Exp infeq Exp
    (87) Cond -> . not Exp
    (88) Cond -> . Exp eq Exp
    (89) Cond -> . Exp diff Exp
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    (               shift and go to state 73
    not             shift and go to state 76
    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42

    Cond                           shift and go to state 136
    Exp                            shift and go to state 137
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 88

    (29) Read -> read ( . id )

    id              shift and go to state 138


state 89

    (45) If -> if ( . Cond ) { Insts }
    (46) If -> if ( . Cond ) Inst
    (47) If -> if ( . Cond ) { Insts } else { Insts }
    (79) Cond -> . Cond and Cond
    (80) Cond -> . Cond or Cond
    (81) Cond -> . ( Cond and Cond )
    (82) Cond -> . ( Cond or Cond )
    (83) Cond -> . Exp sup Exp
    (84) Cond -> . Exp inf Exp
    (85) Cond -> . Exp supeq Exp
    (86) Cond -> . Exp infeq Exp
    (87) Cond -> . not Exp
    (88) Cond -> . Exp eq Exp
    (89) Cond -> . Exp diff Exp
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    (               shift and go to state 73
    not             shift and go to state 76
    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42

    Cond                           shift and go to state 139
    Exp                            shift and go to state 137
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 90

    (33) BlcInt -> int { Dcls } .

    }               reduce using rule 33 (BlcInt -> int { Dcls } .)
    int             reduce using rule 33 (BlcInt -> int { Dcls } .)
    id              reduce using rule 33 (BlcInt -> int { Dcls } .)
    gid             reduce using rule 33 (BlcInt -> int { Dcls } .)
    return          reduce using rule 33 (BlcInt -> int { Dcls } .)
    print           reduce using rule 33 (BlcInt -> int { Dcls } .)
    println         reduce using rule 33 (BlcInt -> int { Dcls } .)
    prints          reduce using rule 33 (BlcInt -> int { Dcls } .)
    for             reduce using rule 33 (BlcInt -> int { Dcls } .)
    while           reduce using rule 33 (BlcInt -> int { Dcls } .)
    read            reduce using rule 33 (BlcInt -> int { Dcls } .)
    if              reduce using rule 33 (BlcInt -> int { Dcls } .)
    repeat          reduce using rule 33 (BlcInt -> int { Dcls } .)
    num             reduce using rule 33 (BlcInt -> int { Dcls } .)
    (               reduce using rule 33 (BlcInt -> int { Dcls } .)


state 91

    (9) Dcls -> Dcls Dcl .

    }               reduce using rule 9 (Dcls -> Dcls Dcl .)
    id              reduce using rule 9 (Dcls -> Dcls Dcl .)


state 92

    (34) Dcl -> id . [ num ]
    (35) Dcl -> id . [ num ] [ num ]
    (36) Dcl -> id .
    (37) Dcl -> id . = num

    [               shift and go to state 140
    }               reduce using rule 36 (Dcl -> id .)
    id              reduce using rule 36 (Dcl -> id .)
    =               shift and go to state 141


state 93

    (4) DefBlc -> id { VarBlcs Insts } .

    id              reduce using rule 4 (DefBlc -> id { VarBlcs Insts } .)
    $end            reduce using rule 4 (DefBlc -> id { VarBlcs Insts } .)


state 94

    (48) Exp -> Exp + Term .
    (55) Term -> Term . * Factor
    (56) Term -> Term . / Factor
    (57) Term -> Term . % Factor

    +               reduce using rule 48 (Exp -> Exp + Term .)
    -               reduce using rule 48 (Exp -> Exp + Term .)
    }               reduce using rule 48 (Exp -> Exp + Term .)
    id              reduce using rule 48 (Exp -> Exp + Term .)
    gid             reduce using rule 48 (Exp -> Exp + Term .)
    return          reduce using rule 48 (Exp -> Exp + Term .)
    print           reduce using rule 48 (Exp -> Exp + Term .)
    println         reduce using rule 48 (Exp -> Exp + Term .)
    prints          reduce using rule 48 (Exp -> Exp + Term .)
    for             reduce using rule 48 (Exp -> Exp + Term .)
    while           reduce using rule 48 (Exp -> Exp + Term .)
    read            reduce using rule 48 (Exp -> Exp + Term .)
    if              reduce using rule 48 (Exp -> Exp + Term .)
    repeat          reduce using rule 48 (Exp -> Exp + Term .)
    num             reduce using rule 48 (Exp -> Exp + Term .)
    (               reduce using rule 48 (Exp -> Exp + Term .)
    )               reduce using rule 48 (Exp -> Exp + Term .)
    sup             reduce using rule 48 (Exp -> Exp + Term .)
    inf             reduce using rule 48 (Exp -> Exp + Term .)
    supeq           reduce using rule 48 (Exp -> Exp + Term .)
    infeq           reduce using rule 48 (Exp -> Exp + Term .)
    eq              reduce using rule 48 (Exp -> Exp + Term .)
    diff            reduce using rule 48 (Exp -> Exp + Term .)
    ;               reduce using rule 48 (Exp -> Exp + Term .)
    ]               reduce using rule 48 (Exp -> Exp + Term .)
    and             reduce using rule 48 (Exp -> Exp + Term .)
    or              reduce using rule 48 (Exp -> Exp + Term .)
    *               shift and go to state 79
    /               shift and go to state 80
    %               shift and go to state 81


state 95

    (58) Term -> id . muleq Factor
    (59) Term -> id . diveq Factor
    (60) Term -> id . modeq Factor
    (61) Term -> id . muleql Factor
    (62) Term -> id . diveql Factor
    (63) Term -> id . modeql Factor
    (65) Factor -> id . plus
    (66) Factor -> id . plusl
    (67) Factor -> id . minus
    (68) Factor -> id . minusl
    (69) Factor -> id .
    (72) Factor -> id . ( )
    (74) Factor -> id . [ Exp ]
    (75) Factor -> id . [ Exp ] [ Exp ]

  ! shift/reduce conflict for ( resolved as shift
    muleq           shift and go to state 59
    diveq           shift and go to state 60
    modeq           shift and go to state 61
    muleql          shift and go to state 62
    diveql          shift and go to state 63
    modeql          shift and go to state 64
    plus            shift and go to state 65
    plusl           shift and go to state 66
    minus           shift and go to state 67
    minusl          shift and go to state 68
    *               reduce using rule 69 (Factor -> id .)
    /               reduce using rule 69 (Factor -> id .)
    %               reduce using rule 69 (Factor -> id .)
    +               reduce using rule 69 (Factor -> id .)
    -               reduce using rule 69 (Factor -> id .)
    }               reduce using rule 69 (Factor -> id .)
    id              reduce using rule 69 (Factor -> id .)
    gid             reduce using rule 69 (Factor -> id .)
    return          reduce using rule 69 (Factor -> id .)
    print           reduce using rule 69 (Factor -> id .)
    println         reduce using rule 69 (Factor -> id .)
    prints          reduce using rule 69 (Factor -> id .)
    for             reduce using rule 69 (Factor -> id .)
    while           reduce using rule 69 (Factor -> id .)
    read            reduce using rule 69 (Factor -> id .)
    if              reduce using rule 69 (Factor -> id .)
    repeat          reduce using rule 69 (Factor -> id .)
    num             reduce using rule 69 (Factor -> id .)
    )               reduce using rule 69 (Factor -> id .)
    sup             reduce using rule 69 (Factor -> id .)
    inf             reduce using rule 69 (Factor -> id .)
    supeq           reduce using rule 69 (Factor -> id .)
    infeq           reduce using rule 69 (Factor -> id .)
    eq              reduce using rule 69 (Factor -> id .)
    diff            reduce using rule 69 (Factor -> id .)
    ;               reduce using rule 69 (Factor -> id .)
    ]               reduce using rule 69 (Factor -> id .)
    and             reduce using rule 69 (Factor -> id .)
    or              reduce using rule 69 (Factor -> id .)
    (               shift and go to state 69
    [               shift and go to state 126

  ! (               [ reduce using rule 69 (Factor -> id .) ]


state 96

    (49) Exp -> Exp - Term .
    (55) Term -> Term . * Factor
    (56) Term -> Term . / Factor
    (57) Term -> Term . % Factor

    +               reduce using rule 49 (Exp -> Exp - Term .)
    -               reduce using rule 49 (Exp -> Exp - Term .)
    }               reduce using rule 49 (Exp -> Exp - Term .)
    id              reduce using rule 49 (Exp -> Exp - Term .)
    gid             reduce using rule 49 (Exp -> Exp - Term .)
    return          reduce using rule 49 (Exp -> Exp - Term .)
    print           reduce using rule 49 (Exp -> Exp - Term .)
    println         reduce using rule 49 (Exp -> Exp - Term .)
    prints          reduce using rule 49 (Exp -> Exp - Term .)
    for             reduce using rule 49 (Exp -> Exp - Term .)
    while           reduce using rule 49 (Exp -> Exp - Term .)
    read            reduce using rule 49 (Exp -> Exp - Term .)
    if              reduce using rule 49 (Exp -> Exp - Term .)
    repeat          reduce using rule 49 (Exp -> Exp - Term .)
    num             reduce using rule 49 (Exp -> Exp - Term .)
    (               reduce using rule 49 (Exp -> Exp - Term .)
    )               reduce using rule 49 (Exp -> Exp - Term .)
    sup             reduce using rule 49 (Exp -> Exp - Term .)
    inf             reduce using rule 49 (Exp -> Exp - Term .)
    supeq           reduce using rule 49 (Exp -> Exp - Term .)
    infeq           reduce using rule 49 (Exp -> Exp - Term .)
    eq              reduce using rule 49 (Exp -> Exp - Term .)
    diff            reduce using rule 49 (Exp -> Exp - Term .)
    ;               reduce using rule 49 (Exp -> Exp - Term .)
    ]               reduce using rule 49 (Exp -> Exp - Term .)
    and             reduce using rule 49 (Exp -> Exp - Term .)
    or              reduce using rule 49 (Exp -> Exp - Term .)
    *               shift and go to state 79
    /               shift and go to state 80
    %               shift and go to state 81


state 97

    (38) Attr -> id = Exp .
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    }               reduce using rule 38 (Attr -> id = Exp .)
    id              reduce using rule 38 (Attr -> id = Exp .)
    gid             reduce using rule 38 (Attr -> id = Exp .)
    return          reduce using rule 38 (Attr -> id = Exp .)
    print           reduce using rule 38 (Attr -> id = Exp .)
    println         reduce using rule 38 (Attr -> id = Exp .)
    prints          reduce using rule 38 (Attr -> id = Exp .)
    for             reduce using rule 38 (Attr -> id = Exp .)
    while           reduce using rule 38 (Attr -> id = Exp .)
    read            reduce using rule 38 (Attr -> id = Exp .)
    if              reduce using rule 38 (Attr -> id = Exp .)
    repeat          reduce using rule 38 (Attr -> id = Exp .)
    num             reduce using rule 38 (Attr -> id = Exp .)
    (               reduce using rule 38 (Attr -> id = Exp .)
    ;               reduce using rule 38 (Attr -> id = Exp .)
    )               reduce using rule 38 (Attr -> id = Exp .)
    +               shift and go to state 51
    -               shift and go to state 52


state 98

    (39) Attr -> id [ Exp . ] = Exp
    (40) Attr -> id [ Exp . ] [ Exp ] = Exp
    (74) Factor -> id [ Exp . ]
    (75) Factor -> id [ Exp . ] [ Exp ]
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    ]               shift and go to state 142
    +               shift and go to state 51
    -               shift and go to state 52


state 99

    (50) Exp -> id addeq Term .
    (55) Term -> Term . * Factor
    (56) Term -> Term . / Factor
    (57) Term -> Term . % Factor

    +               reduce using rule 50 (Exp -> id addeq Term .)
    -               reduce using rule 50 (Exp -> id addeq Term .)
    }               reduce using rule 50 (Exp -> id addeq Term .)
    id              reduce using rule 50 (Exp -> id addeq Term .)
    gid             reduce using rule 50 (Exp -> id addeq Term .)
    return          reduce using rule 50 (Exp -> id addeq Term .)
    print           reduce using rule 50 (Exp -> id addeq Term .)
    println         reduce using rule 50 (Exp -> id addeq Term .)
    prints          reduce using rule 50 (Exp -> id addeq Term .)
    for             reduce using rule 50 (Exp -> id addeq Term .)
    while           reduce using rule 50 (Exp -> id addeq Term .)
    read            reduce using rule 50 (Exp -> id addeq Term .)
    if              reduce using rule 50 (Exp -> id addeq Term .)
    repeat          reduce using rule 50 (Exp -> id addeq Term .)
    num             reduce using rule 50 (Exp -> id addeq Term .)
    (               reduce using rule 50 (Exp -> id addeq Term .)
    )               reduce using rule 50 (Exp -> id addeq Term .)
    sup             reduce using rule 50 (Exp -> id addeq Term .)
    inf             reduce using rule 50 (Exp -> id addeq Term .)
    supeq           reduce using rule 50 (Exp -> id addeq Term .)
    infeq           reduce using rule 50 (Exp -> id addeq Term .)
    eq              reduce using rule 50 (Exp -> id addeq Term .)
    diff            reduce using rule 50 (Exp -> id addeq Term .)
    ;               reduce using rule 50 (Exp -> id addeq Term .)
    ]               reduce using rule 50 (Exp -> id addeq Term .)
    and             reduce using rule 50 (Exp -> id addeq Term .)
    or              reduce using rule 50 (Exp -> id addeq Term .)
    *               shift and go to state 79
    /               shift and go to state 80
    %               shift and go to state 81


state 100

    (51) Exp -> id subeq Term .
    (55) Term -> Term . * Factor
    (56) Term -> Term . / Factor
    (57) Term -> Term . % Factor

    +               reduce using rule 51 (Exp -> id subeq Term .)
    -               reduce using rule 51 (Exp -> id subeq Term .)
    }               reduce using rule 51 (Exp -> id subeq Term .)
    id              reduce using rule 51 (Exp -> id subeq Term .)
    gid             reduce using rule 51 (Exp -> id subeq Term .)
    return          reduce using rule 51 (Exp -> id subeq Term .)
    print           reduce using rule 51 (Exp -> id subeq Term .)
    println         reduce using rule 51 (Exp -> id subeq Term .)
    prints          reduce using rule 51 (Exp -> id subeq Term .)
    for             reduce using rule 51 (Exp -> id subeq Term .)
    while           reduce using rule 51 (Exp -> id subeq Term .)
    read            reduce using rule 51 (Exp -> id subeq Term .)
    if              reduce using rule 51 (Exp -> id subeq Term .)
    repeat          reduce using rule 51 (Exp -> id subeq Term .)
    num             reduce using rule 51 (Exp -> id subeq Term .)
    (               reduce using rule 51 (Exp -> id subeq Term .)
    )               reduce using rule 51 (Exp -> id subeq Term .)
    sup             reduce using rule 51 (Exp -> id subeq Term .)
    inf             reduce using rule 51 (Exp -> id subeq Term .)
    supeq           reduce using rule 51 (Exp -> id subeq Term .)
    infeq           reduce using rule 51 (Exp -> id subeq Term .)
    eq              reduce using rule 51 (Exp -> id subeq Term .)
    diff            reduce using rule 51 (Exp -> id subeq Term .)
    ;               reduce using rule 51 (Exp -> id subeq Term .)
    ]               reduce using rule 51 (Exp -> id subeq Term .)
    and             reduce using rule 51 (Exp -> id subeq Term .)
    or              reduce using rule 51 (Exp -> id subeq Term .)
    *               shift and go to state 79
    /               shift and go to state 80
    %               shift and go to state 81


state 101

    (52) Exp -> id addeql Term .
    (55) Term -> Term . * Factor
    (56) Term -> Term . / Factor
    (57) Term -> Term . % Factor

    +               reduce using rule 52 (Exp -> id addeql Term .)
    -               reduce using rule 52 (Exp -> id addeql Term .)
    }               reduce using rule 52 (Exp -> id addeql Term .)
    id              reduce using rule 52 (Exp -> id addeql Term .)
    gid             reduce using rule 52 (Exp -> id addeql Term .)
    return          reduce using rule 52 (Exp -> id addeql Term .)
    print           reduce using rule 52 (Exp -> id addeql Term .)
    println         reduce using rule 52 (Exp -> id addeql Term .)
    prints          reduce using rule 52 (Exp -> id addeql Term .)
    for             reduce using rule 52 (Exp -> id addeql Term .)
    while           reduce using rule 52 (Exp -> id addeql Term .)
    read            reduce using rule 52 (Exp -> id addeql Term .)
    if              reduce using rule 52 (Exp -> id addeql Term .)
    repeat          reduce using rule 52 (Exp -> id addeql Term .)
    num             reduce using rule 52 (Exp -> id addeql Term .)
    (               reduce using rule 52 (Exp -> id addeql Term .)
    )               reduce using rule 52 (Exp -> id addeql Term .)
    sup             reduce using rule 52 (Exp -> id addeql Term .)
    inf             reduce using rule 52 (Exp -> id addeql Term .)
    supeq           reduce using rule 52 (Exp -> id addeql Term .)
    infeq           reduce using rule 52 (Exp -> id addeql Term .)
    eq              reduce using rule 52 (Exp -> id addeql Term .)
    diff            reduce using rule 52 (Exp -> id addeql Term .)
    ;               reduce using rule 52 (Exp -> id addeql Term .)
    ]               reduce using rule 52 (Exp -> id addeql Term .)
    and             reduce using rule 52 (Exp -> id addeql Term .)
    or              reduce using rule 52 (Exp -> id addeql Term .)
    *               shift and go to state 79
    /               shift and go to state 80
    %               shift and go to state 81


state 102

    (53) Exp -> id subeql Term .
    (55) Term -> Term . * Factor
    (56) Term -> Term . / Factor
    (57) Term -> Term . % Factor

    +               reduce using rule 53 (Exp -> id subeql Term .)
    -               reduce using rule 53 (Exp -> id subeql Term .)
    }               reduce using rule 53 (Exp -> id subeql Term .)
    id              reduce using rule 53 (Exp -> id subeql Term .)
    gid             reduce using rule 53 (Exp -> id subeql Term .)
    return          reduce using rule 53 (Exp -> id subeql Term .)
    print           reduce using rule 53 (Exp -> id subeql Term .)
    println         reduce using rule 53 (Exp -> id subeql Term .)
    prints          reduce using rule 53 (Exp -> id subeql Term .)
    for             reduce using rule 53 (Exp -> id subeql Term .)
    while           reduce using rule 53 (Exp -> id subeql Term .)
    read            reduce using rule 53 (Exp -> id subeql Term .)
    if              reduce using rule 53 (Exp -> id subeql Term .)
    repeat          reduce using rule 53 (Exp -> id subeql Term .)
    num             reduce using rule 53 (Exp -> id subeql Term .)
    (               reduce using rule 53 (Exp -> id subeql Term .)
    )               reduce using rule 53 (Exp -> id subeql Term .)
    sup             reduce using rule 53 (Exp -> id subeql Term .)
    inf             reduce using rule 53 (Exp -> id subeql Term .)
    supeq           reduce using rule 53 (Exp -> id subeql Term .)
    infeq           reduce using rule 53 (Exp -> id subeql Term .)
    eq              reduce using rule 53 (Exp -> id subeql Term .)
    diff            reduce using rule 53 (Exp -> id subeql Term .)
    ;               reduce using rule 53 (Exp -> id subeql Term .)
    ]               reduce using rule 53 (Exp -> id subeql Term .)
    and             reduce using rule 53 (Exp -> id subeql Term .)
    or              reduce using rule 53 (Exp -> id subeql Term .)
    *               shift and go to state 79
    /               shift and go to state 80
    %               shift and go to state 81


state 103

    (65) Factor -> id . plus
    (66) Factor -> id . plusl
    (67) Factor -> id . minus
    (68) Factor -> id . minusl
    (69) Factor -> id .
    (72) Factor -> id . ( )
    (74) Factor -> id . [ Exp ]
    (75) Factor -> id . [ Exp ] [ Exp ]

  ! shift/reduce conflict for ( resolved as shift
    plus            shift and go to state 65
    plusl           shift and go to state 66
    minus           shift and go to state 67
    minusl          shift and go to state 68
    *               reduce using rule 69 (Factor -> id .)
    /               reduce using rule 69 (Factor -> id .)
    %               reduce using rule 69 (Factor -> id .)
    +               reduce using rule 69 (Factor -> id .)
    -               reduce using rule 69 (Factor -> id .)
    }               reduce using rule 69 (Factor -> id .)
    id              reduce using rule 69 (Factor -> id .)
    gid             reduce using rule 69 (Factor -> id .)
    return          reduce using rule 69 (Factor -> id .)
    print           reduce using rule 69 (Factor -> id .)
    println         reduce using rule 69 (Factor -> id .)
    prints          reduce using rule 69 (Factor -> id .)
    for             reduce using rule 69 (Factor -> id .)
    while           reduce using rule 69 (Factor -> id .)
    read            reduce using rule 69 (Factor -> id .)
    if              reduce using rule 69 (Factor -> id .)
    repeat          reduce using rule 69 (Factor -> id .)
    num             reduce using rule 69 (Factor -> id .)
    )               reduce using rule 69 (Factor -> id .)
    sup             reduce using rule 69 (Factor -> id .)
    inf             reduce using rule 69 (Factor -> id .)
    supeq           reduce using rule 69 (Factor -> id .)
    infeq           reduce using rule 69 (Factor -> id .)
    eq              reduce using rule 69 (Factor -> id .)
    diff            reduce using rule 69 (Factor -> id .)
    ;               reduce using rule 69 (Factor -> id .)
    ]               reduce using rule 69 (Factor -> id .)
    and             reduce using rule 69 (Factor -> id .)
    or              reduce using rule 69 (Factor -> id .)
    (               shift and go to state 69
    [               shift and go to state 126

  ! (               [ reduce using rule 69 (Factor -> id .) ]


state 104

    (58) Term -> id muleq Factor .

    *               reduce using rule 58 (Term -> id muleq Factor .)
    /               reduce using rule 58 (Term -> id muleq Factor .)
    %               reduce using rule 58 (Term -> id muleq Factor .)
    +               reduce using rule 58 (Term -> id muleq Factor .)
    -               reduce using rule 58 (Term -> id muleq Factor .)
    }               reduce using rule 58 (Term -> id muleq Factor .)
    id              reduce using rule 58 (Term -> id muleq Factor .)
    gid             reduce using rule 58 (Term -> id muleq Factor .)
    return          reduce using rule 58 (Term -> id muleq Factor .)
    print           reduce using rule 58 (Term -> id muleq Factor .)
    println         reduce using rule 58 (Term -> id muleq Factor .)
    prints          reduce using rule 58 (Term -> id muleq Factor .)
    for             reduce using rule 58 (Term -> id muleq Factor .)
    while           reduce using rule 58 (Term -> id muleq Factor .)
    read            reduce using rule 58 (Term -> id muleq Factor .)
    if              reduce using rule 58 (Term -> id muleq Factor .)
    repeat          reduce using rule 58 (Term -> id muleq Factor .)
    num             reduce using rule 58 (Term -> id muleq Factor .)
    (               reduce using rule 58 (Term -> id muleq Factor .)
    )               reduce using rule 58 (Term -> id muleq Factor .)
    sup             reduce using rule 58 (Term -> id muleq Factor .)
    inf             reduce using rule 58 (Term -> id muleq Factor .)
    supeq           reduce using rule 58 (Term -> id muleq Factor .)
    infeq           reduce using rule 58 (Term -> id muleq Factor .)
    eq              reduce using rule 58 (Term -> id muleq Factor .)
    diff            reduce using rule 58 (Term -> id muleq Factor .)
    ;               reduce using rule 58 (Term -> id muleq Factor .)
    ]               reduce using rule 58 (Term -> id muleq Factor .)
    and             reduce using rule 58 (Term -> id muleq Factor .)
    or              reduce using rule 58 (Term -> id muleq Factor .)


state 105

    (59) Term -> id diveq Factor .

    *               reduce using rule 59 (Term -> id diveq Factor .)
    /               reduce using rule 59 (Term -> id diveq Factor .)
    %               reduce using rule 59 (Term -> id diveq Factor .)
    +               reduce using rule 59 (Term -> id diveq Factor .)
    -               reduce using rule 59 (Term -> id diveq Factor .)
    }               reduce using rule 59 (Term -> id diveq Factor .)
    id              reduce using rule 59 (Term -> id diveq Factor .)
    gid             reduce using rule 59 (Term -> id diveq Factor .)
    return          reduce using rule 59 (Term -> id diveq Factor .)
    print           reduce using rule 59 (Term -> id diveq Factor .)
    println         reduce using rule 59 (Term -> id diveq Factor .)
    prints          reduce using rule 59 (Term -> id diveq Factor .)
    for             reduce using rule 59 (Term -> id diveq Factor .)
    while           reduce using rule 59 (Term -> id diveq Factor .)
    read            reduce using rule 59 (Term -> id diveq Factor .)
    if              reduce using rule 59 (Term -> id diveq Factor .)
    repeat          reduce using rule 59 (Term -> id diveq Factor .)
    num             reduce using rule 59 (Term -> id diveq Factor .)
    (               reduce using rule 59 (Term -> id diveq Factor .)
    )               reduce using rule 59 (Term -> id diveq Factor .)
    sup             reduce using rule 59 (Term -> id diveq Factor .)
    inf             reduce using rule 59 (Term -> id diveq Factor .)
    supeq           reduce using rule 59 (Term -> id diveq Factor .)
    infeq           reduce using rule 59 (Term -> id diveq Factor .)
    eq              reduce using rule 59 (Term -> id diveq Factor .)
    diff            reduce using rule 59 (Term -> id diveq Factor .)
    ;               reduce using rule 59 (Term -> id diveq Factor .)
    ]               reduce using rule 59 (Term -> id diveq Factor .)
    and             reduce using rule 59 (Term -> id diveq Factor .)
    or              reduce using rule 59 (Term -> id diveq Factor .)


state 106

    (60) Term -> id modeq Factor .

    *               reduce using rule 60 (Term -> id modeq Factor .)
    /               reduce using rule 60 (Term -> id modeq Factor .)
    %               reduce using rule 60 (Term -> id modeq Factor .)
    +               reduce using rule 60 (Term -> id modeq Factor .)
    -               reduce using rule 60 (Term -> id modeq Factor .)
    }               reduce using rule 60 (Term -> id modeq Factor .)
    id              reduce using rule 60 (Term -> id modeq Factor .)
    gid             reduce using rule 60 (Term -> id modeq Factor .)
    return          reduce using rule 60 (Term -> id modeq Factor .)
    print           reduce using rule 60 (Term -> id modeq Factor .)
    println         reduce using rule 60 (Term -> id modeq Factor .)
    prints          reduce using rule 60 (Term -> id modeq Factor .)
    for             reduce using rule 60 (Term -> id modeq Factor .)
    while           reduce using rule 60 (Term -> id modeq Factor .)
    read            reduce using rule 60 (Term -> id modeq Factor .)
    if              reduce using rule 60 (Term -> id modeq Factor .)
    repeat          reduce using rule 60 (Term -> id modeq Factor .)
    num             reduce using rule 60 (Term -> id modeq Factor .)
    (               reduce using rule 60 (Term -> id modeq Factor .)
    )               reduce using rule 60 (Term -> id modeq Factor .)
    sup             reduce using rule 60 (Term -> id modeq Factor .)
    inf             reduce using rule 60 (Term -> id modeq Factor .)
    supeq           reduce using rule 60 (Term -> id modeq Factor .)
    infeq           reduce using rule 60 (Term -> id modeq Factor .)
    eq              reduce using rule 60 (Term -> id modeq Factor .)
    diff            reduce using rule 60 (Term -> id modeq Factor .)
    ;               reduce using rule 60 (Term -> id modeq Factor .)
    ]               reduce using rule 60 (Term -> id modeq Factor .)
    and             reduce using rule 60 (Term -> id modeq Factor .)
    or              reduce using rule 60 (Term -> id modeq Factor .)


state 107

    (61) Term -> id muleql Factor .

    *               reduce using rule 61 (Term -> id muleql Factor .)
    /               reduce using rule 61 (Term -> id muleql Factor .)
    %               reduce using rule 61 (Term -> id muleql Factor .)
    +               reduce using rule 61 (Term -> id muleql Factor .)
    -               reduce using rule 61 (Term -> id muleql Factor .)
    }               reduce using rule 61 (Term -> id muleql Factor .)
    id              reduce using rule 61 (Term -> id muleql Factor .)
    gid             reduce using rule 61 (Term -> id muleql Factor .)
    return          reduce using rule 61 (Term -> id muleql Factor .)
    print           reduce using rule 61 (Term -> id muleql Factor .)
    println         reduce using rule 61 (Term -> id muleql Factor .)
    prints          reduce using rule 61 (Term -> id muleql Factor .)
    for             reduce using rule 61 (Term -> id muleql Factor .)
    while           reduce using rule 61 (Term -> id muleql Factor .)
    read            reduce using rule 61 (Term -> id muleql Factor .)
    if              reduce using rule 61 (Term -> id muleql Factor .)
    repeat          reduce using rule 61 (Term -> id muleql Factor .)
    num             reduce using rule 61 (Term -> id muleql Factor .)
    (               reduce using rule 61 (Term -> id muleql Factor .)
    )               reduce using rule 61 (Term -> id muleql Factor .)
    sup             reduce using rule 61 (Term -> id muleql Factor .)
    inf             reduce using rule 61 (Term -> id muleql Factor .)
    supeq           reduce using rule 61 (Term -> id muleql Factor .)
    infeq           reduce using rule 61 (Term -> id muleql Factor .)
    eq              reduce using rule 61 (Term -> id muleql Factor .)
    diff            reduce using rule 61 (Term -> id muleql Factor .)
    ;               reduce using rule 61 (Term -> id muleql Factor .)
    ]               reduce using rule 61 (Term -> id muleql Factor .)
    and             reduce using rule 61 (Term -> id muleql Factor .)
    or              reduce using rule 61 (Term -> id muleql Factor .)


state 108

    (62) Term -> id diveql Factor .

    *               reduce using rule 62 (Term -> id diveql Factor .)
    /               reduce using rule 62 (Term -> id diveql Factor .)
    %               reduce using rule 62 (Term -> id diveql Factor .)
    +               reduce using rule 62 (Term -> id diveql Factor .)
    -               reduce using rule 62 (Term -> id diveql Factor .)
    }               reduce using rule 62 (Term -> id diveql Factor .)
    id              reduce using rule 62 (Term -> id diveql Factor .)
    gid             reduce using rule 62 (Term -> id diveql Factor .)
    return          reduce using rule 62 (Term -> id diveql Factor .)
    print           reduce using rule 62 (Term -> id diveql Factor .)
    println         reduce using rule 62 (Term -> id diveql Factor .)
    prints          reduce using rule 62 (Term -> id diveql Factor .)
    for             reduce using rule 62 (Term -> id diveql Factor .)
    while           reduce using rule 62 (Term -> id diveql Factor .)
    read            reduce using rule 62 (Term -> id diveql Factor .)
    if              reduce using rule 62 (Term -> id diveql Factor .)
    repeat          reduce using rule 62 (Term -> id diveql Factor .)
    num             reduce using rule 62 (Term -> id diveql Factor .)
    (               reduce using rule 62 (Term -> id diveql Factor .)
    )               reduce using rule 62 (Term -> id diveql Factor .)
    sup             reduce using rule 62 (Term -> id diveql Factor .)
    inf             reduce using rule 62 (Term -> id diveql Factor .)
    supeq           reduce using rule 62 (Term -> id diveql Factor .)
    infeq           reduce using rule 62 (Term -> id diveql Factor .)
    eq              reduce using rule 62 (Term -> id diveql Factor .)
    diff            reduce using rule 62 (Term -> id diveql Factor .)
    ;               reduce using rule 62 (Term -> id diveql Factor .)
    ]               reduce using rule 62 (Term -> id diveql Factor .)
    and             reduce using rule 62 (Term -> id diveql Factor .)
    or              reduce using rule 62 (Term -> id diveql Factor .)


state 109

    (63) Term -> id modeql Factor .

    *               reduce using rule 63 (Term -> id modeql Factor .)
    /               reduce using rule 63 (Term -> id modeql Factor .)
    %               reduce using rule 63 (Term -> id modeql Factor .)
    +               reduce using rule 63 (Term -> id modeql Factor .)
    -               reduce using rule 63 (Term -> id modeql Factor .)
    }               reduce using rule 63 (Term -> id modeql Factor .)
    id              reduce using rule 63 (Term -> id modeql Factor .)
    gid             reduce using rule 63 (Term -> id modeql Factor .)
    return          reduce using rule 63 (Term -> id modeql Factor .)
    print           reduce using rule 63 (Term -> id modeql Factor .)
    println         reduce using rule 63 (Term -> id modeql Factor .)
    prints          reduce using rule 63 (Term -> id modeql Factor .)
    for             reduce using rule 63 (Term -> id modeql Factor .)
    while           reduce using rule 63 (Term -> id modeql Factor .)
    read            reduce using rule 63 (Term -> id modeql Factor .)
    if              reduce using rule 63 (Term -> id modeql Factor .)
    repeat          reduce using rule 63 (Term -> id modeql Factor .)
    num             reduce using rule 63 (Term -> id modeql Factor .)
    (               reduce using rule 63 (Term -> id modeql Factor .)
    )               reduce using rule 63 (Term -> id modeql Factor .)
    sup             reduce using rule 63 (Term -> id modeql Factor .)
    inf             reduce using rule 63 (Term -> id modeql Factor .)
    supeq           reduce using rule 63 (Term -> id modeql Factor .)
    infeq           reduce using rule 63 (Term -> id modeql Factor .)
    eq              reduce using rule 63 (Term -> id modeql Factor .)
    diff            reduce using rule 63 (Term -> id modeql Factor .)
    ;               reduce using rule 63 (Term -> id modeql Factor .)
    ]               reduce using rule 63 (Term -> id modeql Factor .)
    and             reduce using rule 63 (Term -> id modeql Factor .)
    or              reduce using rule 63 (Term -> id modeql Factor .)


state 110

    (72) Factor -> id ( ) .

    *               reduce using rule 72 (Factor -> id ( ) .)
    /               reduce using rule 72 (Factor -> id ( ) .)
    %               reduce using rule 72 (Factor -> id ( ) .)
    +               reduce using rule 72 (Factor -> id ( ) .)
    -               reduce using rule 72 (Factor -> id ( ) .)
    }               reduce using rule 72 (Factor -> id ( ) .)
    id              reduce using rule 72 (Factor -> id ( ) .)
    gid             reduce using rule 72 (Factor -> id ( ) .)
    return          reduce using rule 72 (Factor -> id ( ) .)
    print           reduce using rule 72 (Factor -> id ( ) .)
    println         reduce using rule 72 (Factor -> id ( ) .)
    prints          reduce using rule 72 (Factor -> id ( ) .)
    for             reduce using rule 72 (Factor -> id ( ) .)
    while           reduce using rule 72 (Factor -> id ( ) .)
    read            reduce using rule 72 (Factor -> id ( ) .)
    if              reduce using rule 72 (Factor -> id ( ) .)
    repeat          reduce using rule 72 (Factor -> id ( ) .)
    num             reduce using rule 72 (Factor -> id ( ) .)
    (               reduce using rule 72 (Factor -> id ( ) .)
    )               reduce using rule 72 (Factor -> id ( ) .)
    sup             reduce using rule 72 (Factor -> id ( ) .)
    inf             reduce using rule 72 (Factor -> id ( ) .)
    supeq           reduce using rule 72 (Factor -> id ( ) .)
    infeq           reduce using rule 72 (Factor -> id ( ) .)
    eq              reduce using rule 72 (Factor -> id ( ) .)
    diff            reduce using rule 72 (Factor -> id ( ) .)
    ;               reduce using rule 72 (Factor -> id ( ) .)
    ]               reduce using rule 72 (Factor -> id ( ) .)
    and             reduce using rule 72 (Factor -> id ( ) .)
    or              reduce using rule 72 (Factor -> id ( ) .)


state 111

    (41) Attr -> gid = Exp .
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    }               reduce using rule 41 (Attr -> gid = Exp .)
    id              reduce using rule 41 (Attr -> gid = Exp .)
    gid             reduce using rule 41 (Attr -> gid = Exp .)
    return          reduce using rule 41 (Attr -> gid = Exp .)
    print           reduce using rule 41 (Attr -> gid = Exp .)
    println         reduce using rule 41 (Attr -> gid = Exp .)
    prints          reduce using rule 41 (Attr -> gid = Exp .)
    for             reduce using rule 41 (Attr -> gid = Exp .)
    while           reduce using rule 41 (Attr -> gid = Exp .)
    read            reduce using rule 41 (Attr -> gid = Exp .)
    if              reduce using rule 41 (Attr -> gid = Exp .)
    repeat          reduce using rule 41 (Attr -> gid = Exp .)
    num             reduce using rule 41 (Attr -> gid = Exp .)
    (               reduce using rule 41 (Attr -> gid = Exp .)
    ;               reduce using rule 41 (Attr -> gid = Exp .)
    )               reduce using rule 41 (Attr -> gid = Exp .)
    +               shift and go to state 51
    -               shift and go to state 52


state 112

    (42) Attr -> gid [ Exp . ] = Exp
    (43) Attr -> gid [ Exp . ] [ Exp ] = Exp
    (76) Factor -> gid [ Exp . ]
    (77) Factor -> gid [ Exp . ] [ Exp ]
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    ]               shift and go to state 143
    +               shift and go to state 51
    -               shift and go to state 52


state 113

    (44) Return -> return ( Exp . )
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    )               shift and go to state 144
    +               shift and go to state 51
    -               shift and go to state 52


state 114

    (81) Cond -> ( Cond . and Cond )
    (82) Cond -> ( Cond . or Cond )
    (73) Factor -> ( Cond . )
    (79) Cond -> Cond . and Cond
    (80) Cond -> Cond . or Cond

    and             shift and go to state 145
    or              shift and go to state 146
    )               shift and go to state 115


state 115

    (73) Factor -> ( Cond ) .

    *               reduce using rule 73 (Factor -> ( Cond ) .)
    /               reduce using rule 73 (Factor -> ( Cond ) .)
    %               reduce using rule 73 (Factor -> ( Cond ) .)
    +               reduce using rule 73 (Factor -> ( Cond ) .)
    -               reduce using rule 73 (Factor -> ( Cond ) .)
    }               reduce using rule 73 (Factor -> ( Cond ) .)
    id              reduce using rule 73 (Factor -> ( Cond ) .)
    gid             reduce using rule 73 (Factor -> ( Cond ) .)
    return          reduce using rule 73 (Factor -> ( Cond ) .)
    print           reduce using rule 73 (Factor -> ( Cond ) .)
    println         reduce using rule 73 (Factor -> ( Cond ) .)
    prints          reduce using rule 73 (Factor -> ( Cond ) .)
    for             reduce using rule 73 (Factor -> ( Cond ) .)
    while           reduce using rule 73 (Factor -> ( Cond ) .)
    read            reduce using rule 73 (Factor -> ( Cond ) .)
    if              reduce using rule 73 (Factor -> ( Cond ) .)
    repeat          reduce using rule 73 (Factor -> ( Cond ) .)
    num             reduce using rule 73 (Factor -> ( Cond ) .)
    (               reduce using rule 73 (Factor -> ( Cond ) .)
    )               reduce using rule 73 (Factor -> ( Cond ) .)
    sup             reduce using rule 73 (Factor -> ( Cond ) .)
    inf             reduce using rule 73 (Factor -> ( Cond ) .)
    supeq           reduce using rule 73 (Factor -> ( Cond ) .)
    infeq           reduce using rule 73 (Factor -> ( Cond ) .)
    eq              reduce using rule 73 (Factor -> ( Cond ) .)
    diff            reduce using rule 73 (Factor -> ( Cond ) .)
    ;               reduce using rule 73 (Factor -> ( Cond ) .)
    ]               reduce using rule 73 (Factor -> ( Cond ) .)
    and             reduce using rule 73 (Factor -> ( Cond ) .)
    or              reduce using rule 73 (Factor -> ( Cond ) .)


state 116

    (79) Cond -> Cond and . Cond
    (79) Cond -> . Cond and Cond
    (80) Cond -> . Cond or Cond
    (81) Cond -> . ( Cond and Cond )
    (82) Cond -> . ( Cond or Cond )
    (83) Cond -> . Exp sup Exp
    (84) Cond -> . Exp inf Exp
    (85) Cond -> . Exp supeq Exp
    (86) Cond -> . Exp infeq Exp
    (87) Cond -> . not Exp
    (88) Cond -> . Exp eq Exp
    (89) Cond -> . Exp diff Exp
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    (               shift and go to state 73
    not             shift and go to state 76
    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42

    Cond                           shift and go to state 147
    Exp                            shift and go to state 137
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 117

    (80) Cond -> Cond or . Cond
    (79) Cond -> . Cond and Cond
    (80) Cond -> . Cond or Cond
    (81) Cond -> . ( Cond and Cond )
    (82) Cond -> . ( Cond or Cond )
    (83) Cond -> . Exp sup Exp
    (84) Cond -> . Exp inf Exp
    (85) Cond -> . Exp supeq Exp
    (86) Cond -> . Exp infeq Exp
    (87) Cond -> . not Exp
    (88) Cond -> . Exp eq Exp
    (89) Cond -> . Exp diff Exp
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    (               shift and go to state 73
    not             shift and go to state 76
    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42

    Cond                           shift and go to state 148
    Exp                            shift and go to state 137
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 118

    (78) Factor -> ( Exp ) .

    *               reduce using rule 78 (Factor -> ( Exp ) .)
    /               reduce using rule 78 (Factor -> ( Exp ) .)
    %               reduce using rule 78 (Factor -> ( Exp ) .)
    +               reduce using rule 78 (Factor -> ( Exp ) .)
    -               reduce using rule 78 (Factor -> ( Exp ) .)
    }               reduce using rule 78 (Factor -> ( Exp ) .)
    id              reduce using rule 78 (Factor -> ( Exp ) .)
    gid             reduce using rule 78 (Factor -> ( Exp ) .)
    return          reduce using rule 78 (Factor -> ( Exp ) .)
    print           reduce using rule 78 (Factor -> ( Exp ) .)
    println         reduce using rule 78 (Factor -> ( Exp ) .)
    prints          reduce using rule 78 (Factor -> ( Exp ) .)
    for             reduce using rule 78 (Factor -> ( Exp ) .)
    while           reduce using rule 78 (Factor -> ( Exp ) .)
    read            reduce using rule 78 (Factor -> ( Exp ) .)
    if              reduce using rule 78 (Factor -> ( Exp ) .)
    repeat          reduce using rule 78 (Factor -> ( Exp ) .)
    num             reduce using rule 78 (Factor -> ( Exp ) .)
    (               reduce using rule 78 (Factor -> ( Exp ) .)
    )               reduce using rule 78 (Factor -> ( Exp ) .)
    sup             reduce using rule 78 (Factor -> ( Exp ) .)
    inf             reduce using rule 78 (Factor -> ( Exp ) .)
    supeq           reduce using rule 78 (Factor -> ( Exp ) .)
    infeq           reduce using rule 78 (Factor -> ( Exp ) .)
    eq              reduce using rule 78 (Factor -> ( Exp ) .)
    diff            reduce using rule 78 (Factor -> ( Exp ) .)
    ;               reduce using rule 78 (Factor -> ( Exp ) .)
    ]               reduce using rule 78 (Factor -> ( Exp ) .)
    and             reduce using rule 78 (Factor -> ( Exp ) .)
    or              reduce using rule 78 (Factor -> ( Exp ) .)


state 119

    (83) Cond -> Exp sup . Exp
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 149
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 120

    (84) Cond -> Exp inf . Exp
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 150
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 121

    (85) Cond -> Exp supeq . Exp
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 151
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 122

    (86) Cond -> Exp infeq . Exp
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 152
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 123

    (88) Cond -> Exp eq . Exp
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 153
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 124

    (89) Cond -> Exp diff . Exp
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 154
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 125

    (87) Cond -> not Exp .
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    )               reduce using rule 87 (Cond -> not Exp .)
    and             reduce using rule 87 (Cond -> not Exp .)
    or              reduce using rule 87 (Cond -> not Exp .)
    ;               reduce using rule 87 (Cond -> not Exp .)
    +               shift and go to state 51
    -               shift and go to state 52


state 126

    (74) Factor -> id [ . Exp ]
    (75) Factor -> id [ . Exp ] [ Exp ]
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 155
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 127

    (76) Factor -> gid [ . Exp ]
    (77) Factor -> gid [ . Exp ] [ Exp ]
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 156
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 128

    (55) Term -> Term * Factor .

    *               reduce using rule 55 (Term -> Term * Factor .)
    /               reduce using rule 55 (Term -> Term * Factor .)
    %               reduce using rule 55 (Term -> Term * Factor .)
    +               reduce using rule 55 (Term -> Term * Factor .)
    -               reduce using rule 55 (Term -> Term * Factor .)
    }               reduce using rule 55 (Term -> Term * Factor .)
    id              reduce using rule 55 (Term -> Term * Factor .)
    gid             reduce using rule 55 (Term -> Term * Factor .)
    return          reduce using rule 55 (Term -> Term * Factor .)
    print           reduce using rule 55 (Term -> Term * Factor .)
    println         reduce using rule 55 (Term -> Term * Factor .)
    prints          reduce using rule 55 (Term -> Term * Factor .)
    for             reduce using rule 55 (Term -> Term * Factor .)
    while           reduce using rule 55 (Term -> Term * Factor .)
    read            reduce using rule 55 (Term -> Term * Factor .)
    if              reduce using rule 55 (Term -> Term * Factor .)
    repeat          reduce using rule 55 (Term -> Term * Factor .)
    num             reduce using rule 55 (Term -> Term * Factor .)
    (               reduce using rule 55 (Term -> Term * Factor .)
    )               reduce using rule 55 (Term -> Term * Factor .)
    sup             reduce using rule 55 (Term -> Term * Factor .)
    inf             reduce using rule 55 (Term -> Term * Factor .)
    supeq           reduce using rule 55 (Term -> Term * Factor .)
    infeq           reduce using rule 55 (Term -> Term * Factor .)
    eq              reduce using rule 55 (Term -> Term * Factor .)
    diff            reduce using rule 55 (Term -> Term * Factor .)
    ;               reduce using rule 55 (Term -> Term * Factor .)
    ]               reduce using rule 55 (Term -> Term * Factor .)
    and             reduce using rule 55 (Term -> Term * Factor .)
    or              reduce using rule 55 (Term -> Term * Factor .)


state 129

    (56) Term -> Term / Factor .

    *               reduce using rule 56 (Term -> Term / Factor .)
    /               reduce using rule 56 (Term -> Term / Factor .)
    %               reduce using rule 56 (Term -> Term / Factor .)
    +               reduce using rule 56 (Term -> Term / Factor .)
    -               reduce using rule 56 (Term -> Term / Factor .)
    }               reduce using rule 56 (Term -> Term / Factor .)
    id              reduce using rule 56 (Term -> Term / Factor .)
    gid             reduce using rule 56 (Term -> Term / Factor .)
    return          reduce using rule 56 (Term -> Term / Factor .)
    print           reduce using rule 56 (Term -> Term / Factor .)
    println         reduce using rule 56 (Term -> Term / Factor .)
    prints          reduce using rule 56 (Term -> Term / Factor .)
    for             reduce using rule 56 (Term -> Term / Factor .)
    while           reduce using rule 56 (Term -> Term / Factor .)
    read            reduce using rule 56 (Term -> Term / Factor .)
    if              reduce using rule 56 (Term -> Term / Factor .)
    repeat          reduce using rule 56 (Term -> Term / Factor .)
    num             reduce using rule 56 (Term -> Term / Factor .)
    (               reduce using rule 56 (Term -> Term / Factor .)
    )               reduce using rule 56 (Term -> Term / Factor .)
    sup             reduce using rule 56 (Term -> Term / Factor .)
    inf             reduce using rule 56 (Term -> Term / Factor .)
    supeq           reduce using rule 56 (Term -> Term / Factor .)
    infeq           reduce using rule 56 (Term -> Term / Factor .)
    eq              reduce using rule 56 (Term -> Term / Factor .)
    diff            reduce using rule 56 (Term -> Term / Factor .)
    ;               reduce using rule 56 (Term -> Term / Factor .)
    ]               reduce using rule 56 (Term -> Term / Factor .)
    and             reduce using rule 56 (Term -> Term / Factor .)
    or              reduce using rule 56 (Term -> Term / Factor .)


state 130

    (57) Term -> Term % Factor .

    *               reduce using rule 57 (Term -> Term % Factor .)
    /               reduce using rule 57 (Term -> Term % Factor .)
    %               reduce using rule 57 (Term -> Term % Factor .)
    +               reduce using rule 57 (Term -> Term % Factor .)
    -               reduce using rule 57 (Term -> Term % Factor .)
    }               reduce using rule 57 (Term -> Term % Factor .)
    id              reduce using rule 57 (Term -> Term % Factor .)
    gid             reduce using rule 57 (Term -> Term % Factor .)
    return          reduce using rule 57 (Term -> Term % Factor .)
    print           reduce using rule 57 (Term -> Term % Factor .)
    println         reduce using rule 57 (Term -> Term % Factor .)
    prints          reduce using rule 57 (Term -> Term % Factor .)
    for             reduce using rule 57 (Term -> Term % Factor .)
    while           reduce using rule 57 (Term -> Term % Factor .)
    read            reduce using rule 57 (Term -> Term % Factor .)
    if              reduce using rule 57 (Term -> Term % Factor .)
    repeat          reduce using rule 57 (Term -> Term % Factor .)
    num             reduce using rule 57 (Term -> Term % Factor .)
    (               reduce using rule 57 (Term -> Term % Factor .)
    )               reduce using rule 57 (Term -> Term % Factor .)
    sup             reduce using rule 57 (Term -> Term % Factor .)
    inf             reduce using rule 57 (Term -> Term % Factor .)
    supeq           reduce using rule 57 (Term -> Term % Factor .)
    infeq           reduce using rule 57 (Term -> Term % Factor .)
    eq              reduce using rule 57 (Term -> Term % Factor .)
    diff            reduce using rule 57 (Term -> Term % Factor .)
    ;               reduce using rule 57 (Term -> Term % Factor .)
    ]               reduce using rule 57 (Term -> Term % Factor .)
    and             reduce using rule 57 (Term -> Term % Factor .)
    or              reduce using rule 57 (Term -> Term % Factor .)


state 131

    (30) Print -> print ( Exp . )
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    )               shift and go to state 157
    +               shift and go to state 51
    -               shift and go to state 52


state 132

    (31) Println -> println ( Exp . )
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    )               shift and go to state 158
    +               shift and go to state 51
    -               shift and go to state 52


state 133

    (32) Prints -> prints ( string . )

    )               shift and go to state 159


state 134

    (25) Repeat -> RepeatS ( num . ) { Insts }

    )               shift and go to state 160


state 135

    (27) For -> for ( Insts . ; Cond ; Insts ) { Insts }
    (12) Insts -> Insts . Inst
    (14) Inst -> . Attr
    (15) Inst -> . Return
    (16) Inst -> . Exp
    (17) Inst -> . Print
    (18) Inst -> . Println
    (19) Inst -> . Prints
    (20) Inst -> . Repeat
    (21) Inst -> . For
    (22) Inst -> . While
    (23) Inst -> . Read
    (24) Inst -> . If
    (38) Attr -> . id = Exp
    (39) Attr -> . id [ Exp ] = Exp
    (40) Attr -> . id [ Exp ] [ Exp ] = Exp
    (41) Attr -> . gid = Exp
    (42) Attr -> . gid [ Exp ] = Exp
    (43) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (44) Return -> . return ( Exp )
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (30) Print -> . print ( Exp )
    (31) Println -> . println ( Exp )
    (32) Prints -> . prints ( string )
    (25) Repeat -> . RepeatS ( num ) { Insts }
    (27) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (28) While -> . while ( Cond ) { Insts }
    (29) Read -> . read ( id )
    (45) If -> . if ( Cond ) { Insts }
    (46) If -> . if ( Cond ) Inst
    (47) If -> . if ( Cond ) { Insts } else { Insts }
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (26) RepeatS -> . repeat
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    ;               shift and go to state 161
    id              shift and go to state 33
    gid             shift and go to state 34
    return          shift and go to state 35
    print           shift and go to state 38
    println         shift and go to state 39
    prints          shift and go to state 40
    for             shift and go to state 43
    while           shift and go to state 44
    read            shift and go to state 45
    if              shift and go to state 46
    repeat          shift and go to state 48
    num             shift and go to state 42
    (               shift and go to state 36

    Inst                           shift and go to state 21
    Attr                           shift and go to state 22
    Return                         shift and go to state 23
    Exp                            shift and go to state 24
    Print                          shift and go to state 25
    Println                        shift and go to state 26
    Prints                         shift and go to state 27
    Repeat                         shift and go to state 28
    For                            shift and go to state 29
    While                          shift and go to state 30
    Read                           shift and go to state 31
    If                             shift and go to state 32
    Term                           shift and go to state 37
    RepeatS                        shift and go to state 41
    Factor                         shift and go to state 47

state 136

    (28) While -> while ( Cond . ) { Insts }
    (79) Cond -> Cond . and Cond
    (80) Cond -> Cond . or Cond

    )               shift and go to state 162
    and             shift and go to state 116
    or              shift and go to state 117


state 137

    (83) Cond -> Exp . sup Exp
    (84) Cond -> Exp . inf Exp
    (85) Cond -> Exp . supeq Exp
    (86) Cond -> Exp . infeq Exp
    (88) Cond -> Exp . eq Exp
    (89) Cond -> Exp . diff Exp
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    sup             shift and go to state 119
    inf             shift and go to state 120
    supeq           shift and go to state 121
    infeq           shift and go to state 122
    eq              shift and go to state 123
    diff            shift and go to state 124
    +               shift and go to state 51
    -               shift and go to state 52


state 138

    (29) Read -> read ( id . )

    )               shift and go to state 163


state 139

    (45) If -> if ( Cond . ) { Insts }
    (46) If -> if ( Cond . ) Inst
    (47) If -> if ( Cond . ) { Insts } else { Insts }
    (79) Cond -> Cond . and Cond
    (80) Cond -> Cond . or Cond

    )               shift and go to state 164
    and             shift and go to state 116
    or              shift and go to state 117


state 140

    (34) Dcl -> id [ . num ]
    (35) Dcl -> id [ . num ] [ num ]

    num             shift and go to state 165


state 141

    (37) Dcl -> id = . num

    num             shift and go to state 166


state 142

    (39) Attr -> id [ Exp ] . = Exp
    (40) Attr -> id [ Exp ] . [ Exp ] = Exp
    (74) Factor -> id [ Exp ] .
    (75) Factor -> id [ Exp ] . [ Exp ]

    =               shift and go to state 168
    [               shift and go to state 167
    *               reduce using rule 74 (Factor -> id [ Exp ] .)
    /               reduce using rule 74 (Factor -> id [ Exp ] .)
    %               reduce using rule 74 (Factor -> id [ Exp ] .)
    +               reduce using rule 74 (Factor -> id [ Exp ] .)
    -               reduce using rule 74 (Factor -> id [ Exp ] .)
    }               reduce using rule 74 (Factor -> id [ Exp ] .)
    id              reduce using rule 74 (Factor -> id [ Exp ] .)
    gid             reduce using rule 74 (Factor -> id [ Exp ] .)
    return          reduce using rule 74 (Factor -> id [ Exp ] .)
    print           reduce using rule 74 (Factor -> id [ Exp ] .)
    println         reduce using rule 74 (Factor -> id [ Exp ] .)
    prints          reduce using rule 74 (Factor -> id [ Exp ] .)
    for             reduce using rule 74 (Factor -> id [ Exp ] .)
    while           reduce using rule 74 (Factor -> id [ Exp ] .)
    read            reduce using rule 74 (Factor -> id [ Exp ] .)
    if              reduce using rule 74 (Factor -> id [ Exp ] .)
    repeat          reduce using rule 74 (Factor -> id [ Exp ] .)
    num             reduce using rule 74 (Factor -> id [ Exp ] .)
    (               reduce using rule 74 (Factor -> id [ Exp ] .)
    ;               reduce using rule 74 (Factor -> id [ Exp ] .)
    )               reduce using rule 74 (Factor -> id [ Exp ] .)


state 143

    (42) Attr -> gid [ Exp ] . = Exp
    (43) Attr -> gid [ Exp ] . [ Exp ] = Exp
    (76) Factor -> gid [ Exp ] .
    (77) Factor -> gid [ Exp ] . [ Exp ]

    =               shift and go to state 170
    [               shift and go to state 169
    *               reduce using rule 76 (Factor -> gid [ Exp ] .)
    /               reduce using rule 76 (Factor -> gid [ Exp ] .)
    %               reduce using rule 76 (Factor -> gid [ Exp ] .)
    +               reduce using rule 76 (Factor -> gid [ Exp ] .)
    -               reduce using rule 76 (Factor -> gid [ Exp ] .)
    }               reduce using rule 76 (Factor -> gid [ Exp ] .)
    id              reduce using rule 76 (Factor -> gid [ Exp ] .)
    gid             reduce using rule 76 (Factor -> gid [ Exp ] .)
    return          reduce using rule 76 (Factor -> gid [ Exp ] .)
    print           reduce using rule 76 (Factor -> gid [ Exp ] .)
    println         reduce using rule 76 (Factor -> gid [ Exp ] .)
    prints          reduce using rule 76 (Factor -> gid [ Exp ] .)
    for             reduce using rule 76 (Factor -> gid [ Exp ] .)
    while           reduce using rule 76 (Factor -> gid [ Exp ] .)
    read            reduce using rule 76 (Factor -> gid [ Exp ] .)
    if              reduce using rule 76 (Factor -> gid [ Exp ] .)
    repeat          reduce using rule 76 (Factor -> gid [ Exp ] .)
    num             reduce using rule 76 (Factor -> gid [ Exp ] .)
    (               reduce using rule 76 (Factor -> gid [ Exp ] .)
    ;               reduce using rule 76 (Factor -> gid [ Exp ] .)
    )               reduce using rule 76 (Factor -> gid [ Exp ] .)


state 144

    (44) Return -> return ( Exp ) .

    }               reduce using rule 44 (Return -> return ( Exp ) .)
    id              reduce using rule 44 (Return -> return ( Exp ) .)
    gid             reduce using rule 44 (Return -> return ( Exp ) .)
    return          reduce using rule 44 (Return -> return ( Exp ) .)
    print           reduce using rule 44 (Return -> return ( Exp ) .)
    println         reduce using rule 44 (Return -> return ( Exp ) .)
    prints          reduce using rule 44 (Return -> return ( Exp ) .)
    for             reduce using rule 44 (Return -> return ( Exp ) .)
    while           reduce using rule 44 (Return -> return ( Exp ) .)
    read            reduce using rule 44 (Return -> return ( Exp ) .)
    if              reduce using rule 44 (Return -> return ( Exp ) .)
    repeat          reduce using rule 44 (Return -> return ( Exp ) .)
    num             reduce using rule 44 (Return -> return ( Exp ) .)
    (               reduce using rule 44 (Return -> return ( Exp ) .)
    ;               reduce using rule 44 (Return -> return ( Exp ) .)
    )               reduce using rule 44 (Return -> return ( Exp ) .)


state 145

    (81) Cond -> ( Cond and . Cond )
    (79) Cond -> Cond and . Cond
    (79) Cond -> . Cond and Cond
    (80) Cond -> . Cond or Cond
    (81) Cond -> . ( Cond and Cond )
    (82) Cond -> . ( Cond or Cond )
    (83) Cond -> . Exp sup Exp
    (84) Cond -> . Exp inf Exp
    (85) Cond -> . Exp supeq Exp
    (86) Cond -> . Exp infeq Exp
    (87) Cond -> . not Exp
    (88) Cond -> . Exp eq Exp
    (89) Cond -> . Exp diff Exp
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    (               shift and go to state 73
    not             shift and go to state 76
    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42

    Cond                           shift and go to state 171
    Exp                            shift and go to state 137
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 146

    (82) Cond -> ( Cond or . Cond )
    (80) Cond -> Cond or . Cond
    (79) Cond -> . Cond and Cond
    (80) Cond -> . Cond or Cond
    (81) Cond -> . ( Cond and Cond )
    (82) Cond -> . ( Cond or Cond )
    (83) Cond -> . Exp sup Exp
    (84) Cond -> . Exp inf Exp
    (85) Cond -> . Exp supeq Exp
    (86) Cond -> . Exp infeq Exp
    (87) Cond -> . not Exp
    (88) Cond -> . Exp eq Exp
    (89) Cond -> . Exp diff Exp
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    (               shift and go to state 73
    not             shift and go to state 76
    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42

    Cond                           shift and go to state 172
    Exp                            shift and go to state 137
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 147

    (79) Cond -> Cond and Cond .
    (79) Cond -> Cond . and Cond
    (80) Cond -> Cond . or Cond

  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
    )               reduce using rule 79 (Cond -> Cond and Cond .)
    ;               reduce using rule 79 (Cond -> Cond and Cond .)
    and             shift and go to state 116
    or              shift and go to state 117

  ! and             [ reduce using rule 79 (Cond -> Cond and Cond .) ]
  ! or              [ reduce using rule 79 (Cond -> Cond and Cond .) ]


state 148

    (80) Cond -> Cond or Cond .
    (79) Cond -> Cond . and Cond
    (80) Cond -> Cond . or Cond

  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
    )               reduce using rule 80 (Cond -> Cond or Cond .)
    ;               reduce using rule 80 (Cond -> Cond or Cond .)
    and             shift and go to state 116
    or              shift and go to state 117

  ! and             [ reduce using rule 80 (Cond -> Cond or Cond .) ]
  ! or              [ reduce using rule 80 (Cond -> Cond or Cond .) ]


state 149

    (83) Cond -> Exp sup Exp .
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    )               reduce using rule 83 (Cond -> Exp sup Exp .)
    and             reduce using rule 83 (Cond -> Exp sup Exp .)
    or              reduce using rule 83 (Cond -> Exp sup Exp .)
    ;               reduce using rule 83 (Cond -> Exp sup Exp .)
    +               shift and go to state 51
    -               shift and go to state 52


state 150

    (84) Cond -> Exp inf Exp .
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    )               reduce using rule 84 (Cond -> Exp inf Exp .)
    and             reduce using rule 84 (Cond -> Exp inf Exp .)
    or              reduce using rule 84 (Cond -> Exp inf Exp .)
    ;               reduce using rule 84 (Cond -> Exp inf Exp .)
    +               shift and go to state 51
    -               shift and go to state 52


state 151

    (85) Cond -> Exp supeq Exp .
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    )               reduce using rule 85 (Cond -> Exp supeq Exp .)
    and             reduce using rule 85 (Cond -> Exp supeq Exp .)
    or              reduce using rule 85 (Cond -> Exp supeq Exp .)
    ;               reduce using rule 85 (Cond -> Exp supeq Exp .)
    +               shift and go to state 51
    -               shift and go to state 52


state 152

    (86) Cond -> Exp infeq Exp .
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    )               reduce using rule 86 (Cond -> Exp infeq Exp .)
    and             reduce using rule 86 (Cond -> Exp infeq Exp .)
    or              reduce using rule 86 (Cond -> Exp infeq Exp .)
    ;               reduce using rule 86 (Cond -> Exp infeq Exp .)
    +               shift and go to state 51
    -               shift and go to state 52


state 153

    (88) Cond -> Exp eq Exp .
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    )               reduce using rule 88 (Cond -> Exp eq Exp .)
    and             reduce using rule 88 (Cond -> Exp eq Exp .)
    or              reduce using rule 88 (Cond -> Exp eq Exp .)
    ;               reduce using rule 88 (Cond -> Exp eq Exp .)
    +               shift and go to state 51
    -               shift and go to state 52


state 154

    (89) Cond -> Exp diff Exp .
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    )               reduce using rule 89 (Cond -> Exp diff Exp .)
    and             reduce using rule 89 (Cond -> Exp diff Exp .)
    or              reduce using rule 89 (Cond -> Exp diff Exp .)
    ;               reduce using rule 89 (Cond -> Exp diff Exp .)
    +               shift and go to state 51
    -               shift and go to state 52


state 155

    (74) Factor -> id [ Exp . ]
    (75) Factor -> id [ Exp . ] [ Exp ]
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    ]               shift and go to state 173
    +               shift and go to state 51
    -               shift and go to state 52


state 156

    (76) Factor -> gid [ Exp . ]
    (77) Factor -> gid [ Exp . ] [ Exp ]
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    ]               shift and go to state 174
    +               shift and go to state 51
    -               shift and go to state 52


state 157

    (30) Print -> print ( Exp ) .

    }               reduce using rule 30 (Print -> print ( Exp ) .)
    id              reduce using rule 30 (Print -> print ( Exp ) .)
    gid             reduce using rule 30 (Print -> print ( Exp ) .)
    return          reduce using rule 30 (Print -> print ( Exp ) .)
    print           reduce using rule 30 (Print -> print ( Exp ) .)
    println         reduce using rule 30 (Print -> print ( Exp ) .)
    prints          reduce using rule 30 (Print -> print ( Exp ) .)
    for             reduce using rule 30 (Print -> print ( Exp ) .)
    while           reduce using rule 30 (Print -> print ( Exp ) .)
    read            reduce using rule 30 (Print -> print ( Exp ) .)
    if              reduce using rule 30 (Print -> print ( Exp ) .)
    repeat          reduce using rule 30 (Print -> print ( Exp ) .)
    num             reduce using rule 30 (Print -> print ( Exp ) .)
    (               reduce using rule 30 (Print -> print ( Exp ) .)
    ;               reduce using rule 30 (Print -> print ( Exp ) .)
    )               reduce using rule 30 (Print -> print ( Exp ) .)


state 158

    (31) Println -> println ( Exp ) .

    }               reduce using rule 31 (Println -> println ( Exp ) .)
    id              reduce using rule 31 (Println -> println ( Exp ) .)
    gid             reduce using rule 31 (Println -> println ( Exp ) .)
    return          reduce using rule 31 (Println -> println ( Exp ) .)
    print           reduce using rule 31 (Println -> println ( Exp ) .)
    println         reduce using rule 31 (Println -> println ( Exp ) .)
    prints          reduce using rule 31 (Println -> println ( Exp ) .)
    for             reduce using rule 31 (Println -> println ( Exp ) .)
    while           reduce using rule 31 (Println -> println ( Exp ) .)
    read            reduce using rule 31 (Println -> println ( Exp ) .)
    if              reduce using rule 31 (Println -> println ( Exp ) .)
    repeat          reduce using rule 31 (Println -> println ( Exp ) .)
    num             reduce using rule 31 (Println -> println ( Exp ) .)
    (               reduce using rule 31 (Println -> println ( Exp ) .)
    ;               reduce using rule 31 (Println -> println ( Exp ) .)
    )               reduce using rule 31 (Println -> println ( Exp ) .)


state 159

    (32) Prints -> prints ( string ) .

    }               reduce using rule 32 (Prints -> prints ( string ) .)
    id              reduce using rule 32 (Prints -> prints ( string ) .)
    gid             reduce using rule 32 (Prints -> prints ( string ) .)
    return          reduce using rule 32 (Prints -> prints ( string ) .)
    print           reduce using rule 32 (Prints -> prints ( string ) .)
    println         reduce using rule 32 (Prints -> prints ( string ) .)
    prints          reduce using rule 32 (Prints -> prints ( string ) .)
    for             reduce using rule 32 (Prints -> prints ( string ) .)
    while           reduce using rule 32 (Prints -> prints ( string ) .)
    read            reduce using rule 32 (Prints -> prints ( string ) .)
    if              reduce using rule 32 (Prints -> prints ( string ) .)
    repeat          reduce using rule 32 (Prints -> prints ( string ) .)
    num             reduce using rule 32 (Prints -> prints ( string ) .)
    (               reduce using rule 32 (Prints -> prints ( string ) .)
    ;               reduce using rule 32 (Prints -> prints ( string ) .)
    )               reduce using rule 32 (Prints -> prints ( string ) .)


state 160

    (25) Repeat -> RepeatS ( num ) . { Insts }

    {               shift and go to state 175


state 161

    (27) For -> for ( Insts ; . Cond ; Insts ) { Insts }
    (79) Cond -> . Cond and Cond
    (80) Cond -> . Cond or Cond
    (81) Cond -> . ( Cond and Cond )
    (82) Cond -> . ( Cond or Cond )
    (83) Cond -> . Exp sup Exp
    (84) Cond -> . Exp inf Exp
    (85) Cond -> . Exp supeq Exp
    (86) Cond -> . Exp infeq Exp
    (87) Cond -> . not Exp
    (88) Cond -> . Exp eq Exp
    (89) Cond -> . Exp diff Exp
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    (               shift and go to state 73
    not             shift and go to state 76
    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42

    Cond                           shift and go to state 176
    Exp                            shift and go to state 137
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 162

    (28) While -> while ( Cond ) . { Insts }

    {               shift and go to state 177


state 163

    (29) Read -> read ( id ) .

    }               reduce using rule 29 (Read -> read ( id ) .)
    id              reduce using rule 29 (Read -> read ( id ) .)
    gid             reduce using rule 29 (Read -> read ( id ) .)
    return          reduce using rule 29 (Read -> read ( id ) .)
    print           reduce using rule 29 (Read -> read ( id ) .)
    println         reduce using rule 29 (Read -> read ( id ) .)
    prints          reduce using rule 29 (Read -> read ( id ) .)
    for             reduce using rule 29 (Read -> read ( id ) .)
    while           reduce using rule 29 (Read -> read ( id ) .)
    read            reduce using rule 29 (Read -> read ( id ) .)
    if              reduce using rule 29 (Read -> read ( id ) .)
    repeat          reduce using rule 29 (Read -> read ( id ) .)
    num             reduce using rule 29 (Read -> read ( id ) .)
    (               reduce using rule 29 (Read -> read ( id ) .)
    ;               reduce using rule 29 (Read -> read ( id ) .)
    )               reduce using rule 29 (Read -> read ( id ) .)


state 164

    (45) If -> if ( Cond ) . { Insts }
    (46) If -> if ( Cond ) . Inst
    (47) If -> if ( Cond ) . { Insts } else { Insts }
    (14) Inst -> . Attr
    (15) Inst -> . Return
    (16) Inst -> . Exp
    (17) Inst -> . Print
    (18) Inst -> . Println
    (19) Inst -> . Prints
    (20) Inst -> . Repeat
    (21) Inst -> . For
    (22) Inst -> . While
    (23) Inst -> . Read
    (24) Inst -> . If
    (38) Attr -> . id = Exp
    (39) Attr -> . id [ Exp ] = Exp
    (40) Attr -> . id [ Exp ] [ Exp ] = Exp
    (41) Attr -> . gid = Exp
    (42) Attr -> . gid [ Exp ] = Exp
    (43) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (44) Return -> . return ( Exp )
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (30) Print -> . print ( Exp )
    (31) Println -> . println ( Exp )
    (32) Prints -> . prints ( string )
    (25) Repeat -> . RepeatS ( num ) { Insts }
    (27) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (28) While -> . while ( Cond ) { Insts }
    (29) Read -> . read ( id )
    (45) If -> . if ( Cond ) { Insts }
    (46) If -> . if ( Cond ) Inst
    (47) If -> . if ( Cond ) { Insts } else { Insts }
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (26) RepeatS -> . repeat
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    {               shift and go to state 178
    id              shift and go to state 33
    gid             shift and go to state 34
    return          shift and go to state 35
    print           shift and go to state 38
    println         shift and go to state 39
    prints          shift and go to state 40
    for             shift and go to state 43
    while           shift and go to state 44
    read            shift and go to state 45
    if              shift and go to state 46
    repeat          shift and go to state 48
    num             shift and go to state 42
    (               shift and go to state 36

    Inst                           shift and go to state 179
    Attr                           shift and go to state 22
    Return                         shift and go to state 23
    Exp                            shift and go to state 24
    Print                          shift and go to state 25
    Println                        shift and go to state 26
    Prints                         shift and go to state 27
    Repeat                         shift and go to state 28
    For                            shift and go to state 29
    While                          shift and go to state 30
    Read                           shift and go to state 31
    If                             shift and go to state 32
    Term                           shift and go to state 37
    RepeatS                        shift and go to state 41
    Factor                         shift and go to state 47

state 165

    (34) Dcl -> id [ num . ]
    (35) Dcl -> id [ num . ] [ num ]

    ]               shift and go to state 180


state 166

    (37) Dcl -> id = num .

    }               reduce using rule 37 (Dcl -> id = num .)
    id              reduce using rule 37 (Dcl -> id = num .)


state 167

    (40) Attr -> id [ Exp ] [ . Exp ] = Exp
    (75) Factor -> id [ Exp ] [ . Exp ]
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 181
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 168

    (39) Attr -> id [ Exp ] = . Exp
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 182
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 169

    (43) Attr -> gid [ Exp ] [ . Exp ] = Exp
    (77) Factor -> gid [ Exp ] [ . Exp ]
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 183
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 170

    (42) Attr -> gid [ Exp ] = . Exp
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 184
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 171

    (81) Cond -> ( Cond and Cond . )
    (79) Cond -> Cond and Cond .
    (79) Cond -> Cond . and Cond
    (80) Cond -> Cond . or Cond

  ! shift/reduce conflict for ) resolved as shift
  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
    )               shift and go to state 185
    and             shift and go to state 116
    or              shift and go to state 117

  ! and             [ reduce using rule 79 (Cond -> Cond and Cond .) ]
  ! or              [ reduce using rule 79 (Cond -> Cond and Cond .) ]
  ! )               [ reduce using rule 79 (Cond -> Cond and Cond .) ]


state 172

    (82) Cond -> ( Cond or Cond . )
    (80) Cond -> Cond or Cond .
    (79) Cond -> Cond . and Cond
    (80) Cond -> Cond . or Cond

  ! shift/reduce conflict for ) resolved as shift
  ! shift/reduce conflict for and resolved as shift
  ! shift/reduce conflict for or resolved as shift
    )               shift and go to state 186
    and             shift and go to state 116
    or              shift and go to state 117

  ! and             [ reduce using rule 80 (Cond -> Cond or Cond .) ]
  ! or              [ reduce using rule 80 (Cond -> Cond or Cond .) ]
  ! )               [ reduce using rule 80 (Cond -> Cond or Cond .) ]


state 173

    (74) Factor -> id [ Exp ] .
    (75) Factor -> id [ Exp ] . [ Exp ]

    *               reduce using rule 74 (Factor -> id [ Exp ] .)
    /               reduce using rule 74 (Factor -> id [ Exp ] .)
    %               reduce using rule 74 (Factor -> id [ Exp ] .)
    )               reduce using rule 74 (Factor -> id [ Exp ] .)
    sup             reduce using rule 74 (Factor -> id [ Exp ] .)
    inf             reduce using rule 74 (Factor -> id [ Exp ] .)
    supeq           reduce using rule 74 (Factor -> id [ Exp ] .)
    infeq           reduce using rule 74 (Factor -> id [ Exp ] .)
    eq              reduce using rule 74 (Factor -> id [ Exp ] .)
    diff            reduce using rule 74 (Factor -> id [ Exp ] .)
    +               reduce using rule 74 (Factor -> id [ Exp ] .)
    -               reduce using rule 74 (Factor -> id [ Exp ] .)
    }               reduce using rule 74 (Factor -> id [ Exp ] .)
    id              reduce using rule 74 (Factor -> id [ Exp ] .)
    gid             reduce using rule 74 (Factor -> id [ Exp ] .)
    return          reduce using rule 74 (Factor -> id [ Exp ] .)
    print           reduce using rule 74 (Factor -> id [ Exp ] .)
    println         reduce using rule 74 (Factor -> id [ Exp ] .)
    prints          reduce using rule 74 (Factor -> id [ Exp ] .)
    for             reduce using rule 74 (Factor -> id [ Exp ] .)
    while           reduce using rule 74 (Factor -> id [ Exp ] .)
    read            reduce using rule 74 (Factor -> id [ Exp ] .)
    if              reduce using rule 74 (Factor -> id [ Exp ] .)
    repeat          reduce using rule 74 (Factor -> id [ Exp ] .)
    num             reduce using rule 74 (Factor -> id [ Exp ] .)
    (               reduce using rule 74 (Factor -> id [ Exp ] .)
    ;               reduce using rule 74 (Factor -> id [ Exp ] .)
    ]               reduce using rule 74 (Factor -> id [ Exp ] .)
    and             reduce using rule 74 (Factor -> id [ Exp ] .)
    or              reduce using rule 74 (Factor -> id [ Exp ] .)
    [               shift and go to state 187


state 174

    (76) Factor -> gid [ Exp ] .
    (77) Factor -> gid [ Exp ] . [ Exp ]

    *               reduce using rule 76 (Factor -> gid [ Exp ] .)
    /               reduce using rule 76 (Factor -> gid [ Exp ] .)
    %               reduce using rule 76 (Factor -> gid [ Exp ] .)
    )               reduce using rule 76 (Factor -> gid [ Exp ] .)
    sup             reduce using rule 76 (Factor -> gid [ Exp ] .)
    inf             reduce using rule 76 (Factor -> gid [ Exp ] .)
    supeq           reduce using rule 76 (Factor -> gid [ Exp ] .)
    infeq           reduce using rule 76 (Factor -> gid [ Exp ] .)
    eq              reduce using rule 76 (Factor -> gid [ Exp ] .)
    diff            reduce using rule 76 (Factor -> gid [ Exp ] .)
    +               reduce using rule 76 (Factor -> gid [ Exp ] .)
    -               reduce using rule 76 (Factor -> gid [ Exp ] .)
    }               reduce using rule 76 (Factor -> gid [ Exp ] .)
    id              reduce using rule 76 (Factor -> gid [ Exp ] .)
    gid             reduce using rule 76 (Factor -> gid [ Exp ] .)
    return          reduce using rule 76 (Factor -> gid [ Exp ] .)
    print           reduce using rule 76 (Factor -> gid [ Exp ] .)
    println         reduce using rule 76 (Factor -> gid [ Exp ] .)
    prints          reduce using rule 76 (Factor -> gid [ Exp ] .)
    for             reduce using rule 76 (Factor -> gid [ Exp ] .)
    while           reduce using rule 76 (Factor -> gid [ Exp ] .)
    read            reduce using rule 76 (Factor -> gid [ Exp ] .)
    if              reduce using rule 76 (Factor -> gid [ Exp ] .)
    repeat          reduce using rule 76 (Factor -> gid [ Exp ] .)
    num             reduce using rule 76 (Factor -> gid [ Exp ] .)
    (               reduce using rule 76 (Factor -> gid [ Exp ] .)
    ;               reduce using rule 76 (Factor -> gid [ Exp ] .)
    ]               reduce using rule 76 (Factor -> gid [ Exp ] .)
    and             reduce using rule 76 (Factor -> gid [ Exp ] .)
    or              reduce using rule 76 (Factor -> gid [ Exp ] .)
    [               shift and go to state 188


state 175

    (25) Repeat -> RepeatS ( num ) { . Insts }
    (12) Insts -> . Insts Inst
    (13) Insts -> .

    }               reduce using rule 13 (Insts -> .)
    id              reduce using rule 13 (Insts -> .)
    gid             reduce using rule 13 (Insts -> .)
    return          reduce using rule 13 (Insts -> .)
    print           reduce using rule 13 (Insts -> .)
    println         reduce using rule 13 (Insts -> .)
    prints          reduce using rule 13 (Insts -> .)
    for             reduce using rule 13 (Insts -> .)
    while           reduce using rule 13 (Insts -> .)
    read            reduce using rule 13 (Insts -> .)
    if              reduce using rule 13 (Insts -> .)
    repeat          reduce using rule 13 (Insts -> .)
    num             reduce using rule 13 (Insts -> .)
    (               reduce using rule 13 (Insts -> .)

    Insts                          shift and go to state 189

state 176

    (27) For -> for ( Insts ; Cond . ; Insts ) { Insts }
    (79) Cond -> Cond . and Cond
    (80) Cond -> Cond . or Cond

    ;               shift and go to state 190
    and             shift and go to state 116
    or              shift and go to state 117


state 177

    (28) While -> while ( Cond ) { . Insts }
    (12) Insts -> . Insts Inst
    (13) Insts -> .

    }               reduce using rule 13 (Insts -> .)
    id              reduce using rule 13 (Insts -> .)
    gid             reduce using rule 13 (Insts -> .)
    return          reduce using rule 13 (Insts -> .)
    print           reduce using rule 13 (Insts -> .)
    println         reduce using rule 13 (Insts -> .)
    prints          reduce using rule 13 (Insts -> .)
    for             reduce using rule 13 (Insts -> .)
    while           reduce using rule 13 (Insts -> .)
    read            reduce using rule 13 (Insts -> .)
    if              reduce using rule 13 (Insts -> .)
    repeat          reduce using rule 13 (Insts -> .)
    num             reduce using rule 13 (Insts -> .)
    (               reduce using rule 13 (Insts -> .)

    Insts                          shift and go to state 191

state 178

    (45) If -> if ( Cond ) { . Insts }
    (47) If -> if ( Cond ) { . Insts } else { Insts }
    (12) Insts -> . Insts Inst
    (13) Insts -> .

    }               reduce using rule 13 (Insts -> .)
    id              reduce using rule 13 (Insts -> .)
    gid             reduce using rule 13 (Insts -> .)
    return          reduce using rule 13 (Insts -> .)
    print           reduce using rule 13 (Insts -> .)
    println         reduce using rule 13 (Insts -> .)
    prints          reduce using rule 13 (Insts -> .)
    for             reduce using rule 13 (Insts -> .)
    while           reduce using rule 13 (Insts -> .)
    read            reduce using rule 13 (Insts -> .)
    if              reduce using rule 13 (Insts -> .)
    repeat          reduce using rule 13 (Insts -> .)
    num             reduce using rule 13 (Insts -> .)
    (               reduce using rule 13 (Insts -> .)

    Insts                          shift and go to state 192

state 179

    (46) If -> if ( Cond ) Inst .

    }               reduce using rule 46 (If -> if ( Cond ) Inst .)
    id              reduce using rule 46 (If -> if ( Cond ) Inst .)
    gid             reduce using rule 46 (If -> if ( Cond ) Inst .)
    return          reduce using rule 46 (If -> if ( Cond ) Inst .)
    print           reduce using rule 46 (If -> if ( Cond ) Inst .)
    println         reduce using rule 46 (If -> if ( Cond ) Inst .)
    prints          reduce using rule 46 (If -> if ( Cond ) Inst .)
    for             reduce using rule 46 (If -> if ( Cond ) Inst .)
    while           reduce using rule 46 (If -> if ( Cond ) Inst .)
    read            reduce using rule 46 (If -> if ( Cond ) Inst .)
    if              reduce using rule 46 (If -> if ( Cond ) Inst .)
    repeat          reduce using rule 46 (If -> if ( Cond ) Inst .)
    num             reduce using rule 46 (If -> if ( Cond ) Inst .)
    (               reduce using rule 46 (If -> if ( Cond ) Inst .)
    ;               reduce using rule 46 (If -> if ( Cond ) Inst .)
    )               reduce using rule 46 (If -> if ( Cond ) Inst .)


state 180

    (34) Dcl -> id [ num ] .
    (35) Dcl -> id [ num ] . [ num ]

    }               reduce using rule 34 (Dcl -> id [ num ] .)
    id              reduce using rule 34 (Dcl -> id [ num ] .)
    [               shift and go to state 193


state 181

    (40) Attr -> id [ Exp ] [ Exp . ] = Exp
    (75) Factor -> id [ Exp ] [ Exp . ]
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    ]               shift and go to state 194
    +               shift and go to state 51
    -               shift and go to state 52


state 182

    (39) Attr -> id [ Exp ] = Exp .
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    }               reduce using rule 39 (Attr -> id [ Exp ] = Exp .)
    id              reduce using rule 39 (Attr -> id [ Exp ] = Exp .)
    gid             reduce using rule 39 (Attr -> id [ Exp ] = Exp .)
    return          reduce using rule 39 (Attr -> id [ Exp ] = Exp .)
    print           reduce using rule 39 (Attr -> id [ Exp ] = Exp .)
    println         reduce using rule 39 (Attr -> id [ Exp ] = Exp .)
    prints          reduce using rule 39 (Attr -> id [ Exp ] = Exp .)
    for             reduce using rule 39 (Attr -> id [ Exp ] = Exp .)
    while           reduce using rule 39 (Attr -> id [ Exp ] = Exp .)
    read            reduce using rule 39 (Attr -> id [ Exp ] = Exp .)
    if              reduce using rule 39 (Attr -> id [ Exp ] = Exp .)
    repeat          reduce using rule 39 (Attr -> id [ Exp ] = Exp .)
    num             reduce using rule 39 (Attr -> id [ Exp ] = Exp .)
    (               reduce using rule 39 (Attr -> id [ Exp ] = Exp .)
    ;               reduce using rule 39 (Attr -> id [ Exp ] = Exp .)
    )               reduce using rule 39 (Attr -> id [ Exp ] = Exp .)
    +               shift and go to state 51
    -               shift and go to state 52


state 183

    (43) Attr -> gid [ Exp ] [ Exp . ] = Exp
    (77) Factor -> gid [ Exp ] [ Exp . ]
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    ]               shift and go to state 195
    +               shift and go to state 51
    -               shift and go to state 52


state 184

    (42) Attr -> gid [ Exp ] = Exp .
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    }               reduce using rule 42 (Attr -> gid [ Exp ] = Exp .)
    id              reduce using rule 42 (Attr -> gid [ Exp ] = Exp .)
    gid             reduce using rule 42 (Attr -> gid [ Exp ] = Exp .)
    return          reduce using rule 42 (Attr -> gid [ Exp ] = Exp .)
    print           reduce using rule 42 (Attr -> gid [ Exp ] = Exp .)
    println         reduce using rule 42 (Attr -> gid [ Exp ] = Exp .)
    prints          reduce using rule 42 (Attr -> gid [ Exp ] = Exp .)
    for             reduce using rule 42 (Attr -> gid [ Exp ] = Exp .)
    while           reduce using rule 42 (Attr -> gid [ Exp ] = Exp .)
    read            reduce using rule 42 (Attr -> gid [ Exp ] = Exp .)
    if              reduce using rule 42 (Attr -> gid [ Exp ] = Exp .)
    repeat          reduce using rule 42 (Attr -> gid [ Exp ] = Exp .)
    num             reduce using rule 42 (Attr -> gid [ Exp ] = Exp .)
    (               reduce using rule 42 (Attr -> gid [ Exp ] = Exp .)
    ;               reduce using rule 42 (Attr -> gid [ Exp ] = Exp .)
    )               reduce using rule 42 (Attr -> gid [ Exp ] = Exp .)
    +               shift and go to state 51
    -               shift and go to state 52


state 185

    (81) Cond -> ( Cond and Cond ) .

    )               reduce using rule 81 (Cond -> ( Cond and Cond ) .)
    and             reduce using rule 81 (Cond -> ( Cond and Cond ) .)
    or              reduce using rule 81 (Cond -> ( Cond and Cond ) .)
    ;               reduce using rule 81 (Cond -> ( Cond and Cond ) .)


state 186

    (82) Cond -> ( Cond or Cond ) .

    )               reduce using rule 82 (Cond -> ( Cond or Cond ) .)
    and             reduce using rule 82 (Cond -> ( Cond or Cond ) .)
    or              reduce using rule 82 (Cond -> ( Cond or Cond ) .)
    ;               reduce using rule 82 (Cond -> ( Cond or Cond ) .)


state 187

    (75) Factor -> id [ Exp ] [ . Exp ]
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 196
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 188

    (77) Factor -> gid [ Exp ] [ . Exp ]
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 197
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 189

    (25) Repeat -> RepeatS ( num ) { Insts . }
    (12) Insts -> Insts . Inst
    (14) Inst -> . Attr
    (15) Inst -> . Return
    (16) Inst -> . Exp
    (17) Inst -> . Print
    (18) Inst -> . Println
    (19) Inst -> . Prints
    (20) Inst -> . Repeat
    (21) Inst -> . For
    (22) Inst -> . While
    (23) Inst -> . Read
    (24) Inst -> . If
    (38) Attr -> . id = Exp
    (39) Attr -> . id [ Exp ] = Exp
    (40) Attr -> . id [ Exp ] [ Exp ] = Exp
    (41) Attr -> . gid = Exp
    (42) Attr -> . gid [ Exp ] = Exp
    (43) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (44) Return -> . return ( Exp )
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (30) Print -> . print ( Exp )
    (31) Println -> . println ( Exp )
    (32) Prints -> . prints ( string )
    (25) Repeat -> . RepeatS ( num ) { Insts }
    (27) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (28) While -> . while ( Cond ) { Insts }
    (29) Read -> . read ( id )
    (45) If -> . if ( Cond ) { Insts }
    (46) If -> . if ( Cond ) Inst
    (47) If -> . if ( Cond ) { Insts } else { Insts }
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (26) RepeatS -> . repeat
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    }               shift and go to state 198
    id              shift and go to state 33
    gid             shift and go to state 34
    return          shift and go to state 35
    print           shift and go to state 38
    println         shift and go to state 39
    prints          shift and go to state 40
    for             shift and go to state 43
    while           shift and go to state 44
    read            shift and go to state 45
    if              shift and go to state 46
    repeat          shift and go to state 48
    num             shift and go to state 42
    (               shift and go to state 36

    RepeatS                        shift and go to state 41
    Inst                           shift and go to state 21
    Attr                           shift and go to state 22
    Return                         shift and go to state 23
    Exp                            shift and go to state 24
    Print                          shift and go to state 25
    Println                        shift and go to state 26
    Prints                         shift and go to state 27
    Repeat                         shift and go to state 28
    For                            shift and go to state 29
    While                          shift and go to state 30
    Read                           shift and go to state 31
    If                             shift and go to state 32
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 190

    (27) For -> for ( Insts ; Cond ; . Insts ) { Insts }
    (12) Insts -> . Insts Inst
    (13) Insts -> .

    )               reduce using rule 13 (Insts -> .)
    id              reduce using rule 13 (Insts -> .)
    gid             reduce using rule 13 (Insts -> .)
    return          reduce using rule 13 (Insts -> .)
    print           reduce using rule 13 (Insts -> .)
    println         reduce using rule 13 (Insts -> .)
    prints          reduce using rule 13 (Insts -> .)
    for             reduce using rule 13 (Insts -> .)
    while           reduce using rule 13 (Insts -> .)
    read            reduce using rule 13 (Insts -> .)
    if              reduce using rule 13 (Insts -> .)
    repeat          reduce using rule 13 (Insts -> .)
    num             reduce using rule 13 (Insts -> .)
    (               reduce using rule 13 (Insts -> .)

    Insts                          shift and go to state 199

state 191

    (28) While -> while ( Cond ) { Insts . }
    (12) Insts -> Insts . Inst
    (14) Inst -> . Attr
    (15) Inst -> . Return
    (16) Inst -> . Exp
    (17) Inst -> . Print
    (18) Inst -> . Println
    (19) Inst -> . Prints
    (20) Inst -> . Repeat
    (21) Inst -> . For
    (22) Inst -> . While
    (23) Inst -> . Read
    (24) Inst -> . If
    (38) Attr -> . id = Exp
    (39) Attr -> . id [ Exp ] = Exp
    (40) Attr -> . id [ Exp ] [ Exp ] = Exp
    (41) Attr -> . gid = Exp
    (42) Attr -> . gid [ Exp ] = Exp
    (43) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (44) Return -> . return ( Exp )
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (30) Print -> . print ( Exp )
    (31) Println -> . println ( Exp )
    (32) Prints -> . prints ( string )
    (25) Repeat -> . RepeatS ( num ) { Insts }
    (27) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (28) While -> . while ( Cond ) { Insts }
    (29) Read -> . read ( id )
    (45) If -> . if ( Cond ) { Insts }
    (46) If -> . if ( Cond ) Inst
    (47) If -> . if ( Cond ) { Insts } else { Insts }
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (26) RepeatS -> . repeat
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    }               shift and go to state 200
    id              shift and go to state 33
    gid             shift and go to state 34
    return          shift and go to state 35
    print           shift and go to state 38
    println         shift and go to state 39
    prints          shift and go to state 40
    for             shift and go to state 43
    while           shift and go to state 44
    read            shift and go to state 45
    if              shift and go to state 46
    repeat          shift and go to state 48
    num             shift and go to state 42
    (               shift and go to state 36

    Inst                           shift and go to state 21
    Attr                           shift and go to state 22
    Return                         shift and go to state 23
    Exp                            shift and go to state 24
    Print                          shift and go to state 25
    Println                        shift and go to state 26
    Prints                         shift and go to state 27
    Repeat                         shift and go to state 28
    For                            shift and go to state 29
    While                          shift and go to state 30
    Read                           shift and go to state 31
    If                             shift and go to state 32
    Term                           shift and go to state 37
    RepeatS                        shift and go to state 41
    Factor                         shift and go to state 47

state 192

    (45) If -> if ( Cond ) { Insts . }
    (47) If -> if ( Cond ) { Insts . } else { Insts }
    (12) Insts -> Insts . Inst
    (14) Inst -> . Attr
    (15) Inst -> . Return
    (16) Inst -> . Exp
    (17) Inst -> . Print
    (18) Inst -> . Println
    (19) Inst -> . Prints
    (20) Inst -> . Repeat
    (21) Inst -> . For
    (22) Inst -> . While
    (23) Inst -> . Read
    (24) Inst -> . If
    (38) Attr -> . id = Exp
    (39) Attr -> . id [ Exp ] = Exp
    (40) Attr -> . id [ Exp ] [ Exp ] = Exp
    (41) Attr -> . gid = Exp
    (42) Attr -> . gid [ Exp ] = Exp
    (43) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (44) Return -> . return ( Exp )
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (30) Print -> . print ( Exp )
    (31) Println -> . println ( Exp )
    (32) Prints -> . prints ( string )
    (25) Repeat -> . RepeatS ( num ) { Insts }
    (27) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (28) While -> . while ( Cond ) { Insts }
    (29) Read -> . read ( id )
    (45) If -> . if ( Cond ) { Insts }
    (46) If -> . if ( Cond ) Inst
    (47) If -> . if ( Cond ) { Insts } else { Insts }
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (26) RepeatS -> . repeat
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    }               shift and go to state 201
    id              shift and go to state 33
    gid             shift and go to state 34
    return          shift and go to state 35
    print           shift and go to state 38
    println         shift and go to state 39
    prints          shift and go to state 40
    for             shift and go to state 43
    while           shift and go to state 44
    read            shift and go to state 45
    if              shift and go to state 46
    repeat          shift and go to state 48
    num             shift and go to state 42
    (               shift and go to state 36

    Inst                           shift and go to state 21
    Attr                           shift and go to state 22
    Return                         shift and go to state 23
    Exp                            shift and go to state 24
    Print                          shift and go to state 25
    Println                        shift and go to state 26
    Prints                         shift and go to state 27
    Repeat                         shift and go to state 28
    For                            shift and go to state 29
    While                          shift and go to state 30
    Read                           shift and go to state 31
    If                             shift and go to state 32
    Term                           shift and go to state 37
    RepeatS                        shift and go to state 41
    Factor                         shift and go to state 47

state 193

    (35) Dcl -> id [ num ] [ . num ]

    num             shift and go to state 202


state 194

    (40) Attr -> id [ Exp ] [ Exp ] . = Exp
    (75) Factor -> id [ Exp ] [ Exp ] .

    =               shift and go to state 203
    *               reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    /               reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    %               reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    +               reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    -               reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    }               reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    id              reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    gid             reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    return          reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    print           reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    println         reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    prints          reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    for             reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    while           reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    read            reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    if              reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    repeat          reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    num             reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    (               reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    ;               reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    )               reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)


state 195

    (43) Attr -> gid [ Exp ] [ Exp ] . = Exp
    (77) Factor -> gid [ Exp ] [ Exp ] .

    =               shift and go to state 204
    *               reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    /               reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    %               reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    +               reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    -               reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    }               reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    id              reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    gid             reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    return          reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    print           reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    println         reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    prints          reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    for             reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    while           reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    read            reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    if              reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    repeat          reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    num             reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    (               reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    ;               reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    )               reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)


state 196

    (75) Factor -> id [ Exp ] [ Exp . ]
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    ]               shift and go to state 205
    +               shift and go to state 51
    -               shift and go to state 52


state 197

    (77) Factor -> gid [ Exp ] [ Exp . ]
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    ]               shift and go to state 206
    +               shift and go to state 51
    -               shift and go to state 52


state 198

    (25) Repeat -> RepeatS ( num ) { Insts } .

    }               reduce using rule 25 (Repeat -> RepeatS ( num ) { Insts } .)
    id              reduce using rule 25 (Repeat -> RepeatS ( num ) { Insts } .)
    gid             reduce using rule 25 (Repeat -> RepeatS ( num ) { Insts } .)
    return          reduce using rule 25 (Repeat -> RepeatS ( num ) { Insts } .)
    print           reduce using rule 25 (Repeat -> RepeatS ( num ) { Insts } .)
    println         reduce using rule 25 (Repeat -> RepeatS ( num ) { Insts } .)
    prints          reduce using rule 25 (Repeat -> RepeatS ( num ) { Insts } .)
    for             reduce using rule 25 (Repeat -> RepeatS ( num ) { Insts } .)
    while           reduce using rule 25 (Repeat -> RepeatS ( num ) { Insts } .)
    read            reduce using rule 25 (Repeat -> RepeatS ( num ) { Insts } .)
    if              reduce using rule 25 (Repeat -> RepeatS ( num ) { Insts } .)
    repeat          reduce using rule 25 (Repeat -> RepeatS ( num ) { Insts } .)
    num             reduce using rule 25 (Repeat -> RepeatS ( num ) { Insts } .)
    (               reduce using rule 25 (Repeat -> RepeatS ( num ) { Insts } .)
    ;               reduce using rule 25 (Repeat -> RepeatS ( num ) { Insts } .)
    )               reduce using rule 25 (Repeat -> RepeatS ( num ) { Insts } .)


state 199

    (27) For -> for ( Insts ; Cond ; Insts . ) { Insts }
    (12) Insts -> Insts . Inst
    (14) Inst -> . Attr
    (15) Inst -> . Return
    (16) Inst -> . Exp
    (17) Inst -> . Print
    (18) Inst -> . Println
    (19) Inst -> . Prints
    (20) Inst -> . Repeat
    (21) Inst -> . For
    (22) Inst -> . While
    (23) Inst -> . Read
    (24) Inst -> . If
    (38) Attr -> . id = Exp
    (39) Attr -> . id [ Exp ] = Exp
    (40) Attr -> . id [ Exp ] [ Exp ] = Exp
    (41) Attr -> . gid = Exp
    (42) Attr -> . gid [ Exp ] = Exp
    (43) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (44) Return -> . return ( Exp )
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (30) Print -> . print ( Exp )
    (31) Println -> . println ( Exp )
    (32) Prints -> . prints ( string )
    (25) Repeat -> . RepeatS ( num ) { Insts }
    (27) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (28) While -> . while ( Cond ) { Insts }
    (29) Read -> . read ( id )
    (45) If -> . if ( Cond ) { Insts }
    (46) If -> . if ( Cond ) Inst
    (47) If -> . if ( Cond ) { Insts } else { Insts }
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (26) RepeatS -> . repeat
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    )               shift and go to state 207
    id              shift and go to state 33
    gid             shift and go to state 34
    return          shift and go to state 35
    print           shift and go to state 38
    println         shift and go to state 39
    prints          shift and go to state 40
    for             shift and go to state 43
    while           shift and go to state 44
    read            shift and go to state 45
    if              shift and go to state 46
    repeat          shift and go to state 48
    num             shift and go to state 42
    (               shift and go to state 36

    Inst                           shift and go to state 21
    Attr                           shift and go to state 22
    Return                         shift and go to state 23
    Exp                            shift and go to state 24
    Print                          shift and go to state 25
    Println                        shift and go to state 26
    Prints                         shift and go to state 27
    Repeat                         shift and go to state 28
    For                            shift and go to state 29
    While                          shift and go to state 30
    Read                           shift and go to state 31
    If                             shift and go to state 32
    Term                           shift and go to state 37
    RepeatS                        shift and go to state 41
    Factor                         shift and go to state 47

state 200

    (28) While -> while ( Cond ) { Insts } .

    }               reduce using rule 28 (While -> while ( Cond ) { Insts } .)
    id              reduce using rule 28 (While -> while ( Cond ) { Insts } .)
    gid             reduce using rule 28 (While -> while ( Cond ) { Insts } .)
    return          reduce using rule 28 (While -> while ( Cond ) { Insts } .)
    print           reduce using rule 28 (While -> while ( Cond ) { Insts } .)
    println         reduce using rule 28 (While -> while ( Cond ) { Insts } .)
    prints          reduce using rule 28 (While -> while ( Cond ) { Insts } .)
    for             reduce using rule 28 (While -> while ( Cond ) { Insts } .)
    while           reduce using rule 28 (While -> while ( Cond ) { Insts } .)
    read            reduce using rule 28 (While -> while ( Cond ) { Insts } .)
    if              reduce using rule 28 (While -> while ( Cond ) { Insts } .)
    repeat          reduce using rule 28 (While -> while ( Cond ) { Insts } .)
    num             reduce using rule 28 (While -> while ( Cond ) { Insts } .)
    (               reduce using rule 28 (While -> while ( Cond ) { Insts } .)
    ;               reduce using rule 28 (While -> while ( Cond ) { Insts } .)
    )               reduce using rule 28 (While -> while ( Cond ) { Insts } .)


state 201

    (45) If -> if ( Cond ) { Insts } .
    (47) If -> if ( Cond ) { Insts } . else { Insts }

    }               reduce using rule 45 (If -> if ( Cond ) { Insts } .)
    id              reduce using rule 45 (If -> if ( Cond ) { Insts } .)
    gid             reduce using rule 45 (If -> if ( Cond ) { Insts } .)
    return          reduce using rule 45 (If -> if ( Cond ) { Insts } .)
    print           reduce using rule 45 (If -> if ( Cond ) { Insts } .)
    println         reduce using rule 45 (If -> if ( Cond ) { Insts } .)
    prints          reduce using rule 45 (If -> if ( Cond ) { Insts } .)
    for             reduce using rule 45 (If -> if ( Cond ) { Insts } .)
    while           reduce using rule 45 (If -> if ( Cond ) { Insts } .)
    read            reduce using rule 45 (If -> if ( Cond ) { Insts } .)
    if              reduce using rule 45 (If -> if ( Cond ) { Insts } .)
    repeat          reduce using rule 45 (If -> if ( Cond ) { Insts } .)
    num             reduce using rule 45 (If -> if ( Cond ) { Insts } .)
    (               reduce using rule 45 (If -> if ( Cond ) { Insts } .)
    ;               reduce using rule 45 (If -> if ( Cond ) { Insts } .)
    )               reduce using rule 45 (If -> if ( Cond ) { Insts } .)
    else            shift and go to state 208


state 202

    (35) Dcl -> id [ num ] [ num . ]

    ]               shift and go to state 209


state 203

    (40) Attr -> id [ Exp ] [ Exp ] = . Exp
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 210
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 204

    (43) Attr -> gid [ Exp ] [ Exp ] = . Exp
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    id              shift and go to state 77
    gid             shift and go to state 78
    num             shift and go to state 42
    (               shift and go to state 36

    Exp                            shift and go to state 211
    Term                           shift and go to state 37
    Factor                         shift and go to state 47

state 205

    (75) Factor -> id [ Exp ] [ Exp ] .

    *               reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    /               reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    %               reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    )               reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    sup             reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    inf             reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    supeq           reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    infeq           reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    eq              reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    diff            reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    +               reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    -               reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    }               reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    id              reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    gid             reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    return          reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    print           reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    println         reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    prints          reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    for             reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    while           reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    read            reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    if              reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    repeat          reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    num             reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    (               reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    ;               reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    ]               reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    and             reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)
    or              reduce using rule 75 (Factor -> id [ Exp ] [ Exp ] .)


state 206

    (77) Factor -> gid [ Exp ] [ Exp ] .

    *               reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    /               reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    %               reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    )               reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    sup             reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    inf             reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    supeq           reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    infeq           reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    eq              reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    diff            reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    +               reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    -               reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    }               reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    id              reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    gid             reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    return          reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    print           reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    println         reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    prints          reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    for             reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    while           reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    read            reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    if              reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    repeat          reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    num             reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    (               reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    ;               reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    ]               reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    and             reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)
    or              reduce using rule 77 (Factor -> gid [ Exp ] [ Exp ] .)


state 207

    (27) For -> for ( Insts ; Cond ; Insts ) . { Insts }

    {               shift and go to state 212


state 208

    (47) If -> if ( Cond ) { Insts } else . { Insts }

    {               shift and go to state 213


state 209

    (35) Dcl -> id [ num ] [ num ] .

    }               reduce using rule 35 (Dcl -> id [ num ] [ num ] .)
    id              reduce using rule 35 (Dcl -> id [ num ] [ num ] .)


state 210

    (40) Attr -> id [ Exp ] [ Exp ] = Exp .
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    }               reduce using rule 40 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    id              reduce using rule 40 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    gid             reduce using rule 40 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    return          reduce using rule 40 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    print           reduce using rule 40 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    println         reduce using rule 40 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    prints          reduce using rule 40 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    for             reduce using rule 40 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    while           reduce using rule 40 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    read            reduce using rule 40 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    if              reduce using rule 40 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    repeat          reduce using rule 40 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    num             reduce using rule 40 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    (               reduce using rule 40 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    ;               reduce using rule 40 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    )               reduce using rule 40 (Attr -> id [ Exp ] [ Exp ] = Exp .)
    +               shift and go to state 51
    -               shift and go to state 52


state 211

    (43) Attr -> gid [ Exp ] [ Exp ] = Exp .
    (48) Exp -> Exp . + Term
    (49) Exp -> Exp . - Term

    }               reduce using rule 43 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    id              reduce using rule 43 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    gid             reduce using rule 43 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    return          reduce using rule 43 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    print           reduce using rule 43 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    println         reduce using rule 43 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    prints          reduce using rule 43 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    for             reduce using rule 43 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    while           reduce using rule 43 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    read            reduce using rule 43 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    if              reduce using rule 43 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    repeat          reduce using rule 43 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    num             reduce using rule 43 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    (               reduce using rule 43 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    ;               reduce using rule 43 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    )               reduce using rule 43 (Attr -> gid [ Exp ] [ Exp ] = Exp .)
    +               shift and go to state 51
    -               shift and go to state 52


state 212

    (27) For -> for ( Insts ; Cond ; Insts ) { . Insts }
    (12) Insts -> . Insts Inst
    (13) Insts -> .

    }               reduce using rule 13 (Insts -> .)
    id              reduce using rule 13 (Insts -> .)
    gid             reduce using rule 13 (Insts -> .)
    return          reduce using rule 13 (Insts -> .)
    print           reduce using rule 13 (Insts -> .)
    println         reduce using rule 13 (Insts -> .)
    prints          reduce using rule 13 (Insts -> .)
    for             reduce using rule 13 (Insts -> .)
    while           reduce using rule 13 (Insts -> .)
    read            reduce using rule 13 (Insts -> .)
    if              reduce using rule 13 (Insts -> .)
    repeat          reduce using rule 13 (Insts -> .)
    num             reduce using rule 13 (Insts -> .)
    (               reduce using rule 13 (Insts -> .)

    Insts                          shift and go to state 214

state 213

    (47) If -> if ( Cond ) { Insts } else { . Insts }
    (12) Insts -> . Insts Inst
    (13) Insts -> .

    }               reduce using rule 13 (Insts -> .)
    id              reduce using rule 13 (Insts -> .)
    gid             reduce using rule 13 (Insts -> .)
    return          reduce using rule 13 (Insts -> .)
    print           reduce using rule 13 (Insts -> .)
    println         reduce using rule 13 (Insts -> .)
    prints          reduce using rule 13 (Insts -> .)
    for             reduce using rule 13 (Insts -> .)
    while           reduce using rule 13 (Insts -> .)
    read            reduce using rule 13 (Insts -> .)
    if              reduce using rule 13 (Insts -> .)
    repeat          reduce using rule 13 (Insts -> .)
    num             reduce using rule 13 (Insts -> .)
    (               reduce using rule 13 (Insts -> .)

    Insts                          shift and go to state 215

state 214

    (27) For -> for ( Insts ; Cond ; Insts ) { Insts . }
    (12) Insts -> Insts . Inst
    (14) Inst -> . Attr
    (15) Inst -> . Return
    (16) Inst -> . Exp
    (17) Inst -> . Print
    (18) Inst -> . Println
    (19) Inst -> . Prints
    (20) Inst -> . Repeat
    (21) Inst -> . For
    (22) Inst -> . While
    (23) Inst -> . Read
    (24) Inst -> . If
    (38) Attr -> . id = Exp
    (39) Attr -> . id [ Exp ] = Exp
    (40) Attr -> . id [ Exp ] [ Exp ] = Exp
    (41) Attr -> . gid = Exp
    (42) Attr -> . gid [ Exp ] = Exp
    (43) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (44) Return -> . return ( Exp )
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (30) Print -> . print ( Exp )
    (31) Println -> . println ( Exp )
    (32) Prints -> . prints ( string )
    (25) Repeat -> . RepeatS ( num ) { Insts }
    (27) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (28) While -> . while ( Cond ) { Insts }
    (29) Read -> . read ( id )
    (45) If -> . if ( Cond ) { Insts }
    (46) If -> . if ( Cond ) Inst
    (47) If -> . if ( Cond ) { Insts } else { Insts }
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (26) RepeatS -> . repeat
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    }               shift and go to state 216
    id              shift and go to state 33
    gid             shift and go to state 34
    return          shift and go to state 35
    print           shift and go to state 38
    println         shift and go to state 39
    prints          shift and go to state 40
    for             shift and go to state 43
    while           shift and go to state 44
    read            shift and go to state 45
    if              shift and go to state 46
    repeat          shift and go to state 48
    num             shift and go to state 42
    (               shift and go to state 36

    Inst                           shift and go to state 21
    Attr                           shift and go to state 22
    Return                         shift and go to state 23
    Exp                            shift and go to state 24
    Print                          shift and go to state 25
    Println                        shift and go to state 26
    Prints                         shift and go to state 27
    Repeat                         shift and go to state 28
    For                            shift and go to state 29
    While                          shift and go to state 30
    Read                           shift and go to state 31
    If                             shift and go to state 32
    Term                           shift and go to state 37
    RepeatS                        shift and go to state 41
    Factor                         shift and go to state 47

state 215

    (47) If -> if ( Cond ) { Insts } else { Insts . }
    (12) Insts -> Insts . Inst
    (14) Inst -> . Attr
    (15) Inst -> . Return
    (16) Inst -> . Exp
    (17) Inst -> . Print
    (18) Inst -> . Println
    (19) Inst -> . Prints
    (20) Inst -> . Repeat
    (21) Inst -> . For
    (22) Inst -> . While
    (23) Inst -> . Read
    (24) Inst -> . If
    (38) Attr -> . id = Exp
    (39) Attr -> . id [ Exp ] = Exp
    (40) Attr -> . id [ Exp ] [ Exp ] = Exp
    (41) Attr -> . gid = Exp
    (42) Attr -> . gid [ Exp ] = Exp
    (43) Attr -> . gid [ Exp ] [ Exp ] = Exp
    (44) Return -> . return ( Exp )
    (48) Exp -> . Exp + Term
    (49) Exp -> . Exp - Term
    (50) Exp -> . id addeq Term
    (51) Exp -> . id subeq Term
    (52) Exp -> . id addeql Term
    (53) Exp -> . id subeql Term
    (54) Exp -> . Term
    (30) Print -> . print ( Exp )
    (31) Println -> . println ( Exp )
    (32) Prints -> . prints ( string )
    (25) Repeat -> . RepeatS ( num ) { Insts }
    (27) For -> . for ( Insts ; Cond ; Insts ) { Insts }
    (28) While -> . while ( Cond ) { Insts }
    (29) Read -> . read ( id )
    (45) If -> . if ( Cond ) { Insts }
    (46) If -> . if ( Cond ) Inst
    (47) If -> . if ( Cond ) { Insts } else { Insts }
    (55) Term -> . Term * Factor
    (56) Term -> . Term / Factor
    (57) Term -> . Term % Factor
    (58) Term -> . id muleq Factor
    (59) Term -> . id diveq Factor
    (60) Term -> . id modeq Factor
    (61) Term -> . id muleql Factor
    (62) Term -> . id diveql Factor
    (63) Term -> . id modeql Factor
    (64) Term -> . Factor
    (26) RepeatS -> . repeat
    (65) Factor -> . id plus
    (66) Factor -> . id plusl
    (67) Factor -> . id minus
    (68) Factor -> . id minusl
    (69) Factor -> . id
    (70) Factor -> . gid
    (71) Factor -> . num
    (72) Factor -> . id ( )
    (73) Factor -> . ( Cond )
    (74) Factor -> . id [ Exp ]
    (75) Factor -> . id [ Exp ] [ Exp ]
    (76) Factor -> . gid [ Exp ]
    (77) Factor -> . gid [ Exp ] [ Exp ]
    (78) Factor -> . ( Exp )

    }               shift and go to state 217
    id              shift and go to state 33
    gid             shift and go to state 34
    return          shift and go to state 35
    print           shift and go to state 38
    println         shift and go to state 39
    prints          shift and go to state 40
    for             shift and go to state 43
    while           shift and go to state 44
    read            shift and go to state 45
    if              shift and go to state 46
    repeat          shift and go to state 48
    num             shift and go to state 42
    (               shift and go to state 36

    Inst                           shift and go to state 21
    Attr                           shift and go to state 22
    Return                         shift and go to state 23
    Exp                            shift and go to state 24
    Print                          shift and go to state 25
    Println                        shift and go to state 26
    Prints                         shift and go to state 27
    Repeat                         shift and go to state 28
    For                            shift and go to state 29
    While                          shift and go to state 30
    Read                           shift and go to state 31
    If                             shift and go to state 32
    Term                           shift and go to state 37
    RepeatS                        shift and go to state 41
    Factor                         shift and go to state 47

state 216

    (27) For -> for ( Insts ; Cond ; Insts ) { Insts } .

    }               reduce using rule 27 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    id              reduce using rule 27 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    gid             reduce using rule 27 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    return          reduce using rule 27 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    print           reduce using rule 27 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    println         reduce using rule 27 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    prints          reduce using rule 27 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    for             reduce using rule 27 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    while           reduce using rule 27 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    read            reduce using rule 27 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    if              reduce using rule 27 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    repeat          reduce using rule 27 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    num             reduce using rule 27 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    (               reduce using rule 27 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    ;               reduce using rule 27 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)
    )               reduce using rule 27 (For -> for ( Insts ; Cond ; Insts ) { Insts } .)


state 217

    (47) If -> if ( Cond ) { Insts } else { Insts } .

    }               reduce using rule 47 (If -> if ( Cond ) { Insts } else { Insts } .)
    id              reduce using rule 47 (If -> if ( Cond ) { Insts } else { Insts } .)
    gid             reduce using rule 47 (If -> if ( Cond ) { Insts } else { Insts } .)
    return          reduce using rule 47 (If -> if ( Cond ) { Insts } else { Insts } .)
    print           reduce using rule 47 (If -> if ( Cond ) { Insts } else { Insts } .)
    println         reduce using rule 47 (If -> if ( Cond ) { Insts } else { Insts } .)
    prints          reduce using rule 47 (If -> if ( Cond ) { Insts } else { Insts } .)
    for             reduce using rule 47 (If -> if ( Cond ) { Insts } else { Insts } .)
    while           reduce using rule 47 (If -> if ( Cond ) { Insts } else { Insts } .)
    read            reduce using rule 47 (If -> if ( Cond ) { Insts } else { Insts } .)
    if              reduce using rule 47 (If -> if ( Cond ) { Insts } else { Insts } .)
    repeat          reduce using rule 47 (If -> if ( Cond ) { Insts } else { Insts } .)
    num             reduce using rule 47 (If -> if ( Cond ) { Insts } else { Insts } .)
    (               reduce using rule 47 (If -> if ( Cond ) { Insts } else { Insts } .)
    ;               reduce using rule 47 (If -> if ( Cond ) { Insts } else { Insts } .)
    )               reduce using rule 47 (If -> if ( Cond ) { Insts } else { Insts } .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ( in state 33 resolved as shift
WARNING: shift/reduce conflict for ( in state 77 resolved as shift
WARNING: shift/reduce conflict for ( in state 95 resolved as shift
WARNING: shift/reduce conflict for ( in state 103 resolved as shift
WARNING: shift/reduce conflict for and in state 147 resolved as shift
WARNING: shift/reduce conflict for or in state 147 resolved as shift
WARNING: shift/reduce conflict for and in state 148 resolved as shift
WARNING: shift/reduce conflict for or in state 148 resolved as shift
WARNING: shift/reduce conflict for ) in state 171 resolved as shift
WARNING: shift/reduce conflict for and in state 171 resolved as shift
WARNING: shift/reduce conflict for or in state 171 resolved as shift
WARNING: shift/reduce conflict for ) in state 172 resolved as shift
WARNING: shift/reduce conflict for and in state 172 resolved as shift
WARNING: shift/reduce conflict for or in state 172 resolved as shift
